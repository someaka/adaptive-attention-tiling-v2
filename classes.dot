digraph "classes" {
rankdir=BT
charset="utf-8"
".Protocol" [color="black", fontcolor="black", label=<{.Protocol|<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
".Protocol" [color="black", fontcolor="black", label=<{.Protocol|<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
".Protocol" [color="black", fontcolor="black", label=<{.Protocol|<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
".Protocol" [color="black", fontcolor="black", label=<{.Protocol|<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
".Protocol" [color="black", fontcolor="black", label=<{.Protocol|<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
".StructureGroup" [color="black", fontcolor="black", label=<{.StructureGroup|<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
".T" [color="black", fontcolor="black", label=<{.T|<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
".T" [color="black", fontcolor="black", label=<{.T|<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
".T_destination" [color="black", fontcolor="black", label=<{.T_destination|<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"line_profiler.line_profiler.LineProfiler" [color="black", fontcolor="black", label=<{line_profiler.line_profiler.LineProfiler|<br ALIGN="LEFT"/>|add_module(mod)<br ALIGN="LEFT"/>dump_stats(filename)<br ALIGN="LEFT"/>print_stats(stream, output_unit, stripzeros, details, summarize, sort, rich)<br ALIGN="LEFT"/>run(cmd)<br ALIGN="LEFT"/>runcall(func)<br ALIGN="LEFT"/>runctx(cmd, globals, locals)<br ALIGN="LEFT"/>wrap_classmethod(func)<br ALIGN="LEFT"/>wrap_coroutine(func)<br ALIGN="LEFT"/>wrap_function(func)<br ALIGN="LEFT"/>wrap_generator(func)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.core.attention.base.BaseAttention" [color="black", fontcolor="black", label=<{src.core.attention.base.BaseAttention|backend<br ALIGN="LEFT"/>|forward(query: torch.Tensor, key: torch.Tensor, value: torch.Tensor, mask: Optional[torch.Tensor]): torch.Tensor<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.core.attention.compute.AttentionCompute" [color="black", fontcolor="black", label=<{src.core.attention.compute.AttentionCompute|dropout : float<br ALIGN="LEFT"/>|compute_output(scores: torch.Tensor, value: torch.Tensor): torch.Tensor<br ALIGN="LEFT"/>compute_scores(query: torch.Tensor, key: torch.Tensor, mask: Optional[torch.Tensor], scale: Optional[float]): torch.Tensor<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.core.attention.geometric.EuclideanExponential" [color="black", fontcolor="black", label=<{src.core.attention.geometric.EuclideanExponential|dim : int<br ALIGN="LEFT"/>|forward(x: torch.Tensor, v: torch.Tensor): torch.Tensor<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.core.attention.geometric.EuclideanLogarithm" [color="black", fontcolor="black", label=<{src.core.attention.geometric.EuclideanLogarithm|dim : int<br ALIGN="LEFT"/>|forward(x: torch.Tensor, y: torch.Tensor): torch.Tensor<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.core.attention.geometric.GeometricStructures" [color="black", fontcolor="black", label=<{src.core.attention.geometric.GeometricStructures|connection<br ALIGN="LEFT"/>curvature : float<br ALIGN="LEFT"/>curvature_tensor<br ALIGN="LEFT"/>dim : int<br ALIGN="LEFT"/>exp_map : Union[HyperbolicExponential, EuclideanExponential]<br ALIGN="LEFT"/>log_map : Union[HyperbolicLogarithm, EuclideanLogarithm]<br ALIGN="LEFT"/>manifold_type : Literal['hyperbolic', 'euclidean']<br ALIGN="LEFT"/>metric<br ALIGN="LEFT"/>num_heads : int<br ALIGN="LEFT"/>parallel_transport_method : Literal['schild', 'pole']<br ALIGN="LEFT"/>transport<br ALIGN="LEFT"/>|compute_exponential_map(x: torch.Tensor, v: torch.Tensor): torch.Tensor<br ALIGN="LEFT"/>compute_geodesic(x: torch.Tensor, v: torch.Tensor, steps: int): torch.Tensor<br ALIGN="LEFT"/>compute_geodesic_distance(x: torch.Tensor, y: torch.Tensor): torch.Tensor<br ALIGN="LEFT"/>compute_logarithmic_map(x: torch.Tensor, y: torch.Tensor): torch.Tensor<br ALIGN="LEFT"/>compute_sectional_curvature(x: torch.Tensor, v1: torch.Tensor, v2: torch.Tensor): torch.Tensor<br ALIGN="LEFT"/>forward(x: torch.Tensor, y: torch.Tensor, v: Optional[torch.Tensor], return_diagnostics: bool): Dict[str, torch.Tensor]<br ALIGN="LEFT"/>parallel_transport_batch(x: torch.Tensor, y: torch.Tensor, v: torch.Tensor): torch.Tensor<br ALIGN="LEFT"/>process_points(x: torch.Tensor, y: torch.Tensor, v: Optional[torch.Tensor], return_diagnostics: bool): Dict[str, torch.Tensor]<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.core.attention.geometric.HyperbolicExponential" [color="black", fontcolor="black", label=<{src.core.attention.geometric.HyperbolicExponential|curvature<br ALIGN="LEFT"/>dim : int<br ALIGN="LEFT"/>eps : float<br ALIGN="LEFT"/>max_norm : float<br ALIGN="LEFT"/>|forward(x: torch.Tensor, v: torch.Tensor): torch.Tensor<br ALIGN="LEFT"/>minkowski_inner(x: torch.Tensor, y: torch.Tensor): torch.Tensor<br ALIGN="LEFT"/>minkowski_norm(v: torch.Tensor): torch.Tensor<br ALIGN="LEFT"/>project_to_hyperboloid(x: torch.Tensor): torch.Tensor<br ALIGN="LEFT"/>project_to_tangent(x: torch.Tensor, v: torch.Tensor): torch.Tensor<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.core.attention.geometric.HyperbolicLogarithm" [color="black", fontcolor="black", label=<{src.core.attention.geometric.HyperbolicLogarithm|curvature<br ALIGN="LEFT"/>dim : int<br ALIGN="LEFT"/>eps : float<br ALIGN="LEFT"/>max_dist : float<br ALIGN="LEFT"/>|forward(x: torch.Tensor, y: torch.Tensor): torch.Tensor<br ALIGN="LEFT"/>minkowski_inner(x: torch.Tensor, y: torch.Tensor): torch.Tensor<br ALIGN="LEFT"/>project_to_hyperboloid(x: torch.Tensor): torch.Tensor<br ALIGN="LEFT"/>project_to_tangent(x: torch.Tensor, v: torch.Tensor): torch.Tensor<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.core.attention.geometric.ParallelTransport" [color="black", fontcolor="black", label=<{src.core.attention.geometric.ParallelTransport|dim : int<br ALIGN="LEFT"/>method : Literal['schild', 'pole']<br ALIGN="LEFT"/>|forward(v: torch.Tensor, x: torch.Tensor, y: torch.Tensor, connection: Optional[torch.Tensor]): torch.Tensor<br ALIGN="LEFT"/>pole_ladder(v: torch.Tensor, x: torch.Tensor, y: torch.Tensor): torch.Tensor<br ALIGN="LEFT"/>schild_ladder(v: torch.Tensor, x: torch.Tensor, y: torch.Tensor, connection: Optional[torch.Tensor]): torch.Tensor<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.core.attention.routing.InformationRouter" [color="black", fontcolor="black", label=<{src.core.attention.routing.InformationRouter|bottleneck_detector<br ALIGN="LEFT"/>bottleneck_threshold : float<br ALIGN="LEFT"/>dim : int<br ALIGN="LEFT"/>exploration_rate : float<br ALIGN="LEFT"/>num_heads : int<br ALIGN="LEFT"/>path_predictor<br ALIGN="LEFT"/>pattern_dynamics<br ALIGN="LEFT"/>route_scorer<br ALIGN="LEFT"/>|detect_bottlenecks(states: torch.Tensor, routing_scores: torch.Tensor): tuple[torch.Tensor, torch.Tensor]<br ALIGN="LEFT"/>forward(states: torch.Tensor, return_diagnostics: bool): dict[str, torch.Tensor]<br ALIGN="LEFT"/>optimize_bottlenecks(states: torch.Tensor, bottlenecks: torch.Tensor, impact: torch.Tensor): torch.Tensor<br ALIGN="LEFT"/>predict_optimal_path(states: torch.Tensor, start_idx: torch.Tensor): torch.Tensor<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.core.backends.base.AttentionBackend" [color="black", fontcolor="black", label=<{src.core.backends.base.AttentionBackend|<br ALIGN="LEFT"/>|cleanup(): None<br ALIGN="LEFT"/>compute_attention(prepared_inputs: dict[str, Any], mask: Optional[torch.Tensor]): torch.Tensor<br ALIGN="LEFT"/>optimize_tiling(sequence_length: int, batch_size: int, num_heads: int): dict[str, int]<br ALIGN="LEFT"/>prepare_attention(query: torch.Tensor, key: torch.Tensor, value: torch.Tensor, tile_size: int): dict[str, Any]<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.core.benchmarks.metrics.BenchmarkMetrics" [color="black", fontcolor="black", label=<{src.core.benchmarks.metrics.BenchmarkMetrics|backward_time : float<br ALIGN="LEFT"/>batch_size : int<br ALIGN="LEFT"/>device : str<br ALIGN="LEFT"/>efficiency : float<br ALIGN="LEFT"/>flops : float<br ALIGN="LEFT"/>forward_time : float<br ALIGN="LEFT"/>memory_allocated_mb : float<br ALIGN="LEFT"/>memory_pool : Optional[MemoryPoolManager]<br ALIGN="LEFT"/>num_parameters : int<br ALIGN="LEFT"/>operations : List[OperationMetrics]<br ALIGN="LEFT"/>peak_memory_mb : float<br ALIGN="LEFT"/>throughput : float<br ALIGN="LEFT"/>total_time : float<br ALIGN="LEFT"/>|compute_throughput()<br ALIGN="LEFT"/>from_model(model: torch.nn.Module, input_size: tuple): 'BenchmarkMetrics'<br ALIGN="LEFT"/>record_operation(name: str)<br ALIGN="LEFT"/>to_dict(): Dict[str, Union[float, int, Dict[str, Any]]]<br ALIGN="LEFT"/>update_memory()<br ALIGN="LEFT"/>update_timing(forward_time: float, backward_time: float)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.core.benchmarks.metrics.OperationMetrics" [color="black", fontcolor="black", label=<{src.core.benchmarks.metrics.OperationMetrics|accuracy : Optional[float]<br ALIGN="LEFT"/>avg_memory : float<br ALIGN="LEFT"/>avg_time : float<br ALIGN="LEFT"/>batch_size : Optional[int]<br ALIGN="LEFT"/>batch_time : Optional[float]<br ALIGN="LEFT"/>convergence_rate : Optional[float]<br ALIGN="LEFT"/>efficiency : Optional[float]<br ALIGN="LEFT"/>name : str<br ALIGN="LEFT"/>sequential_time : Optional[float]<br ALIGN="LEFT"/>size : int<br ALIGN="LEFT"/>stability : Optional[float]<br ALIGN="LEFT"/>throughput : float<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"src.core.crystal.scale.AnomalyDetector" [color="black", fontcolor="black", label=<{src.core.crystal.scale.AnomalyDetector|detector<br ALIGN="LEFT"/>dim : int<br ALIGN="LEFT"/>max_degree : int<br ALIGN="LEFT"/>variables<br ALIGN="LEFT"/>|detect_anomalies(state: torch.Tensor): List[AnomalyPolynomial]<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.core.crystal.scale.RenormalizationFlow" [color="black", fontcolor="black", label=<{src.core.crystal.scale.RenormalizationFlow|beta_network<br ALIGN="LEFT"/>coupling_dim : int<br ALIGN="LEFT"/>fp_detector<br ALIGN="LEFT"/>max_iter : int<br ALIGN="LEFT"/>|beta_function(couplings: torch.Tensor): torch.Tensor<br ALIGN="LEFT"/>compute_flow_lines(start_points: torch.Tensor, num_steps: int): List[torch.Tensor]<br ALIGN="LEFT"/>find_fixed_points(initial_points: torch.Tensor): Tuple[List[torch.Tensor], List[torch.Tensor]]<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.core.crystal.scale.ScaleCohomology" [color="black", fontcolor="black", label=<{src.core.crystal.scale.ScaleCohomology|anomaly_det<br ALIGN="LEFT"/>callan_symanzik_net<br ALIGN="LEFT"/>conformal_net<br ALIGN="LEFT"/>dim : int<br ALIGN="LEFT"/>num_scales : int<br ALIGN="LEFT"/>ope_net<br ALIGN="LEFT"/>rg_flow<br ALIGN="LEFT"/>scale_conn<br ALIGN="LEFT"/>scale_inv<br ALIGN="LEFT"/>|analyze_cohomology(states: List[torch.Tensor], scales: List[float]): Dict[str, Any]<br ALIGN="LEFT"/>anomaly_polynomial(state: torch.Tensor): List[AnomalyPolynomial]<br ALIGN="LEFT"/>callan_symanzik_operator(state: torch.Tensor, coupling: torch.Tensor): torch.Tensor<br ALIGN="LEFT"/>conformal_symmetry(state: torch.Tensor): bool<br ALIGN="LEFT"/>fixed_points(observable: torch.Tensor): List[torch.Tensor]<br ALIGN="LEFT"/>minimal_invariant_number(): int<br ALIGN="LEFT"/>operator_product_expansion(op1: torch.Tensor, op2: torch.Tensor): torch.Tensor<br ALIGN="LEFT"/>renormalization_flow(observable: torch.Tensor): RGFlow<br ALIGN="LEFT"/>scale_connection(source_state: torch.Tensor, source_scale: float, target_scale: float): ScaleConnectionData<br ALIGN="LEFT"/>scale_invariants(structure: torch.Tensor): List[Tuple[torch.Tensor, float]]<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.core.crystal.scale.ScaleConnection" [color="black", fontcolor="black", label=<{src.core.crystal.scale.ScaleConnection|connections<br ALIGN="LEFT"/>dim : int<br ALIGN="LEFT"/>holonomy_computer<br ALIGN="LEFT"/>num_scales : int<br ALIGN="LEFT"/>|compute_holonomy(states: List[torch.Tensor]): torch.Tensor<br ALIGN="LEFT"/>connect_scales(source_state: torch.Tensor, source_scale: float, target_scale: float): torch.Tensor<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.core.crystal.scale.ScaleInvariance" [color="black", fontcolor="black", label=<{src.core.crystal.scale.ScaleInvariance|dim : int<br ALIGN="LEFT"/>invariant_detector<br ALIGN="LEFT"/>num_scales : int<br ALIGN="LEFT"/>scale_transform<br ALIGN="LEFT"/>|check_invariance(state: torch.Tensor, scale_factor: float): bool<br ALIGN="LEFT"/>find_invariant_structures(states: torch.Tensor): List[Tuple[torch.Tensor, float]]<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.core.crystal.scale.ScaleSystem" [color="black", fontcolor="black", label=<{src.core.crystal.scale.ScaleSystem|anomaly<br ALIGN="LEFT"/>cohomology<br ALIGN="LEFT"/>connection<br ALIGN="LEFT"/>invariance<br ALIGN="LEFT"/>rg_flow<br ALIGN="LEFT"/>|analyze_scales(states: List[torch.Tensor], couplings: torch.Tensor): Tuple[RGFlow, List[AnomalyPolynomial], List[Tuple[torch.Tensor, float]], Dict[str, Any]]<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.core.flow.base.BaseGeometricFlow" [color="black", fontcolor="black", label=<{src.core.flow.base.BaseGeometricFlow|connection_net<br ALIGN="LEFT"/>curvature_net<br ALIGN="LEFT"/>dt : float<br ALIGN="LEFT"/>hidden_dim : int<br ALIGN="LEFT"/>manifold_dim : int<br ALIGN="LEFT"/>metric_net<br ALIGN="LEFT"/>stability_threshold : float<br ALIGN="LEFT"/>|compute_connection(metric: Tensor, points: Optional[Tensor]): Tensor<br ALIGN="LEFT"/>compute_curvature(metric: Tensor, connection: Optional[Tensor]): Tensor<br ALIGN="LEFT"/>compute_geodesic(start_point: Tensor, end_point: Tensor, num_steps: int): Tensor<br ALIGN="LEFT"/>compute_metric(points: Tensor, connection: Optional[Tensor]): Tensor<br ALIGN="LEFT"/>compute_ricci_tensor(metric: Tensor, points: Optional[Tensor], connection: Optional[Tensor]): Tensor<br ALIGN="LEFT"/>detect_singularities(metric: Tensor, points: Optional[Tensor], threshold: float): List[SingularityInfo[Tensor]]<br ALIGN="LEFT"/>flow_step(metric: Tensor, ricci: Optional[Tensor], timestep: float): Tuple[Tensor, FlowMetrics]<br ALIGN="LEFT"/>normalize_flow(flow: Tensor, metric: Optional[Tensor], method: str): Tensor<br ALIGN="LEFT"/>parallel_transport(vector: Tensor, start_point: Tensor, end_point: Tensor, connection: Optional[Tensor]): Tensor<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.core.flow.computation.FlowComputation" [color="black", fontcolor="black", label=<{src.core.flow.computation.FlowComputation|dim : int<br ALIGN="LEFT"/>potential<br ALIGN="LEFT"/>vector_field<br ALIGN="LEFT"/>|compute_gradient_flow(x: torch.Tensor, steps: int, step_size: float): List[torch.Tensor]<br ALIGN="LEFT"/>compute_hamiltonian_flow(x: torch.Tensor, p: torch.Tensor, steps: int, step_size: float): Tuple[List[torch.Tensor], List[torch.Tensor]]<br ALIGN="LEFT"/>compute_parallel_transport(curve: List[torch.Tensor], initial_vector: torch.Tensor): List[torch.Tensor]<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.core.flow.higher_order.HigherOrderFlow" [color="black", fontcolor="black", label=<{src.core.flow.higher_order.HigherOrderFlow|bach_flow_weight : float<br ALIGN="LEFT"/>bach_tensor_net<br ALIGN="LEFT"/>calabi_flow_weight : float<br ALIGN="LEFT"/>calabi_net<br ALIGN="LEFT"/>cross_curvature_net<br ALIGN="LEFT"/>cross_curvature_weight : float<br ALIGN="LEFT"/>fourth_order_net<br ALIGN="LEFT"/>fourth_order_weight : float<br ALIGN="LEFT"/>|compute_bach_tensor(metric: Tensor, ricci: Tensor): Tensor<br ALIGN="LEFT"/>compute_calabi_tensor(metric: Tensor, ricci: Tensor): Tensor<br ALIGN="LEFT"/>compute_cross_curvature(metric: Tensor, ricci: Tensor, pattern: Tensor): Tensor<br ALIGN="LEFT"/>compute_fourth_order_term(metric: Tensor, ricci: Tensor): Tensor<br ALIGN="LEFT"/>flow_step(metric: Tensor, ricci: Optional[Tensor], timestep: float): Tuple[Tensor, QuantumFlowMetrics]<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.core.flow.information_ricci.InformationRicciFlow" [color="black", fontcolor="black", label=<{src.core.flow.information_ricci.InformationRicciFlow|potential_net<br ALIGN="LEFT"/>stress_energy_net<br ALIGN="LEFT"/>stress_energy_weight : float<br ALIGN="LEFT"/>|compute_information_potential(points: Tensor): Tensor<br ALIGN="LEFT"/>compute_potential_hessian(points: Tensor): Tensor<br ALIGN="LEFT"/>compute_stress_energy_tensor(points: Tensor, metric: Tensor): Tensor<br ALIGN="LEFT"/>flow_step(metric: Tensor, ricci: Optional[Tensor], timestep: float): Tuple[Tensor, QuantumFlowMetrics]<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.core.flow.neural.NeuralGeometricFlow" [color="black", fontcolor="black", label=<{src.core.flow.neural.NeuralGeometricFlow|fisher_net<br ALIGN="LEFT"/>fisher_rao_weight : float<br ALIGN="LEFT"/>phase_tracking_enabled : bool<br ALIGN="LEFT"/>quantum_bridge<br ALIGN="LEFT"/>quantum_correction_net<br ALIGN="LEFT"/>quantum_correction_strength : float<br ALIGN="LEFT"/>quantum_weight : float<br ALIGN="LEFT"/>|compute_fisher_rao_metric(points: Tensor): Tensor<br ALIGN="LEFT"/>compute_metric(points: Tensor, connection: Optional[Tensor]): Tensor<br ALIGN="LEFT"/>compute_quantum_corrections(state: QuantumState, metric: Tensor): Tensor<br ALIGN="LEFT"/>flow_step(metric: Tensor, ricci: Optional[Tensor], timestep: float): Tuple[Tensor, QuantumFlowMetrics]<br ALIGN="LEFT"/>parallel_transport(vector: Tensor, start_point: Tensor, end_point: Tensor, connection: Optional[Tensor]): Tensor<br ALIGN="LEFT"/>prepare_quantum_state(points: Tensor, return_validation: bool): Union[QuantumState, Tuple[QuantumState, QuantumStateValidationResult]]<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.core.flow.pattern.PatternFormationFlow" [color="black", fontcolor="black", label=<{src.core.flow.pattern.PatternFormationFlow|arithmetic<br ALIGN="LEFT"/>control_net<br ALIGN="LEFT"/>diffusion_net<br ALIGN="LEFT"/>diffusion_strength : float<br ALIGN="LEFT"/>operadic<br ALIGN="LEFT"/>pattern_dynamics<br ALIGN="LEFT"/>pattern_evolution<br ALIGN="LEFT"/>pattern_formation<br ALIGN="LEFT"/>reaction_net<br ALIGN="LEFT"/>reaction_strength : float<br ALIGN="LEFT"/>stability_net<br ALIGN="LEFT"/>symplectic<br ALIGN="LEFT"/>transition<br ALIGN="LEFT"/>wave<br ALIGN="LEFT"/>|analyze_pattern_stability(points: Tensor, time_window: int): Dict[str, Union[Dict[str, Tensor], Tensor]]<br ALIGN="LEFT"/>apply_control(points: Tensor, target: Tensor, control_strength: float, timestep: float): Tuple[Tensor, Dict[str, Tensor]]<br ALIGN="LEFT"/>compute_connection(metric: Tensor, points: Optional[Tensor]): Tensor<br ALIGN="LEFT"/>compute_control_signal(current_state: Tensor, target_state: Tensor, control_strength: float): Tensor<br ALIGN="LEFT"/>compute_geodesic(start_point: Tensor, end_point: Tensor, num_steps: int): Tensor<br ALIGN="LEFT"/>compute_metric(points: Tensor, connection: Optional[Tensor]): Tensor<br ALIGN="LEFT"/>compute_ricci_tensor(metric: Tensor, points: Optional[Tensor], connection: Optional[Tensor]): Tensor<br ALIGN="LEFT"/>compute_stability_metrics(points: Tensor, metric: Optional[Tensor]): Dict[str, Tensor]<br ALIGN="LEFT"/>detect_bifurcations(points: Tensor, parameter: Tensor, threshold: float): List[float]<br ALIGN="LEFT"/>flow_step(metric: Tensor, ricci: Optional[Tensor], timestep: float): Tuple[Tensor, FlowMetrics]<br ALIGN="LEFT"/>parallel_transport(vector: Tensor, start_point: Tensor, end_point: Tensor, connection: Optional[Tensor]): Tensor<br ALIGN="LEFT"/>predict_stability(points: Tensor, metric: Optional[Tensor], connection: Optional[Tensor], ricci: Optional[Tensor]): Dict[str, Tensor]<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.core.flow.pattern_heat.PatternHeatFlow" [color="black", fontcolor="black", label=<{src.core.flow.pattern_heat.PatternHeatFlow|heat_diffusion_weight : float<br ALIGN="LEFT"/>pattern_net<br ALIGN="LEFT"/>|compute_laplace_beltrami(pattern: Tensor, metric: Tensor): Tensor<br ALIGN="LEFT"/>compute_pattern_gradient(pattern: Tensor, metric: Tensor): Tensor<br ALIGN="LEFT"/>evolve_pattern(pattern: Tensor, metric: Tensor, timestep: float): Tensor<br ALIGN="LEFT"/>flow_step(metric: Tensor, ricci: Optional[Tensor], timestep: float): Tuple[Tensor, QuantumFlowMetrics]<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.core.flow.protocol.FlowMetrics" [color="black", fontcolor="black", label=<{src.core.flow.protocol.FlowMetrics|energy : float<br ALIGN="LEFT"/>flow_magnitude : float<br ALIGN="LEFT"/>metric_determinant : float<br ALIGN="LEFT"/>normalized_flow : float<br ALIGN="LEFT"/>ricci_scalar : float<br ALIGN="LEFT"/>singularity : float<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"src.core.flow.protocol.GeometricFlowProtocol" [color="black", fontcolor="black", label=<{src.core.flow.protocol.GeometricFlowProtocol|<br ALIGN="LEFT"/>|<I>compute_connection</I>(metric: T, points: Optional[T]): T<br ALIGN="LEFT"/><I>compute_curvature</I>(metric: T, connection: Optional[T]): T<br ALIGN="LEFT"/><I>compute_geodesic</I>(start_point: T, end_point: T, num_steps: int): T<br ALIGN="LEFT"/><I>compute_metric</I>(points: T, connection: Optional[T]): T<br ALIGN="LEFT"/><I>compute_ricci_tensor</I>(metric: T, points: Optional[T], connection: Optional[T]): T<br ALIGN="LEFT"/><I>detect_singularities</I>(metric: T, points: Optional[T], threshold: float): List[SingularityInfo[T]]<br ALIGN="LEFT"/><I>flow_step</I>(metric: T, ricci: Optional[T], timestep: float): Tuple[T, FlowMetrics]<br ALIGN="LEFT"/><I>normalize_flow</I>(flow: T, metric: Optional[T], method: str): T<br ALIGN="LEFT"/><I>parallel_transport</I>(vector: T, start_point: T, end_point: T, connection: Optional[T]): T<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.core.flow.protocol.QuantumFlowMetrics" [color="black", fontcolor="black", label=<{src.core.flow.protocol.QuantumFlowMetrics|berry_phase : Optional[Tensor]<br ALIGN="LEFT"/>mean_curvature : Optional[Tensor]<br ALIGN="LEFT"/>quantum_corrections : Optional[Tensor]<br ALIGN="LEFT"/>quantum_entropy<br ALIGN="LEFT"/>|to_device(device: torch.device): 'QuantumFlowMetrics'<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.core.flow.protocol.RicciTensorNetwork" [color="black", fontcolor="black", label=<{src.core.flow.protocol.RicciTensorNetwork|hidden<br ALIGN="LEFT"/>hidden_dim<br ALIGN="LEFT"/>manifold_dim : int<br ALIGN="LEFT"/>output<br ALIGN="LEFT"/>projection<br ALIGN="LEFT"/>|forward(x: Tensor): Tensor<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.core.flow.protocol.SingularityInfo" [color="black", fontcolor="black", label=<{src.core.flow.protocol.SingularityInfo|condition_number : float<br ALIGN="LEFT"/>curvature : Optional[T]<br ALIGN="LEFT"/>determinant : float<br ALIGN="LEFT"/>index : int<br ALIGN="LEFT"/>location : Optional[T]<br ALIGN="LEFT"/>min_eigenvalue : float<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"src.core.flow.quantum.AnalyzerMetrics" [color="black", fontcolor="black", label=<{src.core.flow.quantum.AnalyzerMetrics|berry_phase : float<br ALIGN="LEFT"/>convergence : float<br ALIGN="LEFT"/>energy_conservation : float<br ALIGN="LEFT"/>holonomy : float<br ALIGN="LEFT"/>mean_curvature : float<br ALIGN="LEFT"/>quantum_corrections : float<br ALIGN="LEFT"/>ricci_scalar : float<br ALIGN="LEFT"/>stability : float<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"src.core.flow.quantum.GeometricFlowAnalyzer" [color="black", fontcolor="black", label=<{src.core.flow.quantum.GeometricFlowAnalyzer|flow<br ALIGN="LEFT"/>hilbert_space : Optional[HilbertSpace]<br ALIGN="LEFT"/>history : List[QuantumFlowMetrics]<br ALIGN="LEFT"/>preparation_validator<br ALIGN="LEFT"/>state_validator<br ALIGN="LEFT"/>|analyze_evolution(initial_metric: Tensor, num_steps: int, dt: float, points: Optional[Tensor], initial_state: Optional[QuantumState]): Tuple[List[AnalyzerMetrics], Optional[Dict[str, List[float]]]]<br ALIGN="LEFT"/>analyze_step(metric: Tensor, points: Optional[Tensor], timestep: float, quantum_state: Optional[QuantumState]): Tuple[Tensor, AnalyzerMetrics]<br ALIGN="LEFT"/>get_convergence_stats(): Dict[str, float]<br ALIGN="LEFT"/>validate_entanglement(state: QuantumState): EntanglementMetrics<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.core.flow.quantum.QuantumGeometricFlow" [color="black", fontcolor="black", label=<{src.core.flow.quantum.QuantumGeometricFlow|berry_connection<br ALIGN="LEFT"/>decoherence_rates : dict<br ALIGN="LEFT"/>entanglement_net<br ALIGN="LEFT"/>fubini_study_net<br ALIGN="LEFT"/>hbar : float<br ALIGN="LEFT"/>hilbert_space : Optional[HilbertSpace]<br ALIGN="LEFT"/>mean_curvature_net<br ALIGN="LEFT"/>quantum_transport_net<br ALIGN="LEFT"/>state_reconstruction_net<br ALIGN="LEFT"/>state_validator<br ALIGN="LEFT"/>tomography_validator<br ALIGN="LEFT"/>uncertainty_net<br ALIGN="LEFT"/>|compute_berry_phase(path: List[Tensor]): Tensor<br ALIGN="LEFT"/>compute_connection(metric: Tensor, points: Optional[Tensor]): Tensor<br ALIGN="LEFT"/>compute_decoherence_correction(metric: Tensor, quantum_state: Optional[QuantumState]): Tensor<br ALIGN="LEFT"/>compute_geodesic(start_point: Tensor, end_point: Tensor, num_steps: int): Tensor<br ALIGN="LEFT"/>compute_mean_curvature(points: Tensor): Tensor<br ALIGN="LEFT"/>compute_metric(points: Tensor, connection: Optional[Tensor]): Tensor<br ALIGN="LEFT"/>compute_quantum_metric_tensor(state: QuantumState, metric: Optional[Tensor]): Tensor<br ALIGN="LEFT"/>compute_quantum_metrics(quantum_state: Optional[QuantumState]): Dict[str, Optional[Tensor]]<br ALIGN="LEFT"/>compute_ricci_tensor(metric: Tensor, points: Optional[Tensor], connection: Optional[Tensor]): Tensor<br ALIGN="LEFT"/>flow_step(metric: Tensor, ricci: Optional[Tensor], timestep: float, quantum_state: Optional[QuantumState]): Tuple[Tensor, QuantumFlowMetrics]<br ALIGN="LEFT"/>parallel_transport(vector: Tensor, start_point: Tensor, end_point: Tensor, connection: Optional[Tensor]): Tensor<br ALIGN="LEFT"/>parallel_transport_state(state: QuantumState, vector: Tensor, connection: Optional[Tensor]): QuantumState<br ALIGN="LEFT"/>reconstruct_state(measurements: Dict[str, Tensor], bases: Optional[List[Tensor]]): Optional[QuantumState]<br ALIGN="LEFT"/>set_points(points: Tensor): None<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.core.metrics.advanced_metrics.AdvancedMetricsAnalyzer" [color="black", fontcolor="black", label=<{src.core.metrics.advanced_metrics.AdvancedMetricsAnalyzer|history : Dict[str, List[float]]<br ALIGN="LEFT"/>|compute_cross_tile_flow(pattern: torch.Tensor, tile_size: int): float<br ALIGN="LEFT"/>compute_edge_utilization(pattern: torch.Tensor, edge_threshold: float): float<br ALIGN="LEFT"/>compute_ifq(pattern: torch.Tensor, tile_size: int, window_size: int, edge_threshold: float): InformationFlowMetrics<br ALIGN="LEFT"/>compute_info_density(pattern: torch.Tensor): float<br ALIGN="LEFT"/>compute_pattern_stability(pattern: torch.Tensor, window_size: int): float<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.core.metrics.advanced_metrics.InformationFlowMetrics" [color="black", fontcolor="black", label=<{src.core.metrics.advanced_metrics.InformationFlowMetrics|cross_tile_flow : float<br ALIGN="LEFT"/>edge_utilization : float<br ALIGN="LEFT"/>info_density : float<br ALIGN="LEFT"/>pattern_stability : float<br ALIGN="LEFT"/>|compute_ifq(): float<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.core.metrics.evolution.ErgodicAnalysis" [color="black", fontcolor="black", label=<{src.core.metrics.evolution.ErgodicAnalysis|hidden_dim : int<br ALIGN="LEFT"/>history : List[torch.Tensor]<br ALIGN="LEFT"/>num_observables : int<br ALIGN="LEFT"/>observables<br ALIGN="LEFT"/>|compute_ergodic_average(pattern: torch.Tensor): torch.Tensor<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.core.metrics.evolution.EvolutionAnalyzer" [color="black", fontcolor="black", label=<{src.core.metrics.evolution.EvolutionAnalyzer|ergodic<br ALIGN="LEFT"/>flow<br ALIGN="LEFT"/>l_function<br ALIGN="LEFT"/>orbit<br ALIGN="LEFT"/>|analyze_evolution(pattern: torch.Tensor): EvolutionMetrics<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.core.metrics.evolution.EvolutionMetrics" [color="black", fontcolor="black", label=<{src.core.metrics.evolution.EvolutionMetrics|ergodic_avg<br ALIGN="LEFT"/>flow_metrics<br ALIGN="LEFT"/>l_values<br ALIGN="LEFT"/>orbit_stats : Dict[str, float]<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"src.core.metrics.evolution.FlowEvolution" [color="black", fontcolor="black", label=<{src.core.metrics.evolution.FlowEvolution|flow<br ALIGN="LEFT"/>flow_dim : int<br ALIGN="LEFT"/>hidden_dim : int<br ALIGN="LEFT"/>history : List[torch.Tensor]<br ALIGN="LEFT"/>|compute_flow(pattern: torch.Tensor): torch.Tensor<br ALIGN="LEFT"/>get_evolution_stats(window_size: int): Dict[str, torch.Tensor]<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.core.metrics.evolution.LFunctionComputation" [color="black", fontcolor="black", label=<{src.core.metrics.evolution.LFunctionComputation|hidden_dim : int<br ALIGN="LEFT"/>network<br ALIGN="LEFT"/>num_factors : int<br ALIGN="LEFT"/>rank : int<br ALIGN="LEFT"/>|compute_l_values(pattern: torch.Tensor): torch.Tensor<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.core.metrics.evolution.OrbitAnalysis" [color="black", fontcolor="black", label=<{src.core.metrics.evolution.OrbitAnalysis|hidden_dim : int<br ALIGN="LEFT"/>history : List[torch.Tensor]<br ALIGN="LEFT"/>orbit_dim : int<br ALIGN="LEFT"/>projection<br ALIGN="LEFT"/>|analyze_orbit(pattern: torch.Tensor): Dict[str, float]<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.core.metrics.height_theory.AdaptiveHeightTheory" [color="black", fontcolor="black", label=<{src.core.metrics.height_theory.AdaptiveHeightTheory|height_projection<br ALIGN="LEFT"/>height_structure<br ALIGN="LEFT"/>hidden_dim : int<br ALIGN="LEFT"/>history<br ALIGN="LEFT"/>optimizer<br ALIGN="LEFT"/>|adapt(loss: torch.Tensor): None<br ALIGN="LEFT"/>forward(x: torch.Tensor): Tuple[torch.Tensor, Dict[str, torch.Tensor]]<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.core.metrics.height_theory.HeightStructure" [color="black", fontcolor="black", label=<{src.core.metrics.height_theory.HeightStructure|base_field : str<br ALIGN="LEFT"/>local_heights<br ALIGN="LEFT"/>num_primes : int<br ALIGN="LEFT"/>prime_bases<br ALIGN="LEFT"/>|analyze_growth(points: List[torch.Tensor], window_size: int): Dict[str, torch.Tensor]<br ALIGN="LEFT"/>compute_canonical_height(point: torch.Tensor): torch.Tensor<br ALIGN="LEFT"/>compute_local_height(point: torch.Tensor, prime: int): torch.Tensor<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.core.models.base.LayerGeometry" [color="black", fontcolor="black", label=<{src.core.models.base.LayerGeometry|connection_coeffs<br ALIGN="LEFT"/>manifold_dim : int<br ALIGN="LEFT"/>metric_tensor<br ALIGN="LEFT"/>pattern_dim : NoneType<br ALIGN="LEFT"/>|connection(points: torch.Tensor): torch.Tensor<br ALIGN="LEFT"/>get_riemannian_framework(points: torch.Tensor): PatternRiemannianStructure<br ALIGN="LEFT"/>metric(points: torch.Tensor): torch.Tensor<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.core.models.base.LayerGeometryDict" [color="black", fontcolor="black", label=<{src.core.models.base.LayerGeometryDict|<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"src.core.models.base.ModelGeometry" [color="black", fontcolor="black", label=<{src.core.models.base.ModelGeometry|attention_heads<br ALIGN="LEFT"/>key_dim : int<br ALIGN="LEFT"/>layers<br ALIGN="LEFT"/>manifold_dim : int<br ALIGN="LEFT"/>query_dim : int<br ALIGN="LEFT"/>|add_attention_head(head: nn.Module)<br ALIGN="LEFT"/>add_layer(name: str, layer: LayerGeometry)<br ALIGN="LEFT"/>get_attention_head(idx: int): nn.Module<br ALIGN="LEFT"/>get_layer(name: str): LayerGeometry<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.core.patterns.base_flow.BaseGeometricFlow" [color="black", fontcolor="black", label=<{src.core.patterns.base_flow.BaseGeometricFlow|dt : float<br ALIGN="LEFT"/>flow_layers<br ALIGN="LEFT"/>hidden_dim<br ALIGN="LEFT"/>manifold_dim : int<br ALIGN="LEFT"/>metric_net<br ALIGN="LEFT"/>num_layers : int<br ALIGN="LEFT"/>stability_threshold : float<br ALIGN="LEFT"/>|compute_metric(x: torch.Tensor): torch.Tensor<br ALIGN="LEFT"/>compute_ricci_tensor(metric: torch.Tensor, connection: Optional[torch.Tensor]): torch.Tensor<br ALIGN="LEFT"/>detect_singularities(flow: torch.Tensor, threshold: float): List[Dict[str, Any]]<br ALIGN="LEFT"/>flow_step(metric: torch.Tensor, ricci: torch.Tensor, timestep: float): Tuple[torch.Tensor, Dict[str, Any]]<br ALIGN="LEFT"/>forward(x: torch.Tensor, return_path: bool): Tuple[torch.Tensor, Dict[str, Any]]<br ALIGN="LEFT"/>normalize_flow(flow: torch.Tensor, normalization: str): torch.Tensor<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.core.patterns.dynamics.PatternDynamics" [color="black", fontcolor="black", label=<{src.core.patterns.dynamics.PatternDynamics|device<br ALIGN="LEFT"/>dt : float<br ALIGN="LEFT"/>|<I>compute_conserved_quantities</I>(state: torch.Tensor): Dict[str, torch.Tensor]<br ALIGN="LEFT"/><I>compute_energy</I>(state: torch.Tensor): Dict[str, torch.Tensor]<br ALIGN="LEFT"/><I>compute_flow</I>(state: torch.Tensor): torch.Tensor<br ALIGN="LEFT"/><I>evolve</I>(state: torch.Tensor, time: float): torch.Tensor<br ALIGN="LEFT"/>evolve_pattern_field(pattern: torch.Tensor, field_operator: Optional[torch.Tensor]): Tuple[torch.Tensor, Dict[str, Any]]<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.core.patterns.enriched_structure.EnrichedMorphism" [color="black", fontcolor="black", label=<{src.core.patterns.enriched_structure.EnrichedMorphism|source_space<br ALIGN="LEFT"/>structure_map<br ALIGN="LEFT"/>target_space<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"src.core.patterns.enriched_structure.EnrichedTransition" [color="black", fontcolor="black", label=<{src.core.patterns.enriched_structure.EnrichedTransition|<br ALIGN="LEFT"/>|<I>compose</I>(first: EnrichedMorphism, second: EnrichedMorphism): EnrichedMorphism<br ALIGN="LEFT"/><I>create_morphism</I>(source: Tensor, target: Tensor): EnrichedMorphism<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.core.patterns.enriched_structure.PatternTransition" [color="black", fontcolor="black", label=<{src.core.patterns.enriched_structure.PatternTransition|wave<br ALIGN="LEFT"/>|compose(first: EnrichedMorphism, second: EnrichedMorphism): EnrichedMorphism<br ALIGN="LEFT"/>create_morphism(source: Tensor, target: Tensor): EnrichedMorphism<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.core.patterns.enriched_structure.WaveEmergence" [color="black", fontcolor="black", label=<{src.core.patterns.enriched_structure.WaveEmergence|dt : float<br ALIGN="LEFT"/>num_steps : int<br ALIGN="LEFT"/>|evolve_structure(pattern: Tensor, direction: Tensor): Tensor<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.core.patterns.evolution.PatternEvolution" [color="black", fontcolor="black", label=<{src.core.patterns.evolution.PatternEvolution|enriched<br ALIGN="LEFT"/>framework<br ALIGN="LEFT"/>learning_rate : float<br ALIGN="LEFT"/>momentum : float<br ALIGN="LEFT"/>operadic<br ALIGN="LEFT"/>preserve_structure : bool<br ALIGN="LEFT"/>symplectic<br ALIGN="LEFT"/>velocity : NoneType<br ALIGN="LEFT"/>wave_enabled : bool<br ALIGN="LEFT"/>|compute_hamiltonian(pattern: torch.Tensor, momentum: torch.Tensor): torch.Tensor<br ALIGN="LEFT"/>reset()<br ALIGN="LEFT"/>step(pattern: torch.Tensor, gradient: torch.Tensor, mask: Optional[torch.Tensor], return_metrics: bool): Tuple[torch.Tensor, torch.Tensor]<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.core.patterns.evolution.PatternEvolutionMetrics" [color="black", fontcolor="black", label=<{src.core.patterns.evolution.PatternEvolutionMetrics|geometric_flow<br ALIGN="LEFT"/>momentum_norm : float<br ALIGN="LEFT"/>quantum_metric<br ALIGN="LEFT"/>symplectic_invariant : float<br ALIGN="LEFT"/>velocity_norm : float<br ALIGN="LEFT"/>wave_energy : float<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"src.core.patterns.fiber_bundle.BaseFiberBundle" [color="black", fontcolor="black", label=<{src.core.patterns.fiber_bundle.BaseFiberBundle|base_dim : int<br ALIGN="LEFT"/>connection<br ALIGN="LEFT"/>fiber_dim<br ALIGN="LEFT"/>metric<br ALIGN="LEFT"/>structure_group : Optional[str]<br ALIGN="LEFT"/>total_dim<br ALIGN="LEFT"/>|bundle_projection(total_space: Tensor): Tensor<br ALIGN="LEFT"/>compute_holonomy_algebra(holonomies: List[Tensor]): Tensor<br ALIGN="LEFT"/>compute_holonomy_group(holonomies: List[Tensor]): Tensor<br ALIGN="LEFT"/>compute_metric(points: torch.Tensor): MetricTensor[torch.Tensor]<br ALIGN="LEFT"/>connection_form(tangent_vector: Tensor): Tensor<br ALIGN="LEFT"/>local_trivialization(point: Tensor): Tuple[LocalChart[Tensor], FiberChart[Tensor, str]]<br ALIGN="LEFT"/>parallel_transport(section: Tensor, path: Tensor): Tensor<br ALIGN="LEFT"/>transition_functions(chart1: LocalChart[Tensor], chart2: LocalChart[Tensor]): Tensor<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.core.patterns.fiber_types.FiberBundle" [color="black", fontcolor="black", label=<{src.core.patterns.fiber_types.FiberBundle|<br ALIGN="LEFT"/>|bundle_projection(total_space: T): T<br ALIGN="LEFT"/>connection_form(tangent_vector: T): T<br ALIGN="LEFT"/>local_trivialization(point: T): Tuple[LocalChart[T], FiberChart[T, str]]<br ALIGN="LEFT"/>parallel_transport(section: T, path: T): T<br ALIGN="LEFT"/>transition_functions(chart1: T, chart2: T): T<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.core.patterns.fiber_types.FiberChart" [color="black", fontcolor="black", label=<{src.core.patterns.fiber_types.FiberChart|fiber_coordinates<br ALIGN="LEFT"/>structure_group<br ALIGN="LEFT"/>transition_functions : dict<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"src.core.patterns.fiber_types.FiberType" [color="black", fontcolor="black", label=<{src.core.patterns.fiber_types.FiberType|dimension : int<br ALIGN="LEFT"/>is_complex : bool<br ALIGN="LEFT"/>is_oriented : bool<br ALIGN="LEFT"/>metric_type : str<br ALIGN="LEFT"/>name : str<br ALIGN="LEFT"/>structure_group : str<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"src.core.patterns.fiber_types.FiberTypeManager" [color="black", fontcolor="black", label=<{src.core.patterns.fiber_types.FiberTypeManager|<br ALIGN="LEFT"/>|check_compatibility(fiber_type: str, structure_group: str): bool<br ALIGN="LEFT"/>convert_fiber_type(section: Tensor, source_type: str, target_type: str, fiber_dim: int): Tensor<br ALIGN="LEFT"/>get_fiber_type(name: str): Optional[FiberType]<br ALIGN="LEFT"/>get_structure_group(name: str): Optional[Dict]<br ALIGN="LEFT"/>list_fiber_types(): List[str]<br ALIGN="LEFT"/>list_structure_groups(): List[str]<br ALIGN="LEFT"/>register_conversion(source_type: str, target_type: str, conversion_fn: Callable[[Tensor], Tensor]): None<br ALIGN="LEFT"/>register_fiber_type(fiber_type: FiberType): None<br ALIGN="LEFT"/>validate_fiber_type(section: Tensor, fiber_type: str, fiber_dim: int): bool<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.core.patterns.fiber_types.LocalChart" [color="black", fontcolor="black", label=<{src.core.patterns.fiber_types.LocalChart|coordinates<br ALIGN="LEFT"/>dimension : int<br ALIGN="LEFT"/>transition_maps : dict<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"src.core.patterns.formation.BifurcationAnalyzer" [color="black", fontcolor="black", label=<{src.core.patterns.formation.BifurcationAnalyzer|enriched<br ALIGN="LEFT"/>operadic<br ALIGN="LEFT"/>preserve_structure : bool<br ALIGN="LEFT"/>symplectic<br ALIGN="LEFT"/>threshold : float<br ALIGN="LEFT"/>wave_enabled : bool<br ALIGN="LEFT"/>window_size : int<br ALIGN="LEFT"/>|analyze_stability(pattern: torch.Tensor, parameter_range: Tuple[float, float], num_points: int): Dict[str, Any]<br ALIGN="LEFT"/>detect_bifurcations(pattern: torch.Tensor, parameter: torch.Tensor): List[float]<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.core.patterns.formation.BifurcationMetrics" [color="black", fontcolor="black", label=<{src.core.patterns.formation.BifurcationMetrics|geometric_flow<br ALIGN="LEFT"/>max_eigenvalue : float<br ALIGN="LEFT"/>pattern_height : float<br ALIGN="LEFT"/>quantum_metric<br ALIGN="LEFT"/>stability_margin : float<br ALIGN="LEFT"/>symplectic_invariant : float<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"src.core.patterns.formation.PatternFormation" [color="black", fontcolor="black", label=<{src.core.patterns.formation.PatternFormation|diffusion_coeff : float<br ALIGN="LEFT"/>diffusion_kernel<br ALIGN="LEFT"/>dim : int<br ALIGN="LEFT"/>dt : float<br ALIGN="LEFT"/>enriched<br ALIGN="LEFT"/>operadic<br ALIGN="LEFT"/>preserve_structure : bool<br ALIGN="LEFT"/>reaction_coeff : float<br ALIGN="LEFT"/>symplectic<br ALIGN="LEFT"/>wave_enabled : bool<br ALIGN="LEFT"/>|compute_energy(pattern: torch.Tensor): torch.Tensor<br ALIGN="LEFT"/>compute_stability(pattern: torch.Tensor): Dict[str, Any]<br ALIGN="LEFT"/>evolve(pattern: torch.Tensor, time_steps: int): torch.Tensor<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.core.patterns.motivic_integration.MotivicIntegrationSystem" [color="black", fontcolor="black", label=<{src.core.patterns.motivic_integration.MotivicIntegrationSystem|cache : Dict[str, Any]<br ALIGN="LEFT"/>cohomology<br ALIGN="LEFT"/>device<br ALIGN="LEFT"/>dtype : Ellipsis<br ALIGN="LEFT"/>dynamics<br ALIGN="LEFT"/>geometry<br ALIGN="LEFT"/>hidden_dim : int<br ALIGN="LEFT"/>integrator<br ALIGN="LEFT"/>manifold_dim : int<br ALIGN="LEFT"/>monte_carlo_steps : int<br ALIGN="LEFT"/>motive_rank : int<br ALIGN="LEFT"/>num_primes : int<br ALIGN="LEFT"/>num_samples : int<br ALIGN="LEFT"/>|compute_integral(pattern: Tensor, with_quantum: bool): Tuple[Tensor, Dict[str, Any]]<br ALIGN="LEFT"/>compute_measure(pattern: Tensor, with_quantum: bool): Tuple[Tensor, Dict[str, Any]]<br ALIGN="LEFT"/>compute_stability_metrics(pattern: Tensor, num_perturbations: int, perturbation_scale: float): Dict[str, float]<br ALIGN="LEFT"/>evolve_integral(pattern: Tensor, time_steps: int, with_quantum: bool): Tuple[List[Tensor], Dict[str, Any]]<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.core.patterns.motivic_integration.MotivicRiemannianStructureImpl" [color="black", fontcolor="black", label=<{src.core.patterns.motivic_integration.MotivicRiemannianStructureImpl|hidden_dim : int<br ALIGN="LEFT"/>motive_rank : int<br ALIGN="LEFT"/>num_primes : int<br ALIGN="LEFT"/>structure<br ALIGN="LEFT"/>|compute_riemann(points: Tensor): CurvatureTensor[Tensor]<br ALIGN="LEFT"/>exp_map(point: Tensor, vector: Tensor): Tensor<br ALIGN="LEFT"/>forward(): Any<br ALIGN="LEFT"/>geodesic_flow(initial_point: Tensor, initial_velocity: Tensor, steps: int, step_size: float): Tuple[Tensor, Tensor]<br ALIGN="LEFT"/>get_christoffel_values(points: Tensor): Tensor<br ALIGN="LEFT"/>get_metric_tensor(points: Tensor): Tensor<br ALIGN="LEFT"/>get_riemann_tensor(points: Tensor): Tensor<br ALIGN="LEFT"/>lie_derivative_metric(point: Tensor, vector_field: Callable[[Tensor], Tensor]): MotivicMetricTensor<br ALIGN="LEFT"/>sectional_curvature(point: Tensor, v1: Tensor, v2: Tensor): Union[float, Tensor]<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.core.patterns.motivic_riemannian.MotivicChristoffelSymbols" [color="black", fontcolor="black", label=<{src.core.patterns.motivic_riemannian.MotivicChristoffelSymbols|dynamics<br ALIGN="LEFT"/>dynamics_state<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"src.core.patterns.motivic_riemannian.MotivicCurvatureTensor" [color="black", fontcolor="black", label=<{src.core.patterns.motivic_riemannian.MotivicCurvatureTensor|cohomology_class<br ALIGN="LEFT"/>motive<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"src.core.patterns.motivic_riemannian.MotivicMetricTensor" [color="black", fontcolor="black", label=<{src.core.patterns.motivic_riemannian.MotivicMetricTensor|height_data<br ALIGN="LEFT"/>height_structure<br ALIGN="LEFT"/>|with_height(new_values: Tensor): 'MotivicMetricTensor'<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.core.patterns.motivic_riemannian.MotivicRiemannianStructure" [color="black", fontcolor="black", label=<{src.core.patterns.motivic_riemannian.MotivicRiemannianStructure|cache : Dict[str, Any]<br ALIGN="LEFT"/>connection_coeffs<br ALIGN="LEFT"/>connection_map<br ALIGN="LEFT"/>device<br ALIGN="LEFT"/>dtype : Ellipsis<br ALIGN="LEFT"/>dynamics<br ALIGN="LEFT"/>fiber_map<br ALIGN="LEFT"/>height_structure<br ALIGN="LEFT"/>hidden_dim : int<br ALIGN="LEFT"/>manifold_dim : int<br ALIGN="LEFT"/>metric_factors<br ALIGN="LEFT"/>motive<br ALIGN="LEFT"/>motive_rank : int<br ALIGN="LEFT"/>|bundle_projection(total_space: Tensor): Tensor<br ALIGN="LEFT"/>compute_christoffel(points: Tensor): MotivicChristoffelSymbols<br ALIGN="LEFT"/>compute_curvature(points: Tensor, christoffel: Optional[MotivicChristoffelSymbols]): MotivicCurvatureTensor<br ALIGN="LEFT"/>compute_metric(points: Tensor): MotivicMetricTensor<br ALIGN="LEFT"/>connection_form(tangent_vector: Tensor): Tensor<br ALIGN="LEFT"/>get_connection(point: Tensor): Tensor<br ALIGN="LEFT"/>get_fiber(point: Tensor): Tensor<br ALIGN="LEFT"/>local_trivialization(point: Tensor): Tuple[LocalChart[Tensor], FiberChart[Tensor, str]]<br ALIGN="LEFT"/>parallel_transport(section: Tensor, path: Tensor): Tensor<br ALIGN="LEFT"/>transition_functions(chart1: LocalChart[Tensor], chart2: LocalChart[Tensor]): Tensor<br ALIGN="LEFT"/>validate_connection_properties(connection: MotivicChristoffelSymbols): bool<br ALIGN="LEFT"/>validate_metric_properties(metric: MotivicMetricTensor): bool<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.core.patterns.operadic_handler.OperadicStructureHandler" [color="black", fontcolor="black", label=<{src.core.patterns.operadic_handler.OperadicStructureHandler|base_dim : int<br ALIGN="LEFT"/>device<br ALIGN="LEFT"/>dtype : Ellipsis<br ALIGN="LEFT"/>hidden_dim : int<br ALIGN="LEFT"/>motive_rank : int<br ALIGN="LEFT"/>motivic<br ALIGN="LEFT"/>operad<br ALIGN="LEFT"/>operation_cache : Dict[Tuple[int, int], OperadicOperation]<br ALIGN="LEFT"/>preserve_metric : bool<br ALIGN="LEFT"/>preserve_symplectic : bool<br ALIGN="LEFT"/>|compose_operations(operations: List[OperadicOperation], with_motivic: bool): Tuple[OperadicOperation, Dict[str, Any]]<br ALIGN="LEFT"/>create_natural_transformation(source_op: OperadicOperation, target_op: OperadicOperation, with_cohomology: bool): Tuple[Tensor, Dict[str, Any]]<br ALIGN="LEFT"/>create_operation(source_dim: int, target_dim: int, preserve_structure: Optional[str], use_cache: bool): OperadicOperation<br ALIGN="LEFT"/>forward(): Any<br ALIGN="LEFT"/>handle_dimension_transition(tensor: Tensor, source_dim: int, target_dim: int, preserve_structure: Optional[str]): Tuple[Tensor, Dict[str, Any]]<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.core.patterns.operadic_structure.AttentionOperad" [color="black", fontcolor="black", label=<{src.core.patterns.operadic_structure.AttentionOperad|base_dim : int<br ALIGN="LEFT"/>preserve_metric : bool<br ALIGN="LEFT"/>preserve_symplectic : bool<br ALIGN="LEFT"/>|compose(operations: List[OperadicOperation]): OperadicOperation<br ALIGN="LEFT"/>create_operation(source_dim: int, target_dim: int, preserve_structure: Optional[str]): OperadicOperation<br ALIGN="LEFT"/>natural_transformation(source_op: OperadicOperation, target_op: OperadicOperation): Tensor<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.core.patterns.operadic_structure.EnrichedAttention" [color="black", fontcolor="black", label=<{src.core.patterns.operadic_structure.EnrichedAttention|base_category : str<br ALIGN="LEFT"/>wave_enabled : bool<br ALIGN="LEFT"/>|create_morphism(pattern: Tensor, operation: OperadicOperation, include_wave: bool): Tensor<br ALIGN="LEFT"/>create_wave_packet(position: Tensor, momentum: Tensor): Tensor<br ALIGN="LEFT"/>get_momentum(wave: Tensor): Tensor<br ALIGN="LEFT"/>get_position(wave: Tensor): Tensor<br ALIGN="LEFT"/>wave_operator(tensor: Tensor): Tensor<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.core.patterns.operadic_structure.OperadicComposition" [color="black", fontcolor="black", label=<{src.core.patterns.operadic_structure.OperadicComposition|<br ALIGN="LEFT"/>|<I>compose</I>(operations: List[OperadicOperation]): OperadicOperation<br ALIGN="LEFT"/><I>create_operation</I>(source_dim: int, target_dim: int, preserve_structure: Optional[str]): OperadicOperation<br ALIGN="LEFT"/><I>natural_transformation</I>(source_op: OperadicOperation, target_op: OperadicOperation): Tensor<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.core.patterns.operadic_structure.OperadicOperation" [color="black", fontcolor="black", label=<{src.core.patterns.operadic_structure.OperadicOperation|composition_law<br ALIGN="LEFT"/>enrichment : Optional[Dict[str, Any]]<br ALIGN="LEFT"/>natural_transformation : Optional[Dict[str, Any]]<br ALIGN="LEFT"/>source_dim : int<br ALIGN="LEFT"/>target_dim : int<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"src.core.patterns.pattern_processor.PatternProcessor" [color="black", fontcolor="black", label=<{src.core.patterns.pattern_processor.PatternProcessor|arithmetic<br ALIGN="LEFT"/>device : NoneType<br ALIGN="LEFT"/>dtype : Ellipsis, NoneType<br ALIGN="LEFT"/>flow<br ALIGN="LEFT"/>flow_net<br ALIGN="LEFT"/>hidden_dim : int<br ALIGN="LEFT"/>manifold_dim : int<br ALIGN="LEFT"/>motive_rank : int<br ALIGN="LEFT"/>num_primes : int<br ALIGN="LEFT"/>operadic<br ALIGN="LEFT"/>pattern_bundle<br ALIGN="LEFT"/>pattern_dynamics<br ALIGN="LEFT"/>pattern_evolution<br ALIGN="LEFT"/>pattern_formation<br ALIGN="LEFT"/>pattern_net<br ALIGN="LEFT"/>quantum_bridge<br ALIGN="LEFT"/>quantum_net<br ALIGN="LEFT"/>riemannian<br ALIGN="LEFT"/>symplectic<br ALIGN="LEFT"/>transition<br ALIGN="LEFT"/>wave<br ALIGN="LEFT"/>|forward(x: Tensor, return_intermediates: bool): Union[Tensor, Tuple[Tensor, Dict[str, Any]]]<br ALIGN="LEFT"/>process_pattern(pattern: Tensor, with_quantum: bool, return_intermediates: bool): Union[Tensor, Tuple[Tensor, Dict[str, Any]]]<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.core.patterns.riemannian.BaseRiemannianStructure" [color="black", fontcolor="black", label=<{src.core.patterns.riemannian.BaseRiemannianStructure|cache : Dict[str, Any]<br ALIGN="LEFT"/>connection_coeffs<br ALIGN="LEFT"/>device<br ALIGN="LEFT"/>dtype : Ellipsis<br ALIGN="LEFT"/>manifold_dim : int<br ALIGN="LEFT"/>metric_factors<br ALIGN="LEFT"/>|compute_christoffel(points: Tensor): ChristoffelSymbols[Tensor]<br ALIGN="LEFT"/>compute_curvature(points: Tensor, christoffel: Optional[ChristoffelSymbols[Tensor]]): CurvatureTensor[Tensor]<br ALIGN="LEFT"/>compute_metric(points: Tensor): MetricTensor[Tensor]<br ALIGN="LEFT"/>exp_map(point: Tensor, vector: Tensor): Tensor<br ALIGN="LEFT"/>geodesic_flow(initial_point: Tensor, initial_velocity: Tensor, steps: int, step_size: float): Tuple[Tensor, Tensor]<br ALIGN="LEFT"/>lie_derivative_metric(point: Tensor, vector_field: Callable[[Tensor], Tensor]): MetricTensor[Tensor]<br ALIGN="LEFT"/>parallel_transport(vector: Tensor, path: Tensor, connection: Optional[ChristoffelSymbols[Tensor]]): Tensor<br ALIGN="LEFT"/>sectional_curvature(point: Tensor, v1: Tensor, v2: Tensor): Tensor<br ALIGN="LEFT"/>validate_connection_properties(connection: ChristoffelSymbols[Tensor]): bool<br ALIGN="LEFT"/>validate_metric_properties(metric: MetricTensor[Tensor]): bool<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.core.patterns.riemannian.PatternRiemannianStructure" [color="black", fontcolor="black", label=<{src.core.patterns.riemannian.PatternRiemannianStructure|connection_coeffs<br ALIGN="LEFT"/>metric_factors<br ALIGN="LEFT"/>pattern_dim : int<br ALIGN="LEFT"/>structure<br ALIGN="LEFT"/>|compute_riemann(points: Tensor): CurvatureTensor[Tensor]<br ALIGN="LEFT"/>forward(): Any<br ALIGN="LEFT"/>get_christoffel_values(points: Tensor): Tensor<br ALIGN="LEFT"/>get_metric_tensor(points: Tensor): Tensor<br ALIGN="LEFT"/>get_riemann_tensor(points: Tensor): Tensor<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.core.patterns.riemannian.RiemannianFramework" [color="black", fontcolor="black", label=<{src.core.patterns.riemannian.RiemannianFramework|structure<br ALIGN="LEFT"/>|compute_christoffel(points: Tensor): ChristoffelSymbols[Tensor]<br ALIGN="LEFT"/>compute_metric(points: Tensor): MetricTensor[Tensor]<br ALIGN="LEFT"/>compute_riemann(points: Tensor): CurvatureTensor[Tensor]<br ALIGN="LEFT"/>exp_map(point: Tensor, vector: Tensor): Tensor<br ALIGN="LEFT"/>forward(): Any<br ALIGN="LEFT"/>get_christoffel_values(points: Tensor): Tensor<br ALIGN="LEFT"/>get_metric_tensor(points: Tensor): Tensor<br ALIGN="LEFT"/>get_riemann_tensor(points: Tensor): Tensor<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.core.patterns.riemannian_base.ChristoffelSymbols" [color="black", fontcolor="black", label=<{src.core.patterns.riemannian_base.ChristoffelSymbols|is_symmetric : bool<br ALIGN="LEFT"/>metric : MetricTensor[T]<br ALIGN="LEFT"/>values<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"src.core.patterns.riemannian_base.CurvatureTensor" [color="black", fontcolor="black", label=<{src.core.patterns.riemannian_base.CurvatureTensor|ricci<br ALIGN="LEFT"/>riemann<br ALIGN="LEFT"/>scalar_curvatures<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"src.core.patterns.riemannian_base.MetricTensor" [color="black", fontcolor="black", label=<{src.core.patterns.riemannian_base.MetricTensor|dimension : int<br ALIGN="LEFT"/>is_compatible : bool<br ALIGN="LEFT"/>values<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"src.core.patterns.riemannian_base.RiemannianStructure" [color="black", fontcolor="black", label=<{src.core.patterns.riemannian_base.RiemannianStructure|<br ALIGN="LEFT"/>|compute_christoffel(points: T): ChristoffelSymbols[T]<br ALIGN="LEFT"/>compute_curvature(points: T, christoffel: Optional[ChristoffelSymbols[T]]): CurvatureTensor[T]<br ALIGN="LEFT"/>compute_metric(points: T): MetricTensor[T]<br ALIGN="LEFT"/>geodesic_flow(initial_point: T, initial_velocity: T, steps: int, step_size: float): Tuple[T, T]<br ALIGN="LEFT"/>lie_derivative_metric(point: T, vector_field: VectorField): MetricTensor[T]<br ALIGN="LEFT"/>parallel_transport(vector: T, path: T, connection: Optional[ChristoffelSymbols[T]]): T<br ALIGN="LEFT"/>sectional_curvature(point: T, v1: T, v2: T): Scalar<br ALIGN="LEFT"/>validate_connection_properties(connection: ChristoffelSymbols[T]): bool<br ALIGN="LEFT"/>validate_metric_properties(metric: MetricTensor[T]): bool<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.core.patterns.riemannian_base.RiemannianValidator" [color="black", fontcolor="black", label=<{src.core.patterns.riemannian_base.RiemannianValidator|<br ALIGN="LEFT"/>|validate_connection_properties(connection: ChristoffelSymbols[T]): bool<br ALIGN="LEFT"/>validate_metric_properties(metric: MetricTensor[T]): bool<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.core.patterns.riemannian_base.ValidationMixin" [color="black", fontcolor="black", label=<{src.core.patterns.riemannian_base.ValidationMixin|<br ALIGN="LEFT"/>|validate_connection_properties(connection: ChristoffelSymbols[Tensor]): bool<br ALIGN="LEFT"/>validate_metric_properties(metric: MetricTensor[Tensor]): bool<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.core.patterns.riemannian_flow.RiemannianFlow" [color="black", fontcolor="black", label=<{src.core.patterns.riemannian_flow.RiemannianFlow|christoffel_net<br ALIGN="LEFT"/>use_parallel_transport : bool<br ALIGN="LEFT"/>|compute_christoffel(metric: torch.Tensor, points: Optional[torch.Tensor]): torch.Tensor<br ALIGN="LEFT"/>compute_ricci_tensor(metric: torch.Tensor, connection: Optional[torch.Tensor]): torch.Tensor<br ALIGN="LEFT"/>flow_step(metric: torch.Tensor, ricci: torch.Tensor, timestep: float): Tuple[torch.Tensor, Dict[str, Any]]<br ALIGN="LEFT"/>parallel_transport(vector: torch.Tensor, path: torch.Tensor, metric: Optional[torch.Tensor]): torch.Tensor<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.core.patterns.symplectic.EnrichedOperator" [color="black", fontcolor="black", label=<{src.core.patterns.symplectic.EnrichedOperator|base_category : str<br ALIGN="LEFT"/>wave_enabled : bool<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"src.core.patterns.symplectic.SymplecticForm" [color="black", fontcolor="black", label=<{src.core.patterns.symplectic.SymplecticForm|enrichment : Optional[Dict[str, Any]]<br ALIGN="LEFT"/>matrix<br ALIGN="LEFT"/>|evaluate(v1: Tensor, v2: Tensor): Tensor<br ALIGN="LEFT"/>transpose(): 'SymplecticForm'<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.core.patterns.symplectic.SymplecticStructure" [color="black", fontcolor="black", label=<{src.core.patterns.symplectic.SymplecticStructure|dim : int<br ALIGN="LEFT"/>enriched<br ALIGN="LEFT"/>operadic<br ALIGN="LEFT"/>preserve_structure : bool<br ALIGN="LEFT"/>target_dim<br ALIGN="LEFT"/>wave_enabled : bool<br ALIGN="LEFT"/>|compute_form(fiber_coords: Tensor): SymplecticForm<br ALIGN="LEFT"/>compute_metric(fiber_coords: Tensor): Tensor<br ALIGN="LEFT"/>compute_quantum_geometric_tensor(point: Tensor): Tensor<br ALIGN="LEFT"/>compute_ricci_tensor(point: Tensor): Tensor<br ALIGN="LEFT"/>compute_volume(point: Tensor): Tensor<br ALIGN="LEFT"/>hamiltonian_vector_field(hamiltonian: Tensor, point: Tensor): Tensor<br ALIGN="LEFT"/>poisson_bracket(f: Tensor, g: Tensor, point: Tensor): Tensor<br ALIGN="LEFT"/>quantum_ricci_flow(point: Tensor, time: float, dt: float, steps: int): Tensor<br ALIGN="LEFT"/>standard_form(device: Optional[torch.device]): SymplecticForm<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.core.patterns.symplectic.WaveOperator" [color="black", fontcolor="black", label=<{src.core.patterns.symplectic.WaveOperator|<br ALIGN="LEFT"/>|create_morphism(pattern: Tensor, operation: OperadicOperation, include_wave: bool): Tensor<br ALIGN="LEFT"/>create_wave_packet(position: Tensor, momentum: Tensor): Tensor<br ALIGN="LEFT"/>get_momentum(wave: Tensor): Tensor<br ALIGN="LEFT"/>get_position(wave: Tensor): Tensor<br ALIGN="LEFT"/>wave_operator(tensor: Tensor): Tensor<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.core.performance.cpu.algorithms.AlgorithmMetrics" [color="black", fontcolor="black", label=<{src.core.performance.cpu.algorithms.AlgorithmMetrics|branch_misses : int<br ALIGN="LEFT"/>execution_time : float<br ALIGN="LEFT"/>instruction_count : int<br ALIGN="LEFT"/>numerical_error : float<br ALIGN="LEFT"/>optimization_type : str<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"src.core.performance.cpu.algorithms.AlgorithmOptimizer" [color="black", fontcolor="black", label=<{src.core.performance.cpu.algorithms.AlgorithmOptimizer|branch_opt : NoneType<br ALIGN="LEFT"/>enable_profiling : bool<br ALIGN="LEFT"/>fast_path : NoneType<br ALIGN="LEFT"/>instruction_counter<br ALIGN="LEFT"/>loop_opt : NoneType<br ALIGN="LEFT"/>metrics : List[AlgorithmMetrics]<br ALIGN="LEFT"/>numerical_opt : NoneType<br ALIGN="LEFT"/>operations : Dict[str, Callable]<br ALIGN="LEFT"/>optimization_level : str<br ALIGN="LEFT"/>|clear_metrics(): None<br ALIGN="LEFT"/>get_metrics(): List[AlgorithmMetrics]<br ALIGN="LEFT"/>optimize_algorithm(func: Callable): Callable<br ALIGN="LEFT"/>optimize_operation(operation_name: str): Any<br ALIGN="LEFT"/>register_fast_path(name: str, implementation: Callable, condition: Callable[..., bool]): None<br ALIGN="LEFT"/>register_operation(name: str, operation: Callable): None<br ALIGN="LEFT"/>set_optimization_level(level: str): None<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.core.performance.cpu.algorithms.BranchOptimizer" [color="black", fontcolor="black", label=<{src.core.performance.cpu.algorithms.BranchOptimizer|branch_stats : Dict[str, Dict[bool, int]]<br ALIGN="LEFT"/>|likely(condition: bool, branch_id: str): bool<br ALIGN="LEFT"/>optimize_branches(func: Callable): Callable<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.core.performance.cpu.algorithms.FastPathDict" [color="black", fontcolor="black", label=<{src.core.performance.cpu.algorithms.FastPathDict|condition : Callable[..., bool]<br ALIGN="LEFT"/>implementation : Callable[..., Any]<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"src.core.performance.cpu.algorithms.FastPathOptimizer" [color="black", fontcolor="black", label=<{src.core.performance.cpu.algorithms.FastPathOptimizer|fast_paths : Dict[str, FastPathDict]<br ALIGN="LEFT"/>path_stats : Dict[str, int]<br ALIGN="LEFT"/>|optimize(func: Callable[..., T]): Callable[..., T]<br ALIGN="LEFT"/>register_fast_path(name: str, condition: Callable[..., bool], implementation: Callable[..., Any]): None<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.core.performance.cpu.algorithms.InstructionCounter" [color="black", fontcolor="black", label=<{src.core.performance.cpu.algorithms.InstructionCounter|instruction_counts : Dict[str, int]<br ALIGN="LEFT"/>|get_instruction_count(func: Callable): int<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.core.performance.cpu.algorithms.LoopOptimizer" [color="black", fontcolor="black", label=<{src.core.performance.cpu.algorithms.LoopOptimizer|loop_stats : Dict[str, Dict[str, int]]<br ALIGN="LEFT"/>unroll_threshold : int<br ALIGN="LEFT"/>|fuse_loops(operations: List[Callable[[T], T]], data: T): T<br ALIGN="LEFT"/>unroll(loop_id: str, iterations: int, operation: Callable[[int], T]): List[T]<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.core.performance.cpu.algorithms.NumericalOptimizer" [color="black", fontcolor="black", label=<{src.core.performance.cpu.algorithms.NumericalOptimizer|enable_mixed_precision : bool<br ALIGN="LEFT"/>numerical_stats : Dict[str, float]<br ALIGN="LEFT"/>stability_threshold : float<br ALIGN="LEFT"/>|optimize_precision(tensor: torch.Tensor, operation_id: str): torch.Tensor<br ALIGN="LEFT"/>stable_softmax(x: torch.Tensor, dim: int): torch.Tensor<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.core.performance.cpu.memory.CacheOptimizer" [color="black", fontcolor="black", label=<{src.core.performance.cpu.memory.CacheOptimizer|cache_line_size : int<br ALIGN="LEFT"/>stats : dict<br ALIGN="LEFT"/>|optimize_layout(tensor: torch.Tensor): torch.Tensor<br ALIGN="LEFT"/>prefetch(tensor: torch.Tensor, indices: torch.Tensor): None<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.core.performance.cpu.memory.MemoryManager" [color="black", fontcolor="black", label=<{src.core.performance.cpu.memory.MemoryManager|cache_optimizer<br ALIGN="LEFT"/>enable_monitoring : bool<br ALIGN="LEFT"/>pool<br ALIGN="LEFT"/>stats : List[MemoryStats]<br ALIGN="LEFT"/>|allocate(shape: Tuple[int, ...], dtype: torch.dtype): torch.Tensor<br ALIGN="LEFT"/>clear_metrics(): None<br ALIGN="LEFT"/>clear_stats(): None<br ALIGN="LEFT"/>create_pool(size: int): MemoryPool<br ALIGN="LEFT"/>get_memory_stats(): List[MemoryStats]<br ALIGN="LEFT"/>optimize_tensor(tensor: torch.Tensor, access_pattern: str): torch.Tensor<br ALIGN="LEFT"/>release_tensor(tensor: torch.Tensor): None<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.core.performance.cpu.memory.MemoryPool" [color="black", fontcolor="black", label=<{src.core.performance.cpu.memory.MemoryPool|current_size : int<br ALIGN="LEFT"/>max_size : int<br ALIGN="LEFT"/>pools : Dict[Tuple[int, ...], List[torch.Tensor]]<br ALIGN="LEFT"/>stats : defaultdict<br ALIGN="LEFT"/>|acquire(shape: Tuple[int, ...], dtype: torch.dtype): torch.Tensor<br ALIGN="LEFT"/>release(tensor: torch.Tensor): None<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.core.performance.cpu.memory.MemoryStats" [color="black", fontcolor="black", label=<{src.core.performance.cpu.memory.MemoryStats|access_pattern : str<br ALIGN="LEFT"/>allocation_size : int<br ALIGN="LEFT"/>cache_hits : int<br ALIGN="LEFT"/>fragmentation : float<br ALIGN="LEFT"/>pool_hits : int<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"src.core.performance.cpu.memory_management.MemoryManager" [color="black", fontcolor="black", label=<{src.core.performance.cpu.memory_management.MemoryManager|<br ALIGN="LEFT"/>|allocate_tensor(size: Tuple[int, ...]): torch.Tensor<br ALIGN="LEFT"/>get_allocated_memory(): int<br ALIGN="LEFT"/>get_fragmentation_ratio(): float<br ALIGN="LEFT"/>get_peak_memory(): int<br ALIGN="LEFT"/>inplace_operation(tensor: torch.Tensor, operation: Callable[[torch.Tensor], None]): None<br ALIGN="LEFT"/>optimized_matmul(x: torch.Tensor, y: torch.Tensor): torch.Tensor<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.core.performance.cpu.memory_management.MemoryMetrics" [color="black", fontcolor="black", label=<{src.core.performance.cpu.memory_management.MemoryMetrics|allocated_memory : int<br ALIGN="LEFT"/>fragmentation_ratio : float<br ALIGN="LEFT"/>operation_type : str<br ALIGN="LEFT"/>peak_memory : int<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"src.core.performance.cpu.vectorization.VectorizationMetrics" [color="black", fontcolor="black", label=<{src.core.performance.cpu.vectorization.VectorizationMetrics|execution_time : float<br ALIGN="LEFT"/>memory_usage : float<br ALIGN="LEFT"/>operation_type : str<br ALIGN="LEFT"/>vectorization_efficiency : float<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"src.core.performance.cpu.vectorization.VectorizationOptimizer" [color="black", fontcolor="black", label=<{src.core.performance.cpu.vectorization.VectorizationOptimizer|chunk_size : int<br ALIGN="LEFT"/>enable_profiling : bool<br ALIGN="LEFT"/>metrics : List[VectorizationMetrics]<br ALIGN="LEFT"/>use_mixed_precision : bool<br ALIGN="LEFT"/>|clear_metrics(): None<br ALIGN="LEFT"/>get_metrics(): List[VectorizationMetrics]<br ALIGN="LEFT"/>profile_vectorization(func: Callable): Callable<br ALIGN="LEFT"/>vectorize_attention(query: torch.Tensor, key: torch.Tensor, value: torch.Tensor): torch.Tensor<br ALIGN="LEFT"/>vectorize_geometric_flow(metric: torch.Tensor, connection: torch.Tensor): torch.Tensor<br ALIGN="LEFT"/>vectorize_pattern_dynamics(pattern: torch.Tensor, flow: torch.Tensor): torch.Tensor<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.core.performance.cpu_memory.CPUMemoryManager" [color="black", fontcolor="black", label=<{src.core.performance.cpu_memory.CPUMemoryManager|<br ALIGN="LEFT"/>|allocate_tensor(size: Union[Tuple[int, ...], torch.Size], dtype: Any): torch.Tensor<br ALIGN="LEFT"/>cleanup(): None<br ALIGN="LEFT"/>copy_from_device(src: torch.Tensor, dst: Union[torch.Tensor, np.ndarray]): None<br ALIGN="LEFT"/>copy_to_device(src: Union[torch.Tensor, np.ndarray], dst: torch.Tensor): None<br ALIGN="LEFT"/>free_tensor(tensor: torch.Tensor): None<br ALIGN="LEFT"/>get_fragmentation_ratio(): float<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.core.performance.cpu_optimizer.CPUOptimizer" [color="black", fontcolor="black", label=<{src.core.performance.cpu_optimizer.CPUOptimizer|cpu_profiler : Profile<br ALIGN="LEFT"/>enable_memory_tracking : bool<br ALIGN="LEFT"/>enable_profiling : bool<br ALIGN="LEFT"/>line_profiler<br ALIGN="LEFT"/>memory_profiler<br ALIGN="LEFT"/>|get_performance_metrics(): PerformanceMetrics<br ALIGN="LEFT"/>optimize_computation(computation_graph: torch.nn.Module, sample_input: torch.Tensor): torch.nn.Module<br ALIGN="LEFT"/>optimize_memory_access(tensor: torch.Tensor): torch.Tensor<br ALIGN="LEFT"/>profile_execution(func: Callable): Callable<br ALIGN="LEFT"/>vectorize_operation(func: Callable[..., torch.Tensor], inputs: List[torch.Tensor], chunk_size: Optional[int]): torch.Tensor<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.core.performance.cpu_optimizer.PerformanceMetrics" [color="black", fontcolor="black", label=<{src.core.performance.cpu_optimizer.PerformanceMetrics|cache_hits : float<br ALIGN="LEFT"/>cpu_utilization : float<br ALIGN="LEFT"/>execution_time : float<br ALIGN="LEFT"/>memory_usage : float<br ALIGN="LEFT"/>vectorization_efficiency : float<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"src.core.performance.gpu.memory_management.GPUMemoryManager" [color="black", fontcolor="black", label=<{src.core.performance.gpu.memory_management.GPUMemoryManager|device<br ALIGN="LEFT"/>|allocate(size: tuple, dtype: torch.dtype): torch.Tensor<br ALIGN="LEFT"/>clear_cache()<br ALIGN="LEFT"/>free(tensor: torch.Tensor)<br ALIGN="LEFT"/>get_memory_stats(): Dict[str, float]<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.core.performance.memory_base.MemoryError" [color="black", fontcolor="red", label=<{src.core.performance.memory_base.MemoryError|<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"src.core.performance.memory_base.MemoryManagerBase" [color="black", fontcolor="black", label=<{src.core.performance.memory_base.MemoryManagerBase|<br ALIGN="LEFT"/>|<I>allocate_tensor</I>(size: Union[Tuple[int, ...], torch.Size], dtype: Any): Any<br ALIGN="LEFT"/><I>cleanup</I>(): None<br ALIGN="LEFT"/><I>copy_from_device</I>(src: Any, dst: Any): None<br ALIGN="LEFT"/><I>copy_to_device</I>(src: Any, dst: Any): None<br ALIGN="LEFT"/><I>free_tensor</I>(tensor: Any): None<br ALIGN="LEFT"/>get_allocated_memory(): int<br ALIGN="LEFT"/>get_fragmentation_ratio(): float<br ALIGN="LEFT"/>get_metrics(): List[MemoryMetrics]<br ALIGN="LEFT"/>get_peak_memory(): int<br ALIGN="LEFT"/>record_metric(operation_type: str): None<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.core.performance.memory_base.MemoryMetrics" [color="black", fontcolor="black", label=<{src.core.performance.memory_base.MemoryMetrics|allocated_memory : int<br ALIGN="LEFT"/>fragmentation_ratio : float<br ALIGN="LEFT"/>operation_type : str<br ALIGN="LEFT"/>peak_memory : int<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"src.core.performance.vulkan.shaders.ComputeShaderDispatcher" [color="black", fontcolor="black", label=<{src.core.performance.vulkan.shaders.ComputeShaderDispatcher|command_pool : c_void_p<br ALIGN="LEFT"/>device : c_void_p<br ALIGN="LEFT"/>queue : c_void_p<br ALIGN="LEFT"/>|dispatch(pipeline: VkPipeline, pipeline_layout: VkPipelineLayout, descriptor_set: VkDescriptorSet, push_constants: Optional[bytes], group_count: Tuple[int, int, int]): None<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.core.performance.vulkan.shaders.ShaderCompiler" [color="black", fontcolor="black", label=<{src.core.performance.vulkan.shaders.ShaderCompiler|shader_dir : Path<br ALIGN="LEFT"/>|compile_all_shaders(): None<br ALIGN="LEFT"/>compile_shader(shader_name: str): None<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.core.performance.vulkan.shaders.ShaderManager" [color="black", fontcolor="black", label=<{src.core.performance.vulkan.shaders.ShaderManager|device : c_void_p<br ALIGN="LEFT"/>pipeline_layouts : Dict[str, VkPipelineLayout]<br ALIGN="LEFT"/>pipelines : Dict[str, VkPipeline]<br ALIGN="LEFT"/>shader_dir : Path<br ALIGN="LEFT"/>shader_modules : Dict[str, VkShaderModule]<br ALIGN="LEFT"/>|cleanup(): None<br ALIGN="LEFT"/>create_compute_pipeline(shader_name: str, push_constant_size: int): Tuple[VkPipeline, VkPipelineLayout]<br ALIGN="LEFT"/>create_shader_module(shader_name: str): VkShaderModule<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.core.performance.vulkan.shaders.VkCommandBufferAllocateInfo" [color="black", fontcolor="black", label=<{src.core.performance.vulkan.shaders.VkCommandBufferAllocateInfo|<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"src.core.performance.vulkan.shaders.VkCommandBufferBeginInfo" [color="black", fontcolor="black", label=<{src.core.performance.vulkan.shaders.VkCommandBufferBeginInfo|<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"src.core.performance.vulkan.shaders.VkComputePipelineCreateInfo" [color="black", fontcolor="black", label=<{src.core.performance.vulkan.shaders.VkComputePipelineCreateInfo|<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"src.core.performance.vulkan.shaders.VkDescriptorSetLayoutBinding" [color="black", fontcolor="black", label=<{src.core.performance.vulkan.shaders.VkDescriptorSetLayoutBinding|<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"src.core.performance.vulkan.shaders.VkDescriptorSetLayoutCreateInfo" [color="black", fontcolor="black", label=<{src.core.performance.vulkan.shaders.VkDescriptorSetLayoutCreateInfo|<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"src.core.performance.vulkan.shaders.VkPipelineLayoutCreateInfo" [color="black", fontcolor="black", label=<{src.core.performance.vulkan.shaders.VkPipelineLayoutCreateInfo|<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"src.core.performance.vulkan.shaders.VkPipelineShaderStageCreateInfo" [color="black", fontcolor="black", label=<{src.core.performance.vulkan.shaders.VkPipelineShaderStageCreateInfo|<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"src.core.performance.vulkan.shaders.VkPushConstantRange" [color="black", fontcolor="black", label=<{src.core.performance.vulkan.shaders.VkPushConstantRange|<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"src.core.performance.vulkan.shaders.VkShaderModuleCreateInfo" [color="black", fontcolor="black", label=<{src.core.performance.vulkan.shaders.VkShaderModuleCreateInfo|<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"src.core.performance.vulkan.shaders.VkSubmitInfo" [color="black", fontcolor="black", label=<{src.core.performance.vulkan.shaders.VkSubmitInfo|<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"src.core.performance.vulkan_memory.VulkanBuffer" [color="black", fontcolor="black", label=<{src.core.performance.vulkan_memory.VulkanBuffer|buffer : c_void_p<br ALIGN="LEFT"/>dtype : Optional[Any]<br ALIGN="LEFT"/>memory : c_void_p<br ALIGN="LEFT"/>offset : int<br ALIGN="LEFT"/>shape : Optional[Tuple[int, ...]]<br ALIGN="LEFT"/>size : int<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"src.core.performance.vulkan_memory.VulkanMemoryManager" [color="black", fontcolor="black", label=<{src.core.performance.vulkan_memory.VulkanMemoryManager|device : c_void_p<br ALIGN="LEFT"/>physical_device : c_void_p<br ALIGN="LEFT"/>|allocate_tensor(size: Union[Tuple[int, ...], torch.Size], dtype: Any): VulkanBuffer<br ALIGN="LEFT"/>cleanup(): None<br ALIGN="LEFT"/>copy_from_device(src: VulkanBuffer, dst: np.ndarray): None<br ALIGN="LEFT"/>copy_to_device(src: np.ndarray, dst: VulkanBuffer): None<br ALIGN="LEFT"/>free_tensor(buffer: VulkanBuffer): None<br ALIGN="LEFT"/>get_fragmentation_ratio(): float<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.core.quantum.neural_quantum_bridge.NeuralQuantumBridge" [color="black", fontcolor="black", label=<{src.core.quantum.neural_quantum_bridge.NeuralQuantumBridge|hidden_dim : int<br ALIGN="LEFT"/>hilbert_space<br ALIGN="LEFT"/>motivic_system<br ALIGN="LEFT"/>num_heads : int<br ALIGN="LEFT"/>pattern_bundle<br ALIGN="LEFT"/>quantum_attention<br ALIGN="LEFT"/>quantum_tile<br ALIGN="LEFT"/>riemannian_bundle<br ALIGN="LEFT"/>scale_system<br ALIGN="LEFT"/>state_manager<br ALIGN="LEFT"/>state_preparation<br ALIGN="LEFT"/>state_validator<br ALIGN="LEFT"/>|bridge_scales(state: torch.Tensor, source_scale: float, target_scale: float): torch.Tensor<br ALIGN="LEFT"/>compute_coherence(state1: torch.Tensor, state2: torch.Tensor): torch.Tensor<br ALIGN="LEFT"/>compute_motivic_structure(pattern: torch.Tensor, return_metrics: bool): Union[torch.Tensor, Tuple[torch.Tensor, Dict[str, torch.Tensor]]]<br ALIGN="LEFT"/>compute_scale_cohomology(pattern: torch.Tensor, return_metrics: bool): Dict[str, Any]<br ALIGN="LEFT"/>construct_pattern_bundle(pattern: torch.Tensor, return_metrics: bool): Union[PatternSection, Tuple[PatternSection, Dict[str, torch.Tensor]]]<br ALIGN="LEFT"/>evolve_motivic_structure(form: ArithmeticForm, time: float): torch.Tensor<br ALIGN="LEFT"/>evolve_pattern_bundle(section: PatternSection, time: float, scale_factor: Optional[float]): Tuple[PatternSection, Dict[str, Any]]<br ALIGN="LEFT"/>evolve_quantum_state(state: QuantumState, time: float): QuantumState<br ALIGN="LEFT"/>evolve_scale_cohomology(states: List[torch.Tensor], time: float): Dict[str, Any]<br ALIGN="LEFT"/>forward(x: torch.Tensor, return_intermediates: bool): Union[torch.Tensor, Tuple[torch.Tensor, Dict[str, Any]]]<br ALIGN="LEFT"/>neural_to_quantum(x: torch.Tensor, return_validation: bool): Union[QuantumState, Tuple[QuantumState, QuantumStateValidationResult]]<br ALIGN="LEFT"/>quantum_to_neural(state: QuantumState, original_shape: Optional[torch.Size]): torch.Tensor<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.core.quantum.state_space.HilbertSpace" [color="black", fontcolor="black", label=<{src.core.quantum.state_space.HilbertSpace|basis_states<br ALIGN="LEFT"/>dim : int<br ALIGN="LEFT"/>hamiltonian<br ALIGN="LEFT"/>observables : dict<br ALIGN="LEFT"/>|apply_quantum_channel(state: QuantumState, kraus_ops: List[torch.Tensor]): QuantumState<br ALIGN="LEFT"/>compute_berry_phase(initial_state: QuantumState, hamiltonian_fn: Callable[[float], torch.Tensor], times: torch.Tensor): torch.Tensor<br ALIGN="LEFT"/>compute_concurrence(density_matrix: torch.Tensor): torch.Tensor<br ALIGN="LEFT"/>compute_entanglement_entropy(state: QuantumState): torch.Tensor<br ALIGN="LEFT"/>compute_entropy(state: Union[QuantumState, torch.Tensor]): torch.Tensor<br ALIGN="LEFT"/>compute_negativity(state: Union[QuantumState, torch.Tensor]): torch.Tensor<br ALIGN="LEFT"/>entanglement_entropy(state: Union[QuantumState, torch.Tensor]): torch.Tensor<br ALIGN="LEFT"/>evaluate_entanglement_witness(state: Union[QuantumState, torch.Tensor]): torch.Tensor<br ALIGN="LEFT"/>evolve_state(initial_state: QuantumState, hamiltonian: torch.Tensor, t: Union[float, torch.Tensor]): Union[QuantumState, List[QuantumState]]<br ALIGN="LEFT"/>evolve_with_decoherence(state: QuantumState, T1: float, T2: float, times: torch.Tensor): List[QuantumState]<br ALIGN="LEFT"/>fubini_study_distance(state1: QuantumState, state2: QuantumState): torch.Tensor<br ALIGN="LEFT"/>measure_observable(state: QuantumState, observable: torch.Tensor): torch.Tensor<br ALIGN="LEFT"/>measure_variance(state: QuantumState, observable: torch.Tensor): torch.Tensor<br ALIGN="LEFT"/>parallel_transport(tangent: torch.Tensor, state1: QuantumState, state2: QuantumState): torch.Tensor<br ALIGN="LEFT"/>prepare_state(amplitudes: torch.Tensor): QuantumState<br ALIGN="LEFT"/>quantum_tangent_vector(state: QuantumState): torch.Tensor<br ALIGN="LEFT"/>reconstruct_state(measurements: Dict[str, torch.Tensor]): QuantumState<br ALIGN="LEFT"/>scale_state(state: QuantumState, scale_factor: float): QuantumState<br ALIGN="LEFT"/>state_fidelity(state1: QuantumState, state2: QuantumState): torch.Tensor<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.core.scale_transition.ScaleFlowIntegrator" [color="black", fontcolor="black", label=<{src.core.scale_transition.ScaleFlowIntegrator|config<br ALIGN="LEFT"/>entanglement_tracker<br ALIGN="LEFT"/>scale_classical_proj<br ALIGN="LEFT"/>scale_dependent_ops<br ALIGN="LEFT"/>scale_quantum_proj<br ALIGN="LEFT"/>|compute_scale_quantum_state(state: torch.Tensor, scale_idx: int): torch.Tensor<br ALIGN="LEFT"/>get_entanglement_metrics(): Dict[str, torch.Tensor]<br ALIGN="LEFT"/>integrate_flow(state: torch.Tensor, source_scale: float, target_scale: float, quantum_bridge: Optional[NeuralQuantumBridge]): torch.Tensor<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.core.scale_transition.ScaleTransitionConfig" [color="black", fontcolor="black", label=<{src.core.scale_transition.ScaleTransitionConfig|dim : int<br ALIGN="LEFT"/>hidden_dim : int<br ALIGN="LEFT"/>max_scale : float<br ALIGN="LEFT"/>min_scale : float<br ALIGN="LEFT"/>num_scales : int<br ALIGN="LEFT"/>use_quantum_bridge : bool<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"src.core.scale_transition.ScaleTransitionLayer" [color="black", fontcolor="black", label=<{src.core.scale_transition.ScaleTransitionLayer|config<br ALIGN="LEFT"/>quantum_bridge : NoneType<br ALIGN="LEFT"/>scale_down<br ALIGN="LEFT"/>scale_norm<br ALIGN="LEFT"/>scale_system<br ALIGN="LEFT"/>scale_up<br ALIGN="LEFT"/>|forward(state: torch.Tensor, source_scale: float, target_scale: float): torch.Tensor<br ALIGN="LEFT"/>transition_down(state: torch.Tensor, source_scale: float, target_scale: float): torch.Tensor<br ALIGN="LEFT"/>transition_up(state: torch.Tensor, source_scale: float, target_scale: float): torch.Tensor<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.core.scale_transition.ScaleTransitionSystem" [color="black", fontcolor="black", label=<{src.core.scale_transition.ScaleTransitionSystem|config<br ALIGN="LEFT"/>transition_layer<br ALIGN="LEFT"/>|connect_pattern_scales(patterns: List[torch.Tensor], scales: List[float], preserve_symmetry: bool): List[torch.Tensor]<br ALIGN="LEFT"/>connect_scales(states: List[torch.Tensor], scales: List[float]): List[torch.Tensor]<br ALIGN="LEFT"/>validate_pattern_transitions(patterns: List[torch.Tensor], scales: List[float]): Mapping[str, torch.Tensor]<br ALIGN="LEFT"/>validate_transitions(states: List[torch.Tensor], scales: List[float]): Mapping[str, torch.Tensor]<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.core.tiling.arithmetic_dynamics.ArithmeticDynamics" [color="black", fontcolor="black", label=<{src.core.tiling.arithmetic_dynamics.ArithmeticDynamics|adelic_proj<br ALIGN="LEFT"/>coupling<br ALIGN="LEFT"/>flow<br ALIGN="LEFT"/>height_dim : int<br ALIGN="LEFT"/>height_map<br ALIGN="LEFT"/>hidden_dim : int<br ALIGN="LEFT"/>l_function<br ALIGN="LEFT"/>motive_rank : int<br ALIGN="LEFT"/>num_primes : int<br ALIGN="LEFT"/>output_proj<br ALIGN="LEFT"/>quantum_height<br ALIGN="LEFT"/>quantum_l_function<br ALIGN="LEFT"/>quantum_weight : float<br ALIGN="LEFT"/>|compute_dynamics(x: torch.Tensor): torch.Tensor<br ALIGN="LEFT"/>compute_height(x: torch.Tensor): torch.Tensor<br ALIGN="LEFT"/>compute_l_function(x: torch.Tensor): torch.Tensor<br ALIGN="LEFT"/>compute_modular_form(x: torch.Tensor): torch.Tensor<br ALIGN="LEFT"/>compute_motivic_integral(x: torch.Tensor, num_samples: int): torch.Tensor<br ALIGN="LEFT"/>compute_quantum_correction(metric: torch.Tensor): torch.Tensor<br ALIGN="LEFT"/>compute_quantum_metric(x: torch.Tensor): torch.Tensor<br ALIGN="LEFT"/>forward(x: torch.Tensor, steps: int, return_trajectory: bool): Tuple[torch.Tensor, Dict]<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.core.tiling.arithmetic_dynamics.ArithmeticPattern" [color="black", fontcolor="black", label=<{src.core.tiling.arithmetic_dynamics.ArithmeticPattern|hidden_dim : int<br ALIGN="LEFT"/>input_dim : int<br ALIGN="LEFT"/>layers<br ALIGN="LEFT"/>motive_rank : int<br ALIGN="LEFT"/>num_layers : int<br ALIGN="LEFT"/>pattern_proj<br ALIGN="LEFT"/>|forward(x: torch.Tensor): Tuple[torch.Tensor, List[Dict]]<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.core.tiling.arithmetic_dynamics.ModularFormComputer" [color="black", fontcolor="black", label=<{src.core.tiling.arithmetic_dynamics.ModularFormComputer|coeff_net<br ALIGN="LEFT"/>hidden_dim : int<br ALIGN="LEFT"/>level : int<br ALIGN="LEFT"/>num_coeffs : int<br ALIGN="LEFT"/>symmetry_net<br ALIGN="LEFT"/>weight : int<br ALIGN="LEFT"/>|compute_q_expansion(x: torch.Tensor): torch.Tensor<br ALIGN="LEFT"/>compute_symmetries(x: torch.Tensor): Dict[str, torch.Tensor]<br ALIGN="LEFT"/>forward(x: torch.Tensor): Tuple[torch.Tensor, Dict[str, Any]]<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.core.tiling.arithmetic_dynamics.MotivicIntegrator" [color="black", fontcolor="black", label=<{src.core.tiling.arithmetic_dynamics.MotivicIntegrator|domain_net<br ALIGN="LEFT"/>hidden_dim : int<br ALIGN="LEFT"/>measure_net<br ALIGN="LEFT"/>monte_carlo_steps : int<br ALIGN="LEFT"/>motive_rank : int<br ALIGN="LEFT"/>num_samples : int<br ALIGN="LEFT"/>|compute_domain(x: torch.Tensor): Tuple[torch.Tensor, torch.Tensor]<br ALIGN="LEFT"/>compute_measure(x: torch.Tensor): torch.Tensor<br ALIGN="LEFT"/>forward(x: torch.Tensor): Tuple[torch.Tensor, Dict[str, Any]]<br ALIGN="LEFT"/>monte_carlo_integrate(measure: torch.Tensor, lower: torch.Tensor, upper: torch.Tensor): torch.Tensor<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.core.tiling.components.config.TilingConfig" [color="black", fontcolor="black", label=<{src.core.tiling.components.config.TilingConfig|dilation : int<br ALIGN="LEFT"/>groups : int<br ALIGN="LEFT"/>max_memory_gb : float<br ALIGN="LEFT"/>num_stages : int<br ALIGN="LEFT"/>num_warps : int<br ALIGN="LEFT"/>optimize_layout : bool<br ALIGN="LEFT"/>overlap : int<br ALIGN="LEFT"/>padding : str<br ALIGN="LEFT"/>stride : Optional[Tuple[int, ...]]<br ALIGN="LEFT"/>tile_size : Tuple[int, ...]<br ALIGN="LEFT"/>vectorize : bool<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"src.core.tiling.config.GeometricFlowConfig" [color="black", fontcolor="black", label=<{src.core.tiling.config.GeometricFlowConfig|MAX_DENSITY : float<br ALIGN="LEFT"/>MIN_DENSITY : float<br ALIGN="LEFT"/>MIN_RESOLUTION : float<br ALIGN="LEFT"/>adam_epsilon : float<br ALIGN="LEFT"/>attention_probs_dropout_prob : float<br ALIGN="LEFT"/>curvature_threshold : float<br ALIGN="LEFT"/>dim : int<br ALIGN="LEFT"/>dropout : float<br ALIGN="LEFT"/>entanglement_threshold : float<br ALIGN="LEFT"/>flow_epsilon : float<br ALIGN="LEFT"/>flow_lr : float<br ALIGN="LEFT"/>flow_steps : int<br ALIGN="LEFT"/>hidden_act : str<br ALIGN="LEFT"/>hidden_dropout_prob : float<br ALIGN="LEFT"/>hidden_size : int<br ALIGN="LEFT"/>initializer_range : float<br ALIGN="LEFT"/>intermediate_size : int<br ALIGN="LEFT"/>layer_norm_eps : float<br ALIGN="LEFT"/>layer_norm_eps_geometric : float<br ALIGN="LEFT"/>learning_rate : float<br ALIGN="LEFT"/>max_delta : float<br ALIGN="LEFT"/>max_grad_norm : float<br ALIGN="LEFT"/>max_position_embeddings : int<br ALIGN="LEFT"/>max_position_embeddings_geometric : int<br ALIGN="LEFT"/>measurement_samples : int<br ALIGN="LEFT"/>min_delta : float<br ALIGN="LEFT"/>num_attention_heads : int<br ALIGN="LEFT"/>num_heads : int<br ALIGN="LEFT"/>num_hidden_layers : int<br ALIGN="LEFT"/>quantum_dim : int<br ALIGN="LEFT"/>stability_threshold : float<br ALIGN="LEFT"/>warmup_steps : int<br ALIGN="LEFT"/>weight_decay : float<br ALIGN="LEFT"/>|from_dict(config_dict: Dict[str, Any]): 'GeometricFlowConfig'<br ALIGN="LEFT"/>to_dict(): Dict[str, Any]<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.core.tiling.geometric_flow.GeometricFlow" [color="black", fontcolor="black", label=<{src.core.tiling.geometric_flow.GeometricFlow|arithmetic<br ALIGN="LEFT"/>chart_embedding<br ALIGN="LEFT"/>hamiltonian<br ALIGN="LEFT"/>integration_steps : int<br ALIGN="LEFT"/>motive_rank : int<br ALIGN="LEFT"/>num_charts : int<br ALIGN="LEFT"/>|compute_metric(x: Tensor): Tensor<br ALIGN="LEFT"/>compute_ricci_tensor(metric: Tensor, connection: Optional[Tensor]): Tensor<br ALIGN="LEFT"/>flow_step(metric: Tensor, ricci: Tensor, timestep: float): Tuple[Tensor, Dict[str, Any]]<br ALIGN="LEFT"/>forward(x: Tensor, return_path: bool): Tuple[Tensor, Dict[str, Any]]<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.core.tiling.optimization.parameter_manager.AdaptiveParameterManager" [color="black", fontcolor="black", label=<{src.core.tiling.optimization.parameter_manager.AdaptiveParameterManager|adapt_factor : float<br ALIGN="LEFT"/>base_lr : float<br ALIGN="LEFT"/>learning_rates : Dict[str, float]<br ALIGN="LEFT"/>max_lr : float<br ALIGN="LEFT"/>min_lr : float<br ALIGN="LEFT"/>momentum : float<br ALIGN="LEFT"/>monitor<br ALIGN="LEFT"/>velocities : Dict[str, torch.Tensor]<br ALIGN="LEFT"/>|get_lr(name: str): float<br ALIGN="LEFT"/>get_state_dict(): Dict<br ALIGN="LEFT"/>load_state_dict(state_dict: Dict)<br ALIGN="LEFT"/>step(name: str, param: nn.Parameter, grad: Optional[torch.Tensor])<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.core.tiling.optimization.parameter_manager.ParameterMonitor" [color="black", fontcolor="black", label=<{src.core.tiling.optimization.parameter_manager.ParameterMonitor|gradient_history : Dict[str, List[torch.Tensor]]<br ALIGN="LEFT"/>parameter_history : Dict[str, List[torch.Tensor]]<br ALIGN="LEFT"/>window_size : int<br ALIGN="LEFT"/>|get_statistics(name: str): Dict[str, torch.Tensor]<br ALIGN="LEFT"/>update(name: str, param: nn.Parameter)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.core.tiling.patterns.cohomology.AdvancedMetricsAnalyzer" [color="black", fontcolor="black", label=<{src.core.tiling.patterns.cohomology.AdvancedMetricsAnalyzer|<br ALIGN="LEFT"/>|compute_ifq(pattern_stability: float, cross_tile_flow: float, edge_utilization: float, info_density: float): float<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.core.tiling.patterns.cohomology.ArithmeticDynamics" [color="black", fontcolor="black", label=<{src.core.tiling.patterns.cohomology.ArithmeticDynamics|flow<br ALIGN="LEFT"/>hidden_dim : int<br ALIGN="LEFT"/>hidden_proj<br ALIGN="LEFT"/>l_function<br ALIGN="LEFT"/>motive_rank : int<br ALIGN="LEFT"/>num_primes : int<br ALIGN="LEFT"/>|compute_dynamics(state: torch.Tensor): torch.Tensor<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.core.tiling.patterns.cohomology.ArithmeticForm" [color="black", fontcolor="black", label=<{src.core.tiling.patterns.cohomology.ArithmeticForm|coefficients<br ALIGN="LEFT"/>degree : int<br ALIGN="LEFT"/>dynamics_state : Optional[torch.Tensor]<br ALIGN="LEFT"/>height_data : Optional[torch.Tensor]<br ALIGN="LEFT"/>prime_bases : Optional[torch.Tensor]<br ALIGN="LEFT"/>|exterior_derivative(): 'ArithmeticForm'<br ALIGN="LEFT"/>wedge(other: 'ArithmeticForm'): 'ArithmeticForm'<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.core.tiling.patterns.cohomology.CohomologyGroup" [color="black", fontcolor="black", label=<{src.core.tiling.patterns.cohomology.CohomologyGroup|base_space<br ALIGN="LEFT"/>boundaries : List[ArithmeticForm]<br ALIGN="LEFT"/>degree : int<br ALIGN="LEFT"/>representatives : List[ArithmeticForm]<br ALIGN="LEFT"/>|add_cocycle(form: ArithmeticForm): None<br ALIGN="LEFT"/>cup_product(other: 'CohomologyGroup'): 'CohomologyGroup'<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.core.tiling.patterns.cohomology.DeRhamCohomology" [color="black", fontcolor="black", label=<{src.core.tiling.patterns.cohomology.DeRhamCohomology|cohomology_groups : List[CohomologyGroup]<br ALIGN="LEFT"/>manifold<br ALIGN="LEFT"/>|betti_numbers(): List[int]<br ALIGN="LEFT"/>compute_cohomology(max_degree: int): None<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.core.tiling.patterns.cohomology.FiberBundle" [color="black", fontcolor="black", label=<{src.core.tiling.patterns.cohomology.FiberBundle|<br ALIGN="LEFT"/>|get_connection(point: torch.Tensor): torch.Tensor<br ALIGN="LEFT"/>get_fiber(point: torch.Tensor): torch.Tensor<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.core.tiling.patterns.cohomology.HeightStructure" [color="black", fontcolor="black", label=<{src.core.tiling.patterns.cohomology.HeightStructure|num_primes : int<br ALIGN="LEFT"/>prime_bases<br ALIGN="LEFT"/>|compute_height(coefficients: torch.Tensor): torch.Tensor<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.core.tiling.patterns.cohomology.Integration" [color="black", fontcolor="black", label=<{src.core.tiling.patterns.cohomology.Integration|manifold<br ALIGN="LEFT"/>|apply_stokes(form: ArithmeticForm, domain: torch.Tensor): torch.Tensor<br ALIGN="LEFT"/>integrate_form(form: ArithmeticForm, domain: torch.Tensor): torch.Tensor<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.core.tiling.patterns.cohomology.MotivicCohomology" [color="black", fontcolor="black", label=<{src.core.tiling.patterns.cohomology.MotivicCohomology|base_space<br ALIGN="LEFT"/>dynamics<br ALIGN="LEFT"/>height_structure<br ALIGN="LEFT"/>hidden_dim : int<br ALIGN="LEFT"/>metrics<br ALIGN="LEFT"/>motive_rank : int<br ALIGN="LEFT"/>num_primes : int<br ALIGN="LEFT"/>|compute_motive(form: ArithmeticForm): torch.Tensor<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.core.tiling.patterns.cohomology.QuantumMotivicCohomology" [color="black", fontcolor="black", label=<{src.core.tiling.patterns.cohomology.QuantumMotivicCohomology|metric<br ALIGN="LEFT"/>motivic<br ALIGN="LEFT"/>quantum_structure<br ALIGN="LEFT"/>|compute_quantum_motive(form: ArithmeticForm): torch.Tensor<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.core.tiling.patterns.cohomology.RiemannianFiberBundle" [color="black", fontcolor="black", label=<{src.core.tiling.patterns.cohomology.RiemannianFiberBundle|connection_map<br ALIGN="LEFT"/>dimension : int<br ALIGN="LEFT"/>fiber_map<br ALIGN="LEFT"/>|get_connection(point: torch.Tensor): torch.Tensor<br ALIGN="LEFT"/>get_fiber(point: torch.Tensor): torch.Tensor<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.core.tiling.patterns.pattern_fiber_bundle.BundleConfig" [color="black", fontcolor="black", label=<{src.core.tiling.patterns.pattern_fiber_bundle.BundleConfig|base_dim : int<br ALIGN="LEFT"/>dt : float<br ALIGN="LEFT"/>fiber_dim : int<br ALIGN="LEFT"/>integration_steps : int<br ALIGN="LEFT"/>learning_rate : float<br ALIGN="LEFT"/>momentum : float<br ALIGN="LEFT"/>motive_rank : int<br ALIGN="LEFT"/>num_primes : int<br ALIGN="LEFT"/>stability_threshold : float<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"src.core.tiling.patterns.pattern_fiber_bundle.PatternFiberBundle" [color="black", fontcolor="black", label=<{src.core.tiling.patterns.pattern_fiber_bundle.PatternFiberBundle|basis_matrices<br ALIGN="LEFT"/>device<br ALIGN="LEFT"/>fiber_metric<br ALIGN="LEFT"/>fiber_transition<br ALIGN="LEFT"/>fiber_type_manager<br ALIGN="LEFT"/>geometric_flow<br ALIGN="LEFT"/>height_structure<br ALIGN="LEFT"/>operadic<br ALIGN="LEFT"/>pattern_dynamics<br ALIGN="LEFT"/>pattern_evolution<br ALIGN="LEFT"/>pattern_formation<br ALIGN="LEFT"/>riemannian_framework<br ALIGN="LEFT"/>symplectic<br ALIGN="LEFT"/>transition<br ALIGN="LEFT"/>wave<br ALIGN="LEFT"/>|compute_cohomology(point: Tensor): Tensor<br ALIGN="LEFT"/>compute_connection(tangent_vector: Tensor, connection_type: str): Tensor<br ALIGN="LEFT"/>compute_curvature(): CurvatureTensor<br ALIGN="LEFT"/>compute_holonomy_algebra(holonomies: List[Tensor]): Tensor<br ALIGN="LEFT"/>compute_holonomy_group(holonomies: List[Tensor]): Tensor<br ALIGN="LEFT"/>compute_metric(points: torch.Tensor): MotivicMetricTensor<br ALIGN="LEFT"/>compute_stability(point: Tensor): Dict[str, Any]<br ALIGN="LEFT"/>connection_form(tangent_vector: Tensor): Tensor<br ALIGN="LEFT"/>construct_bundle(structure_group: str, fiber_type: str, base_manifold: Optional[str]): None<br ALIGN="LEFT"/>convert_fiber_type(section: Tensor, target_type: str): Tensor<br ALIGN="LEFT"/>local_trivialization(point: Tensor): Tuple[LocalChart[Tensor], FiberChart[Tensor, str]]<br ALIGN="LEFT"/>parallel_transport(section: Tensor, path: Tensor): Tensor<br ALIGN="LEFT"/>set_fiber_type(fiber_type: str): None<br ALIGN="LEFT"/>structure_group_action(point: Tensor, group_element: Tensor): Tensor<br ALIGN="LEFT"/>to(device: torch.device): 'PatternFiberBundle'<br ALIGN="LEFT"/>validate_connection(connection: ChristoffelSymbols): bool<br ALIGN="LEFT"/>validate_fiber_type(section: Tensor): bool<br ALIGN="LEFT"/>validate_metric(metric: MetricTensor): bool<br ALIGN="LEFT"/>with_tensor_state(tensor: Tensor, target: Optional[Tensor]): TensorStateContext<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.core.tiling.patterns.pattern_fiber_bundle.TensorStateContext" [color="black", fontcolor="black", label=<{src.core.tiling.patterns.pattern_fiber_bundle.TensorStateContext|bundle : str<br ALIGN="LEFT"/>modified_tensor : NoneType, Optional[Tensor]<br ALIGN="LEFT"/>original_device<br ALIGN="LEFT"/>original_dtype<br ALIGN="LEFT"/>original_tensor<br ALIGN="LEFT"/>target : Optional[Tensor]<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"src.core.tiling.patterns.pattern_fiber_bundle.TensorStateManager" [color="black", fontcolor="black", label=<{src.core.tiling.patterns.pattern_fiber_bundle.TensorStateManager|<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"src.core.tiling.quantum_attention_tile.AttentionResult" [color="black", fontcolor="black", label=<{src.core.tiling.quantum_attention_tile.AttentionResult|<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"src.core.tiling.quantum_attention_tile.LoadBalancer" [color="black", fontcolor="black", label=<{src.core.tiling.quantum_attention_tile.LoadBalancer|loads<br ALIGN="LEFT"/>num_tiles : int<br ALIGN="LEFT"/>|balance(): List[int]<br ALIGN="LEFT"/>get_load(tile_idx: int): LoadProfile<br ALIGN="LEFT"/>update_load(tile_idx: int, load: LoadProfile)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.core.tiling.quantum_attention_tile.LoadProfile" [color="black", fontcolor="black", label=<{src.core.tiling.quantum_attention_tile.LoadProfile|compute : float<br ALIGN="LEFT"/>io : float<br ALIGN="LEFT"/>memory : float<br ALIGN="LEFT"/>|total(): float<br ALIGN="LEFT"/>weighted(compute_weight: float, memory_weight: float, io_weight: float): float<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.core.tiling.quantum_attention_tile.QuantumMotivicTile" [color="black", fontcolor="black", label=<{src.core.tiling.quantum_attention_tile.QuantumMotivicTile|cohomology_dim : int<br ALIGN="LEFT"/>cohomology_proj<br ALIGN="LEFT"/>dropout : float<br ALIGN="LEFT"/>dropout_layer<br ALIGN="LEFT"/>field_proj<br ALIGN="LEFT"/>height_proj<br ALIGN="LEFT"/>hidden_dim : int<br ALIGN="LEFT"/>key<br ALIGN="LEFT"/>motive_rank : int<br ALIGN="LEFT"/>neighbors<br ALIGN="LEFT"/>num_heads : int<br ALIGN="LEFT"/>output<br ALIGN="LEFT"/>query<br ALIGN="LEFT"/>resolution : float<br ALIGN="LEFT"/>size : int<br ALIGN="LEFT"/>value<br ALIGN="LEFT"/>|adapt_resolution(density_metric: float, strategy: str): None<br ALIGN="LEFT"/>add_neighbor(neighbor: 'QuantumMotivicTile'): None<br ALIGN="LEFT"/>balance_load(neighbors: List['QuantumMotivicTile']): None<br ALIGN="LEFT"/>compute_ae(resolution_history: List[float], load_variance_history: List[float], window_size: int): float<br ALIGN="LEFT"/>compute_cer(information_transferred: float, compute_cost: float, memory_usage: float, resolution: float, beta: float): float<br ALIGN="LEFT"/>compute_ifq(pattern_stability: float, cross_tile_flow: float, edge_utilization: float, info_density: float, alpha: float): float<br ALIGN="LEFT"/>forward(q: Tensor, k: Tensor, v: Tensor, return_metrics: bool): Union[Tensor, Tuple[Tensor, Dict[str, Any]]]<br ALIGN="LEFT"/>get_memory_stats(): Dict[str, float]<br ALIGN="LEFT"/>get_metrics(): Dict[str, Any]<br ALIGN="LEFT"/>get_visualization_data(): Dict[str, Any]<br ALIGN="LEFT"/>optimize_resources(profile: LoadProfile): None<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.core.tiling.quantum_geometric_attention.AttentionMetrics" [color="black", fontcolor="black", label=<{src.core.tiling.quantum_geometric_attention.AttentionMetrics|complexity<br ALIGN="LEFT"/>entropy<br ALIGN="LEFT"/>sparsity : Optional[torch.Tensor]<br ALIGN="LEFT"/>stability : Optional[torch.Tensor]<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"src.core.tiling.quantum_geometric_attention.AttentionState" [color="black", fontcolor="black", label=<{src.core.tiling.quantum_geometric_attention.AttentionState|attention_scores : Optional[torch.Tensor]<br ALIGN="LEFT"/>geometric_state<br ALIGN="LEFT"/>quantum_state<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"src.core.tiling.quantum_geometric_attention.FlowMetrics" [color="black", fontcolor="black", label=<{src.core.tiling.quantum_geometric_attention.FlowMetrics|curvature<br ALIGN="LEFT"/>energy<br ALIGN="LEFT"/>geodesic_distance<br ALIGN="LEFT"/>parallel_transport<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"src.core.tiling.quantum_geometric_attention.GeometricStructures" [color="black", fontcolor="black", label=<{src.core.tiling.quantum_geometric_attention.GeometricStructures|curvature : float<br ALIGN="LEFT"/>dim : int<br ALIGN="LEFT"/>exp_map<br ALIGN="LEFT"/>log_map<br ALIGN="LEFT"/>manifold_type : str<br ALIGN="LEFT"/>parallel_transport_method : str<br ALIGN="LEFT"/>transport<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"src.core.tiling.quantum_geometric_attention.PatternDynamics" [color="black", fontcolor="black", label=<{src.core.tiling.quantum_geometric_attention.PatternDynamics|adaptation_rate : float<br ALIGN="LEFT"/>dim : int<br ALIGN="LEFT"/>num_heads : int<br ALIGN="LEFT"/>num_patterns : int<br ALIGN="LEFT"/>pattern_scores<br ALIGN="LEFT"/>patterns<br ALIGN="LEFT"/>temperature : float<br ALIGN="LEFT"/>|update_patterns(x: torch.Tensor): torch.Tensor<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.core.tiling.quantum_geometric_attention.QuantumGeometricAttention" [color="black", fontcolor="black", label=<{src.core.tiling.quantum_geometric_attention.QuantumGeometricAttention|arithmetic<br ALIGN="LEFT"/>attention<br ALIGN="LEFT"/>curvature : float<br ALIGN="LEFT"/>dropout<br ALIGN="LEFT"/>exp_map<br ALIGN="LEFT"/>flow<br ALIGN="LEFT"/>head_dim<br ALIGN="LEFT"/>hidden_dim : int<br ALIGN="LEFT"/>log_map<br ALIGN="LEFT"/>manifold_dim : int<br ALIGN="LEFT"/>manifold_type : str<br ALIGN="LEFT"/>metric<br ALIGN="LEFT"/>motive_rank : int<br ALIGN="LEFT"/>num_heads : int<br ALIGN="LEFT"/>num_layers : int<br ALIGN="LEFT"/>pattern_proj<br ALIGN="LEFT"/>scale<br ALIGN="LEFT"/>tile_size : int<br ALIGN="LEFT"/>tiles<br ALIGN="LEFT"/>to_out<br ALIGN="LEFT"/>to_qkv<br ALIGN="LEFT"/>transport<br ALIGN="LEFT"/>|build_attention_complex(query: torch.Tensor, key: torch.Tensor, value: torch.Tensor, mask: Optional[torch.Tensor]): Tuple[torch.Tensor, AttentionMetrics]<br ALIGN="LEFT"/>classical_to_quantum(x: torch.Tensor): torch.Tensor<br ALIGN="LEFT"/>compute_attention_patterns(x: torch.Tensor, mask: Optional[torch.Tensor], return_metrics: bool): Union[torch.Tensor, Tuple[torch.Tensor, AttentionMetrics]]<br ALIGN="LEFT"/>compute_complexity(features: torch.Tensor): torch.Tensor<br ALIGN="LEFT"/>compute_entropy(features: torch.Tensor): torch.Tensor<br ALIGN="LEFT"/>compute_fisher_information(states: torch.Tensor): torch.Tensor<br ALIGN="LEFT"/>compute_metric_tensor(state: AttentionState): torch.Tensor<br ALIGN="LEFT"/>compute_sparsity(features: torch.Tensor): torch.Tensor<br ALIGN="LEFT"/>compute_stability(features: torch.Tensor): torch.Tensor<br ALIGN="LEFT"/>create_attention_parameters(batch_size: int, seq_len: int): Dict[str, torch.Tensor]<br ALIGN="LEFT"/>detect_patterns(x: torch.Tensor): Tuple[torch.Tensor, Dict[str, Any]]<br ALIGN="LEFT"/>forward(x: torch.Tensor, mask: Optional[torch.Tensor], return_metrics: bool): Tuple[torch.Tensor, Optional[Dict[str, Any]]]<br ALIGN="LEFT"/>prepare_attention_state(x: torch.Tensor, mask: Optional[torch.Tensor]): AttentionState<br ALIGN="LEFT"/>prepare_code_state(x: torch.Tensor): torch.Tensor<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.core.tiling.quantum_geometric_attention.QuantumGeometricTransformer" [color="black", fontcolor="black", label=<{src.core.tiling.quantum_geometric_attention.QuantumGeometricTransformer|layers<br ALIGN="LEFT"/>norm<br ALIGN="LEFT"/>|forward(x: torch.Tensor, return_patterns: bool): Tuple[torch.Tensor, Optional[List[Dict[str, Any]]]]<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.core.tiling.state_manager.StateConfig" [color="black", fontcolor="black", label=<{src.core.tiling.state_manager.StateConfig|dim : int<br ALIGN="LEFT"/>epsilon : float<br ALIGN="LEFT"/>max_entanglement : float<br ALIGN="LEFT"/>type<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"src.core.tiling.state_manager.StateManager" [color="black", fontcolor="black", label=<{src.core.tiling.state_manager.StateManager|config<br ALIGN="LEFT"/>device : NoneType<br ALIGN="LEFT"/>history : list<br ALIGN="LEFT"/>states : dict<br ALIGN="LEFT"/>|calculate_fidelity(state1: torch.Tensor, state2: torch.Tensor): float<br ALIGN="LEFT"/>get_entanglement_history(source_scale: Optional[float], target_scale: Optional[float]): Dict[str, List[float]]<br ALIGN="LEFT"/>get_state_history(key: str): List[torch.Tensor]<br ALIGN="LEFT"/>initialize_state(key: str, dim: Optional[int]): torch.Tensor<br ALIGN="LEFT"/>update_entanglement(source_scale: float, target_scale: float, entropy: torch.Tensor): None<br ALIGN="LEFT"/>update_state(key: str, update: torch.Tensor, learning_rate: float): torch.Tensor<br ALIGN="LEFT"/>validate_state(state: torch.Tensor): bool<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.core.tiling.state_manager.StateType" [color="black", fontcolor="black", label=<{src.core.tiling.state_manager.StateType|name<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"src.core.types.FiberBundleProtocol" [color="black", fontcolor="black", label=<{src.core.types.FiberBundleProtocol|base_dim : int<br ALIGN="LEFT"/>fiber_dim : int<br ALIGN="LEFT"/>total_dim : int<br ALIGN="LEFT"/>|bundle_projection(total_space: torch.Tensor): torch.Tensor<br ALIGN="LEFT"/>get_connection(point: torch.Tensor): torch.Tensor<br ALIGN="LEFT"/>get_fiber(point: torch.Tensor): torch.Tensor<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.core.types.GeometricFlowProtocol" [color="black", fontcolor="black", label=<{src.core.types.GeometricFlowProtocol|<br ALIGN="LEFT"/>|compute_metric(x: torch.Tensor): torch.Tensor<br ALIGN="LEFT"/>compute_ricci_tensor(metric: torch.Tensor, connection: Optional[torch.Tensor]): torch.Tensor<br ALIGN="LEFT"/>detect_singularities(flow: torch.Tensor, threshold: float): List[Dict[str, Any]]<br ALIGN="LEFT"/>flow_step(metric: torch.Tensor, ricci: torch.Tensor, timestep: float): Tuple[torch.Tensor, Dict[str, Any]]<br ALIGN="LEFT"/>forward(x: torch.Tensor, return_path: bool): Tuple[torch.Tensor, Dict[str, Any]]<br ALIGN="LEFT"/>normalize_flow(flow: torch.Tensor, normalization: str): torch.Tensor<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.core.types.PatternState" [color="black", fontcolor="black", label=<{src.core.types.PatternState|connection : Optional[torch.Tensor]<br ALIGN="LEFT"/>coordinates<br ALIGN="LEFT"/>curvature : Optional[torch.Tensor]<br ALIGN="LEFT"/>metric<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"src.core.types.RiemannianMetric" [color="black", fontcolor="black", label=<{src.core.types.RiemannianMetric|christoffel_symbols : Optional[torch.Tensor]<br ALIGN="LEFT"/>curvature : Optional[torch.Tensor]<br ALIGN="LEFT"/>tensor<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"src.core.vulkan.memory.MemoryBlock" [color="black", fontcolor="black", label=<{src.core.vulkan.memory.MemoryBlock|memory : Any<br ALIGN="LEFT"/>offset : int<br ALIGN="LEFT"/>size : int<br ALIGN="LEFT"/>type_index : int<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"src.core.vulkan.memory.VulkanMemory" [color="black", fontcolor="black", label=<{src.core.vulkan.memory.VulkanMemory|allocations : Dict[int, MemoryBlock]<br ALIGN="LEFT"/>device : Union[int, c_void_p]<br ALIGN="LEFT"/>memory_properties<br ALIGN="LEFT"/>peak_allocated : int<br ALIGN="LEFT"/>physical_device : Union[int, c_void_p]<br ALIGN="LEFT"/>total_allocated : int<br ALIGN="LEFT"/>|allocate(size: int, memory_type_bits: int, properties: int): MemoryBlock<br ALIGN="LEFT"/>cleanup()<br ALIGN="LEFT"/>free(block: MemoryBlock)<br ALIGN="LEFT"/>get_stats(): Dict[str, float]<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.core.vulkan.resources.BufferResource" [color="black", fontcolor="black", label=<{src.core.vulkan.resources.BufferResource|buffer : int<br ALIGN="LEFT"/>memory<br ALIGN="LEFT"/>size : int<br ALIGN="LEFT"/>usage : int<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"src.core.vulkan.resources.ConvertibleToInt" [color="black", fontcolor="black", label=<{src.core.vulkan.resources.ConvertibleToInt|<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"src.core.vulkan.resources.ImageResource" [color="black", fontcolor="black", label=<{src.core.vulkan.resources.ImageResource|extent : Any<br ALIGN="LEFT"/>format : int<br ALIGN="LEFT"/>image : int<br ALIGN="LEFT"/>memory<br ALIGN="LEFT"/>view : int<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"src.core.vulkan.resources.MemoryRequirements" [color="black", fontcolor="black", label=<{src.core.vulkan.resources.MemoryRequirements|alignment : int<br ALIGN="LEFT"/>memory_type_bits : int<br ALIGN="LEFT"/>size : int<br ALIGN="LEFT"/>|from_vulkan(vulkan_reqs: VkMemoryRequirements): 'MemoryRequirements'<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.core.vulkan.resources.VkMemoryRequirements" [color="black", fontcolor="black", label=<{src.core.vulkan.resources.VkMemoryRequirements|<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"src.core.vulkan.resources.VulkanResources" [color="black", fontcolor="black", label=<{src.core.vulkan.resources.VulkanResources|buffers : Dict[int, BufferResource]<br ALIGN="LEFT"/>device : int<br ALIGN="LEFT"/>images : Dict[int, ImageResource]<br ALIGN="LEFT"/>memory<br ALIGN="LEFT"/>|cleanup()<br ALIGN="LEFT"/>create_buffer(size: int, usage: int, sharing_mode: int, memory_properties: int): BufferResource<br ALIGN="LEFT"/>create_image(format: int, width: int, height: int, depth: int, usage: int, sharing_mode: int, memory_properties: int): ImageResource<br ALIGN="LEFT"/>destroy_buffer(resource: BufferResource)<br ALIGN="LEFT"/>destroy_image(resource: ImageResource)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.infrastructure.base.CPUOptimizer" [color="black", fontcolor="black", label=<{src.infrastructure.base.CPUOptimizer|enable_profiling : bool<br ALIGN="LEFT"/>|get_metrics(): Dict[str, float]<br ALIGN="LEFT"/>get_thread_info(): List[Dict[str, Any]]<br ALIGN="LEFT"/>optimize(func: Callable, data: torch.Tensor): torch.Tensor<br ALIGN="LEFT"/>profile()<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.infrastructure.base.DeviceInfo" [color="black", fontcolor="black", label=<{src.infrastructure.base.DeviceInfo|compute_support : bool<br ALIGN="LEFT"/>memory_types : List[str]<br ALIGN="LEFT"/>queue_families : List[str]<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"src.infrastructure.base.InfrastructureMetrics" [color="black", fontcolor="black", label=<{src.infrastructure.base.InfrastructureMetrics|cpu_metrics : Dict[str, float]<br ALIGN="LEFT"/>memory_metrics : Dict[str, float]<br ALIGN="LEFT"/>parallel_metrics : Dict[str, float]<br ALIGN="LEFT"/>resource_metrics : Dict[str, float]<br ALIGN="LEFT"/>vulkan_metrics : Dict[str, float]<br ALIGN="LEFT"/>|collect(cpu_optimizer: CPUOptimizer, memory_manager: MemoryManager, vulkan_integration: VulkanIntegration, parallel_processor: ParallelProcessor, resource_allocator: ResourceAllocator): Dict[str, Dict[str, float]]<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.infrastructure.base.MemoryManager" [color="black", fontcolor="black", label=<{src.infrastructure.base.MemoryManager|pool_size : int<br ALIGN="LEFT"/>|cleanup()<br ALIGN="LEFT"/>get_memory_stats(): MemoryStats<br ALIGN="LEFT"/>manage_tensor(tensor: torch.Tensor): torch.Tensor<br ALIGN="LEFT"/>optimize()<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.infrastructure.base.MemoryStats" [color="black", fontcolor="black", label=<{src.infrastructure.base.MemoryStats|active_blocks : int<br ALIGN="LEFT"/>peak_allocated : int<br ALIGN="LEFT"/>total_allocated : int<br ALIGN="LEFT"/>total_cached : int<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"src.infrastructure.base.MemoryManager.optimize.OptimizeContext" [color="black", fontcolor="black", label=<{src.infrastructure.base.OptimizeContext|<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"src.infrastructure.base.ParallelProcessor" [color="black", fontcolor="black", label=<{src.infrastructure.base.ParallelProcessor|num_threads : int<br ALIGN="LEFT"/>|get_stats(): Dict[str, float]<br ALIGN="LEFT"/>merge_results(results: List[torch.Tensor]): torch.Tensor<br ALIGN="LEFT"/>partition_data(data: torch.Tensor): List[torch.Tensor]<br ALIGN="LEFT"/>process_parallel(func: Callable, chunks: List[torch.Tensor]): List[torch.Tensor]<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.infrastructure.base.CPUOptimizer.profile.ProfileContext" [color="black", fontcolor="black", label=<{src.infrastructure.base.ProfileContext|<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"src.infrastructure.base.ResourceAllocationError" [color="black", fontcolor="red", label=<{src.infrastructure.base.ResourceAllocationError|<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"src.infrastructure.base.ResourceAllocator" [color="black", fontcolor="black", label=<{src.infrastructure.base.ResourceAllocator|compute_limit : float<br ALIGN="LEFT"/>memory_limit : int<br ALIGN="LEFT"/>|cleanup()<br ALIGN="LEFT"/>get_status(): Dict[str, Any]<br ALIGN="LEFT"/>plan_allocation(memory_size: int, compute_intensity: float): Dict[str, Any]<br ALIGN="LEFT"/>run_with_limits(func: Callable, memory_limit: Optional[int], cpu_limit: Optional[float]): Any<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.infrastructure.base.VulkanIntegration" [color="black", fontcolor="black", label=<{src.infrastructure.base.VulkanIntegration|<br ALIGN="LEFT"/>|compute(shader_code: str, buffer: Any, workgroup_size: int): Any<br ALIGN="LEFT"/>create_buffer(data: torch.Tensor): Any<br ALIGN="LEFT"/>download_buffer(buffer: Any): torch.Tensor<br ALIGN="LEFT"/>get_device_info(): DeviceInfo<br ALIGN="LEFT"/>get_queue_status(): str<br ALIGN="LEFT"/>wait_idle()<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.infrastructure.cpu_optimizer.CPUOptimizer" [color="black", fontcolor="black", label=<{src.infrastructure.cpu_optimizer.CPUOptimizer|cache_optimization_enabled : bool<br ALIGN="LEFT"/>thread_pool_size<br ALIGN="LEFT"/>vectorization_enabled : bool<br ALIGN="LEFT"/>|enable_cache_optimization(enabled: bool): None<br ALIGN="LEFT"/>enable_vectorization(enabled: bool): None<br ALIGN="LEFT"/>optimize_memory_layout(data: np.ndarray): np.ndarray<br ALIGN="LEFT"/>set_thread_pool_size(size: int): None<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.infrastructure.memory_manager.MemoryManager" [color="black", fontcolor="black", label=<{src.infrastructure.memory_manager.MemoryManager|allocated : int<br ALIGN="LEFT"/>pool_size : int<br ALIGN="LEFT"/>pools : Dict[str, Any]<br ALIGN="LEFT"/>|allocate(size: int, dtype: np.dtype): Optional[np.ndarray]<br ALIGN="LEFT"/>clear_pools(): None<br ALIGN="LEFT"/>deallocate(array: np.ndarray): None<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.infrastructure.metrics.InfrastructureMetrics" [color="black", fontcolor="black", label=<{src.infrastructure.metrics.InfrastructureMetrics|device_info : Dict[str, str]<br ALIGN="LEFT"/>error_log : List[str]<br ALIGN="LEFT"/>performance<br ALIGN="LEFT"/>resources<br ALIGN="LEFT"/>|get_summary(): str<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.infrastructure.metrics.PerformanceMetrics" [color="black", fontcolor="black", label=<{src.infrastructure.metrics.PerformanceMetrics|compute_time : float<br ALIGN="LEFT"/>memory_time : float<br ALIGN="LEFT"/>sync_time : float<br ALIGN="LEFT"/>total_time : float<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"src.infrastructure.metrics.ResourceMetrics" [color="black", fontcolor="black", label=<{src.infrastructure.metrics.ResourceMetrics|cpu_utilization : Optional[float]<br ALIGN="LEFT"/>gpu_utilization : Optional[float]<br ALIGN="LEFT"/>memory_available : float<br ALIGN="LEFT"/>memory_used : float<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"src.infrastructure.parallel.ParallelProcessor" [color="black", fontcolor="black", label=<{src.infrastructure.parallel.ParallelProcessor|device : str<br ALIGN="LEFT"/>num_processes<br ALIGN="LEFT"/>num_threads<br ALIGN="LEFT"/>process_pool : Pool<br ALIGN="LEFT"/>thread_pool : ThreadPoolExecutor<br ALIGN="LEFT"/>|batch_process(func: Callable, data: torch.Tensor, batch_size: int, use_processes: bool): List[torch.Tensor]<br ALIGN="LEFT"/>cleanup()<br ALIGN="LEFT"/>parallel_execute(funcs: List[Callable], use_processes: bool): List[Any]<br ALIGN="LEFT"/>parallel_map(func: Callable, data: List[Any], use_processes: bool): List[Any]<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.infrastructure.resource.ResourceAllocator" [color="black", fontcolor="black", label=<{src.infrastructure.resource.ResourceAllocator|allocations : Dict[str, Dict]<br ALIGN="LEFT"/>compute_allocated : int<br ALIGN="LEFT"/>compute_limit : Optional[int]<br ALIGN="LEFT"/>device : str<br ALIGN="LEFT"/>memory_allocated : int<br ALIGN="LEFT"/>memory_limit : Optional[int]<br ALIGN="LEFT"/>|allocate_compute(units: int, name: str, priority: int): bool<br ALIGN="LEFT"/>allocate_memory(size: int, name: str, priority: int): bool<br ALIGN="LEFT"/>cleanup()<br ALIGN="LEFT"/>free(name: str)<br ALIGN="LEFT"/>get_available_compute(): float<br ALIGN="LEFT"/>get_available_memory(): float<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.infrastructure.vulkan_integration.VulkanIntegration" [color="black", fontcolor="black", label=<{src.infrastructure.vulkan_integration.VulkanIntegration|command_pool : NoneType<br ALIGN="LEFT"/>compute_queue : NoneType<br ALIGN="LEFT"/>device : NoneType<br ALIGN="LEFT"/>pipeline_cache : Dict[str, Any]<br ALIGN="LEFT"/>|cleanup(): None<br ALIGN="LEFT"/>create_compute_pipeline(shader_path: str): Optional[Any]<br ALIGN="LEFT"/>execute_compute(pipeline: Any, data: np.ndarray): Optional[np.ndarray]<br ALIGN="LEFT"/>initialize(): bool<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.metrics.load_analyzer.LoadBalanceAnalyzer" [color="black", fontcolor="black", label=<{src.metrics.load_analyzer.LoadBalanceAnalyzer|history<br ALIGN="LEFT"/>overload_threshold : float<br ALIGN="LEFT"/>underload_threshold : float<br ALIGN="LEFT"/>variance_threshold : float<br ALIGN="LEFT"/>|add_metrics(metrics: dict): None<br ALIGN="LEFT"/>analyze_network(tiles: list[AttentionTile]): dict[str, Any]<br ALIGN="LEFT"/>get_convergence_rate(): float<br ALIGN="LEFT"/>get_load_distribution(): tuple[float, float, float]<br ALIGN="LEFT"/>get_recommendations(tiles: list[AttentionTile]): list[str]<br ALIGN="LEFT"/>get_stability_score(): float<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.metrics.metrics_tracker.MetricsTracker" [color="black", fontcolor="black", label=<{src.metrics.metrics_tracker.MetricsTracker|num_runs : int<br ALIGN="LEFT"/>total_flops : int<br ALIGN="LEFT"/>total_memory : int<br ALIGN="LEFT"/>total_time : int<br ALIGN="LEFT"/>|compute_metrics(model: nn.Module, input_tensor: torch.Tensor, output_tensor: torch.Tensor): Dict[str, float]<br ALIGN="LEFT"/>reset()<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.metrics.quantum_geometric_metrics.ArithmeticMetrics" [color="black", fontcolor="black", label=<{src.metrics.quantum_geometric_metrics.ArithmeticMetrics|hidden_dim : int<br ALIGN="LEFT"/>motive_proj<br ALIGN="LEFT"/>motive_rank : int<br ALIGN="LEFT"/>num_primes : int<br ALIGN="LEFT"/>prime_bases<br ALIGN="LEFT"/>|compute_adelic_norm(patterns: torch.Tensor, context: MetricContext): torch.Tensor<br ALIGN="LEFT"/>compute_global_height(patterns: torch.Tensor, context: MetricContext): torch.Tensor<br ALIGN="LEFT"/>compute_height_distribution(patterns: torch.Tensor, context: MetricContext, num_bins: int): Tuple[torch.Tensor, torch.Tensor]<br ALIGN="LEFT"/>compute_l_function(patterns: torch.Tensor, context: MetricContext): torch.Tensor<br ALIGN="LEFT"/>compute_local_height(patterns: torch.Tensor, context: MetricContext): torch.Tensor<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.metrics.quantum_geometric_metrics.BaseMetric" [color="black", fontcolor="black", label=<{src.metrics.quantum_geometric_metrics.BaseMetric|domain<br ALIGN="LEFT"/>history : List[T]<br ALIGN="LEFT"/>name : str<br ALIGN="LEFT"/>|<I>compute</I>(): T<br ALIGN="LEFT"/>reset(): None<br ALIGN="LEFT"/>update(value: T, context: MetricContext): None<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.metrics.quantum_geometric_metrics.GeometricMetrics" [color="black", fontcolor="black", label=<{src.metrics.quantum_geometric_metrics.GeometricMetrics|hidden_dim : int<br ALIGN="LEFT"/>manifold_dim : int<br ALIGN="LEFT"/>|compute_curvature(flow_path: torch.Tensor, context: MetricContext): torch.Tensor<br ALIGN="LEFT"/>compute_geodesic_distance(flow_path: torch.Tensor, context: MetricContext): torch.Tensor<br ALIGN="LEFT"/>compute_parallel_transport(vector: torch.Tensor, connection: torch.Tensor, context: MetricContext): torch.Tensor<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.metrics.quantum_geometric_metrics.MetricContext" [color="black", fontcolor="black", label=<{src.metrics.quantum_geometric_metrics.MetricContext|batch_size : int<br ALIGN="LEFT"/>device<br ALIGN="LEFT"/>hidden_dim : int<br ALIGN="LEFT"/>resolution : float<br ALIGN="LEFT"/>sequence_length : int<br ALIGN="LEFT"/>timestamp : float<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"src.metrics.quantum_geometric_metrics.MetricDomain" [color="black", fontcolor="black", label=<{src.metrics.quantum_geometric_metrics.MetricDomain|name<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"src.metrics.quantum_geometric_metrics.PatternMetrics" [color="black", fontcolor="black", label=<{src.metrics.quantum_geometric_metrics.PatternMetrics|<br ALIGN="LEFT"/>|compute_pattern_complexity(patterns: torch.Tensor, context: MetricContext): torch.Tensor<br ALIGN="LEFT"/>compute_pattern_entropy(patterns: torch.Tensor, context: MetricContext): torch.Tensor<br ALIGN="LEFT"/>compute_pattern_stability(patterns: torch.Tensor, context: MetricContext): torch.Tensor<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.metrics.quantum_geometric_metrics.QuantumMetrics" [color="black", fontcolor="black", label=<{src.metrics.quantum_geometric_metrics.QuantumMetrics|hidden_dim : int<br ALIGN="LEFT"/>motive_rank : int<br ALIGN="LEFT"/>|compute_cohomology_class(attention_patterns: torch.Tensor, context: MetricContext): torch.Tensor<br ALIGN="LEFT"/>compute_motive_height(cohomology: torch.Tensor, context: MetricContext): torch.Tensor<br ALIGN="LEFT"/>compute_quantum_entropy(patterns: torch.Tensor, context: MetricContext): torch.Tensor<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.metrics.quantum_geometric_metrics.UnifiedMetrics" [color="black", fontcolor="black", label=<{src.metrics.quantum_geometric_metrics.UnifiedMetrics|arithmetic<br ALIGN="LEFT"/>geometric<br ALIGN="LEFT"/>hidden_dim : int<br ALIGN="LEFT"/>manifold_dim : int<br ALIGN="LEFT"/>motive_rank : int<br ALIGN="LEFT"/>num_bins : int<br ALIGN="LEFT"/>num_heads : int<br ALIGN="LEFT"/>num_primes : int<br ALIGN="LEFT"/>pattern<br ALIGN="LEFT"/>quantum<br ALIGN="LEFT"/>|compute_all_metrics(data: Dict[str, torch.Tensor], context: MetricContext): Dict[str, torch.Tensor]<br ALIGN="LEFT"/>compute_pattern_evolution(pattern_history: List[torch.Tensor], context: MetricContext): torch.Tensor<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.metrics.synthetic_data.SyntheticDataGenerator" [color="black", fontcolor="black", label=<{src.metrics.synthetic_data.SyntheticDataGenerator|num_values : int<br ALIGN="LEFT"/>vocab_size : int<br ALIGN="LEFT"/>|generate_constant_sequence(length: int, batch_size: int): torch.Tensor<br ALIGN="LEFT"/>generate_density_pattern(sequence_length: int): torch.Tensor<br ALIGN="LEFT"/>generate_edge_cases(): Sequence[tuple[torch.Tensor, torch.Tensor]]<br ALIGN="LEFT"/>generate_mixed_sequence(sequence_length: int): torch.Tensor<br ALIGN="LEFT"/>generate_pattern_sequence(length: int, pattern_length: int, batch_size: int): torch.Tensor<br ALIGN="LEFT"/>generate_random_sequence(length: int, batch_size: int): torch.Tensor<br ALIGN="LEFT"/>generate_test_batch(num_sequences: int, min_length: int, max_length: int): Sequence[torch.Tensor]<br ALIGN="LEFT"/>generate_test_sequence(sequence_length: int, batch_size: int): tuple[torch.Tensor, torch.Tensor]<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.neural.attention.pattern.diffusion.DiffusionSystem" [color="black", fontcolor="black", label=<{src.neural.attention.pattern.diffusion.DiffusionSystem|kernel<br ALIGN="LEFT"/>size : int<br ALIGN="LEFT"/>|apply_diffusion(state: torch.Tensor, diffusion_coefficient: float, dt: float): torch.Tensor<br ALIGN="LEFT"/>forward(state: torch.Tensor, diffusion_coefficient: Union[float, torch.Tensor], dt: float): torch.Tensor<br ALIGN="LEFT"/>test_convergence(state: torch.Tensor, diffusion_coefficient: float, dt: float, max_iter: int, tol: float): bool<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.neural.attention.pattern.dynamics.PatternDynamics" [color="black", fontcolor="black", label=<{src.neural.attention.pattern.dynamics.PatternDynamics|boundary : str<br ALIGN="LEFT"/>diffusion<br ALIGN="LEFT"/>dim : int<br ALIGN="LEFT"/>dt : float<br ALIGN="LEFT"/>hidden_dim : int<br ALIGN="LEFT"/>num_modes : int<br ALIGN="LEFT"/>quantum_enabled : bool<br ALIGN="LEFT"/>quantum_tensor<br ALIGN="LEFT"/>reaction<br ALIGN="LEFT"/>size : int<br ALIGN="LEFT"/>stability<br ALIGN="LEFT"/>|apply_diffusion(state: torch.Tensor, diffusion_coefficient: float, dt: Optional[float]): torch.Tensor<br ALIGN="LEFT"/>apply_reaction(state: torch.Tensor, reaction_term: Optional[Callable], dt: Optional[float]): torch.Tensor<br ALIGN="LEFT"/>apply_scale_transform(pattern: torch.Tensor, scale: torch.Tensor): torch.Tensor<br ALIGN="LEFT"/>apply_symmetry(pattern: torch.Tensor, symmetry: torch.Tensor): torch.Tensor<br ALIGN="LEFT"/>bifurcation_analysis(pattern: torch.Tensor, parameterized_reaction: Callable[[torch.Tensor, torch.Tensor], torch.Tensor], parameter_range: torch.Tensor, max_iter: int, max_states: int): BifurcationDiagram<br ALIGN="LEFT"/>compute_berry_phase(state: torch.Tensor, path: torch.Tensor): float<br ALIGN="LEFT"/>compute_eigenvalues(state: torch.Tensor): torch.Tensor<br ALIGN="LEFT"/>compute_energy(state: torch.Tensor): torch.Tensor<br ALIGN="LEFT"/>compute_jacobian(state: torch.Tensor): torch.Tensor<br ALIGN="LEFT"/>compute_linearization(pattern: torch.Tensor): torch.Tensor<br ALIGN="LEFT"/>compute_lyapunov_spectrum(state: torch.Tensor, steps: int, dt: Optional[float]): torch.Tensor<br ALIGN="LEFT"/>compute_next_state(state: torch.Tensor): torch.Tensor<br ALIGN="LEFT"/>compute_normal_form(bifurcation_point: dict): torch.Tensor<br ALIGN="LEFT"/>compute_quantum_potential(state: torch.Tensor): torch.Tensor<br ALIGN="LEFT"/>compute_stability_matrix(state: torch.Tensor, epsilon: float, chunk_size: int): torch.Tensor<br ALIGN="LEFT"/>detect_pattern_formation(evolution: List[torch.Tensor]): bool<br ALIGN="LEFT"/>evolve_pattern(pattern: torch.Tensor, diffusion_coefficient: float, reaction_term: Optional[Callable], steps: int): List[torch.Tensor]<br ALIGN="LEFT"/>evolve_spatiotemporal(initial: torch.Tensor, coupling: Callable, steps: int, t_span: Optional[Tuple[float, float]], dt: Optional[float]): List[torch.Tensor]<br ALIGN="LEFT"/>find_homogeneous_state(): torch.Tensor<br ALIGN="LEFT"/>find_reaction_fixed_points(state: torch.Tensor): torch.Tensor<br ALIGN="LEFT"/>forward(states: torch.Tensor, return_patterns: bool): dict[str, torch.Tensor]<br ALIGN="LEFT"/>is_stable(state: torch.Tensor, threshold: float): bool<br ALIGN="LEFT"/>pattern_control(current: torch.Tensor, target: torch.Tensor, constraints: List[Callable]): ControlSignal<br ALIGN="LEFT"/>reaction_diffusion(state: torch.Tensor, reaction_term: Optional[Callable], max_iterations: int, dt: float): torch.Tensor<br ALIGN="LEFT"/>stability_analysis(fixed_point: Union[ReactionDiffusionState, torch.Tensor], perturbation: torch.Tensor): StabilityMetrics<br ALIGN="LEFT"/>step(state: torch.Tensor, diffusion_coefficient: float, reaction_term: Optional[Callable]): torch.Tensor<br ALIGN="LEFT"/>test_structural_stability(state: torch.Tensor, perturbed_reaction: Callable, epsilon: float, steps: int): float<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.neural.attention.pattern.quantum.QuantumGeometricTensor" [color="black", fontcolor="black", label=<{src.neural.attention.pattern.quantum.QuantumGeometricTensor|dim : int<br ALIGN="LEFT"/>|compute_tensor(state: QuantumState): torch.Tensor<br ALIGN="LEFT"/>decompose(Q: torch.Tensor): Tuple[torch.Tensor, torch.Tensor]<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.neural.attention.pattern.reaction.ReactionSystem" [color="black", fontcolor="black", label=<{src.neural.attention.pattern.reaction.ReactionSystem|activator_network<br ALIGN="LEFT"/>grid_size : int<br ALIGN="LEFT"/>inhibitor_network<br ALIGN="LEFT"/>|apply_reaction(state: torch.Tensor, reaction_term: Optional[Callable]): torch.Tensor<br ALIGN="LEFT"/>find_reaction_fixed_points(state: torch.Tensor, reaction_term: Optional[Callable]): torch.Tensor<br ALIGN="LEFT"/>reaction_term(state: torch.Tensor): torch.Tensor<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.neural.attention.pattern.stability.StabilityAnalyzer" [color="black", fontcolor="black", label=<{src.neural.attention.pattern.stability.StabilityAnalyzer|pattern_system<br ALIGN="LEFT"/>|analyze_stability(state: torch.Tensor, perturbation: torch.Tensor): StabilityMetrics<br ALIGN="LEFT"/>compute_eigenvalues(state: torch.Tensor): Tuple[torch.Tensor, torch.Tensor]<br ALIGN="LEFT"/>compute_jacobian(state: torch.Tensor, eps: float): torch.Tensor<br ALIGN="LEFT"/>compute_lyapunov_spectrum(state: torch.Tensor, steps: int, dt: Optional[float]): torch.Tensor<br ALIGN="LEFT"/>compute_stability(state: torch.Tensor, reaction_term: Optional[Callable[[torch.Tensor], torch.Tensor]]): torch.Tensor<br ALIGN="LEFT"/>find_bifurcation(state: torch.Tensor, parameter_range: torch.Tensor, parameter_name: str, threshold: float): Optional[float]<br ALIGN="LEFT"/>is_stable(state: torch.Tensor, reaction_term: Optional[Callable[[torch.Tensor], torch.Tensor]], threshold: float): bool<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.utils.memory_management.MemoryOptimizer" [color="black", fontcolor="black", label=<{src.utils.memory_management.MemoryOptimizer|tensor_manager<br ALIGN="LEFT"/>|clear_memory(): None<br ALIGN="LEFT"/>get_memory_stats(): Dict[str, Any]<br ALIGN="LEFT"/>optimize(operation: str)<br ALIGN="LEFT"/>set_max_memory_usage(size_bytes: int): None<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.utils.memory_management.TensorManager" [color="black", fontcolor="black", label=<{src.utils.memory_management.TensorManager|<br ALIGN="LEFT"/>|cleanup_operation(operation: str): None<br ALIGN="LEFT"/>clear_all(): None<br ALIGN="LEFT"/>disable()<br ALIGN="LEFT"/>operation_scope(operation: str)<br ALIGN="LEFT"/>register_tensor(tensor: torch.Tensor, operation: Optional[str]): torch.Tensor<br ALIGN="LEFT"/>set_max_tensor_size(size_bytes: int): None<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.validation.base.BasicValidationResult" [color="black", fontcolor="black", label=<{src.validation.base.BasicValidationResult|<br ALIGN="LEFT"/>|from_dict(data: Dict[str, Any]): 'BasicValidationResult'<br ALIGN="LEFT"/>merge(other: ValidationResult): 'BasicValidationResult'<br ALIGN="LEFT"/>to_dict(): Dict[str, Any]<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.validation.base.ValidationResult" [color="black", fontcolor="black", label=<{src.validation.base.ValidationResult|data : Optional[T \| Dict[str, Any]]<br ALIGN="LEFT"/>is_valid : bool<br ALIGN="LEFT"/>message : str<br ALIGN="LEFT"/>|<I>from_dict</I>(data: Dict[str, Any]): 'ValidationResult'<br ALIGN="LEFT"/><I>merge</I>(other: 'ValidationResult'): 'ValidationResult'<br ALIGN="LEFT"/><I>to_dict</I>(): Dict[str, Any]<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.validation.flow.stability.LinearStabilityValidator" [color="black", fontcolor="black", label=<{src.validation.flow.stability.LinearStabilityValidator|stability_threshold : float<br ALIGN="LEFT"/>tolerance : float<br ALIGN="LEFT"/>|validate_stability(flow: GeometricFlow, state: torch.Tensor): LinearStabilityValidation<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.validation.flow.stability.NonlinearStabilityValidator" [color="black", fontcolor="black", label=<{src.validation.flow.stability.NonlinearStabilityValidator|basin_samples : int<br ALIGN="LEFT"/>tolerance : float<br ALIGN="LEFT"/>|validate_stability(flow: GeometricFlow, state: torch.Tensor, time_steps: int): NonlinearStabilityValidation<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.validation.flow.stability.StructuralStabilityValidator" [color="black", fontcolor="black", label=<{src.validation.flow.stability.StructuralStabilityValidator|parameter_range : float<br ALIGN="LEFT"/>tolerance : float<br ALIGN="LEFT"/>|validate_stability(flow: GeometricFlow, state: torch.Tensor, time_steps: int): StructuralStabilityValidation<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.validation.framework.ConcreteValidationResult" [color="black", fontcolor="black", label=<{src.validation.framework.ConcreteValidationResult|bifurcation_points : Optional[List[torch.Tensor]]<br ALIGN="LEFT"/>component_scores : Dict[str, float]<br ALIGN="LEFT"/>curvature_bounds : Optional[Tuple[float, float]]<br ALIGN="LEFT"/>energy_metrics : Optional[Dict[str, float]]<br ALIGN="LEFT"/>framework_accuracy : float<br ALIGN="LEFT"/>framework_consistency : float<br ALIGN="LEFT"/>metrics : Dict[str, Any]<br ALIGN="LEFT"/>overall_score<br ALIGN="LEFT"/>stability_eigenvalues : Optional[torch.Tensor]<br ALIGN="LEFT"/>|from_dict(data: Dict[str, Any]): 'ConcreteValidationResult'<br ALIGN="LEFT"/>get_summary(): str<br ALIGN="LEFT"/>merge(other: ValidationResult): 'ConcreteValidationResult'<br ALIGN="LEFT"/>to_dict(): Dict[str, Any]<br ALIGN="LEFT"/>validate_metric(metric: torch.Tensor): bool<br ALIGN="LEFT"/>validate_positive_definite(metric: torch.Tensor): bool<br ALIGN="LEFT"/>validate_smoothness(metric: torch.Tensor): bool<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.validation.framework.FrameworkValidationResult" [color="black", fontcolor="black", label=<{src.validation.framework.FrameworkValidationResult|curvature_bounds : Optional[Tuple[float, float]]<br ALIGN="LEFT"/>flow_result : Optional[TilingFlowValidationResult]<br ALIGN="LEFT"/>geometric_result : Optional[GeometricValidationResult]<br ALIGN="LEFT"/>motivic_result : Optional[MotivicValidation]<br ALIGN="LEFT"/>pattern_result : Optional[ValidationResult]<br ALIGN="LEFT"/>quantum_result : Optional[QuantumStateValidationResult]<br ALIGN="LEFT"/>|from_dict(data: Dict[str, Any]): 'FrameworkValidationResult'<br ALIGN="LEFT"/>merge(other: ValidationResult): 'FrameworkValidationResult'<br ALIGN="LEFT"/>to_dict(): Dict[str, Any]<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.validation.framework.ValidationFramework" [color="black", fontcolor="black", label=<{src.validation.framework.ValidationFramework|geometric_validator<br ALIGN="LEFT"/>pattern_validator<br ALIGN="LEFT"/>quantum_validator<br ALIGN="LEFT"/>symplectic_validator<br ALIGN="LEFT"/>tolerance : float<br ALIGN="LEFT"/>|load_results(path: str): FrameworkValidationResult<br ALIGN="LEFT"/>safe_int_cast(value: Union[int, float, torch.Tensor, nn.Module]): int<br ALIGN="LEFT"/>save_results(results: FrameworkValidationResult, path: str)<br ALIGN="LEFT"/>validate_all(model: Any, data: Dict[str, Any], include_symplectic: bool): FrameworkValidationResult<br ALIGN="LEFT"/>validate_geometric(model: Any, data: Dict[str, Any]): GeometricValidationResult<br ALIGN="LEFT"/>validate_pattern_formation(pattern: torch.Tensor, dynamics: Optional[AttentionPatternDynamics], time_steps: int): ValidationResult<br ALIGN="LEFT"/>validate_patterns(patterns: Optional[Any]): ValidationResult<br ALIGN="LEFT"/>validate_quantum(quantum_state: Optional[Any]): QuantumStateValidationResult<br ALIGN="LEFT"/>validate_quantum_state(state: Union[torch.Tensor, QuantumState], prepared: Optional[Union[torch.Tensor, QuantumState]], measurements: Optional[List[Union[torch.Tensor, QuantumState]]], bases: Optional[List[str]]): QuantumStateValidationResult<br ALIGN="LEFT"/>validate_symplectic(structure: SymplecticStructure, point: Tensor, wave_packet: Optional[Tensor], target_point: Optional[Tensor]): FrameworkValidationResult<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.validation.framework.ValidationProtocol" [color="black", fontcolor="black", label=<{src.validation.framework.ValidationProtocol|data : Optional[Dict[str, Any]]<br ALIGN="LEFT"/>is_valid : bool<br ALIGN="LEFT"/>message : str<br ALIGN="LEFT"/>|from_dict(data: Dict[str, Any]): 'ValidationProtocol'<br ALIGN="LEFT"/>merge(other: 'ValidationProtocol'): 'ValidationProtocol'<br ALIGN="LEFT"/>to_dict(): Dict[str, Any]<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.validation.geometric.model.ModelGeometricValidator" [color="black", fontcolor="black", label=<{src.validation.geometric.model.ModelGeometricValidator|curvature_bounds : Tuple[float, float]<br ALIGN="LEFT"/>key_distances<br ALIGN="LEFT"/>layer_validators : dict<br ALIGN="LEFT"/>model_geometry<br ALIGN="LEFT"/>query_distances<br ALIGN="LEFT"/>score_distances<br ALIGN="LEFT"/>tolerance : float<br ALIGN="LEFT"/>|validate_attention_geometry(head_idx: int, query_points: torch.Tensor, key_points: torch.Tensor): GeometricValidationResult<br ALIGN="LEFT"/>validate_cross_layer_geometry(layer1: str, layer2: str, points: torch.Tensor): GeometricValidationResult<br ALIGN="LEFT"/>validate_layer_geometry(layer_name: str, points: torch.Tensor): GeometricValidationResult<br ALIGN="LEFT"/>validate_model_geometry(batch_size: int, manifold_dim: Optional[int], max_memory_gb: float): GeometricValidationResult<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.validation.geometric.symplectic.OperadicValidator" [color="black", fontcolor="black", label=<{src.validation.geometric.symplectic.OperadicValidator|tolerance : float<br ALIGN="LEFT"/>|validate_operadic_transition(structure: SymplecticStructure, source: Tensor, target: Tensor, operation: Optional[Any]): SymplecticValidationResult<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.validation.geometric.symplectic.QuantumGeometricValidator" [color="black", fontcolor="black", label=<{src.validation.geometric.symplectic.QuantumGeometricValidator|tolerance : float<br ALIGN="LEFT"/>|validate_quantum_geometric(structure: SymplecticStructure, point: Tensor): SymplecticValidationResult<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.validation.geometric.symplectic.SymplecticStructureValidator" [color="black", fontcolor="black", label=<{src.validation.geometric.symplectic.SymplecticStructureValidator|operadic_validator<br ALIGN="LEFT"/>quantum_validator<br ALIGN="LEFT"/>tolerance : float<br ALIGN="LEFT"/>wave_validator<br ALIGN="LEFT"/>|validate_all(structure: SymplecticStructure, point: Tensor, wave_packet: Optional[Tensor], target_point: Optional[Tensor]): SymplecticValidationResult<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.validation.geometric.symplectic.WavePacketValidator" [color="black", fontcolor="black", label=<{src.validation.geometric.symplectic.WavePacketValidator|tolerance : float<br ALIGN="LEFT"/>|validate_wave_packet(structure: SymplecticStructure, packet: Tensor, position: Optional[Tensor], momentum: Optional[Tensor]): SymplecticValidationResult<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.validation.patterns.stability.PatternValidator" [color="black", fontcolor="black", label=<{src.validation.patterns.stability.PatternValidator|linear_validator<br ALIGN="LEFT"/>lyapunov_threshold : float<br ALIGN="LEFT"/>nonlinear_validator<br ALIGN="LEFT"/>perturbation_threshold : float<br ALIGN="LEFT"/>structural_validator<br ALIGN="LEFT"/>|validate(pattern_flow: GeometricFlow, initial_state: torch.Tensor, time_steps: int): PatternStabilityResult<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.validation.quantum.evolution.AdiabaticValidation" [color="black", fontcolor="black", label=<{src.validation.quantum.evolution.AdiabaticValidation|adiabatic : bool<br ALIGN="LEFT"/>energy_gap : float<br ALIGN="LEFT"/>fidelity : float<br ALIGN="LEFT"/>transition_prob : float<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"src.validation.quantum.evolution.AdiabaticValidator" [color="black", fontcolor="black", label=<{src.validation.quantum.evolution.AdiabaticValidator|tolerance : float<br ALIGN="LEFT"/>|validate_adiabatic(initial: QuantumState, trajectory: List[QuantumState], hamiltonians: List[torch.Tensor]): AdiabaticValidation<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.validation.quantum.evolution.DecoherenceValidation" [color="black", fontcolor="black", label=<{src.validation.quantum.evolution.DecoherenceValidation|decay_rate : float<br ALIGN="LEFT"/>decoherence_time : float<br ALIGN="LEFT"/>entropy_increase : float<br ALIGN="LEFT"/>purity_loss : float<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"src.validation.quantum.evolution.DecoherenceValidator" [color="black", fontcolor="black", label=<{src.validation.quantum.evolution.DecoherenceValidator|state_validator<br ALIGN="LEFT"/>time_steps : int<br ALIGN="LEFT"/>|validate_decoherence(initial: QuantumState, trajectory: List[QuantumState]): DecoherenceValidation<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.validation.quantum.evolution.QuantumEvolutionValidator" [color="black", fontcolor="black", label=<{src.validation.quantum.evolution.QuantumEvolutionValidator|adiabatic_validator<br ALIGN="LEFT"/>decoherence_validator<br ALIGN="LEFT"/>unitary_validator<br ALIGN="LEFT"/>|validate(initial: QuantumState, evolved: QuantumState, evolution_operator: torch.Tensor, trajectory: List[QuantumState], hamiltonians: List[torch.Tensor]): Tuple[UnitaryValidation, DecoherenceValidation, AdiabaticValidation]<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.validation.quantum.evolution.UnitaryValidation" [color="black", fontcolor="black", label=<{src.validation.quantum.evolution.UnitaryValidation|coherence : float<br ALIGN="LEFT"/>norm_preservation : float<br ALIGN="LEFT"/>phase_error : float<br ALIGN="LEFT"/>unitary : bool<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"src.validation.quantum.evolution.UnitaryValidator" [color="black", fontcolor="black", label=<{src.validation.quantum.evolution.UnitaryValidator|tolerance : float<br ALIGN="LEFT"/>|validate_unitary(initial: QuantumState, evolved: QuantumState, evolution_operator: torch.Tensor): UnitaryValidation<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.validation.quantum.state.DensityMatrixValidation" [color="black", fontcolor="black", label=<{src.validation.quantum.state.DensityMatrixValidation|eigenvalues<br ALIGN="LEFT"/>hermitian : bool<br ALIGN="LEFT"/>positive : bool<br ALIGN="LEFT"/>trace_one : bool<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"src.validation.quantum.state.DensityMatrixValidator" [color="black", fontcolor="black", label=<{src.validation.quantum.state.DensityMatrixValidator|tolerance : float<br ALIGN="LEFT"/>|validate_density_matrix(state: QuantumState): QuantumStateValidationResult<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.validation.quantum.state.EntanglementMetrics" [color="black", fontcolor="black", label=<{src.validation.quantum.state.EntanglementMetrics|concurrence : float<br ALIGN="LEFT"/>log_negativity : float<br ALIGN="LEFT"/>negativity : float<br ALIGN="LEFT"/>ppt_criterion : bool<br ALIGN="LEFT"/>von_neumann_entropy : float<br ALIGN="LEFT"/>witness_value : float<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"src.validation.quantum.state.QuantumStateValidationResult" [color="black", fontcolor="black", label=<{src.validation.quantum.state.QuantumStateValidationResult|error_type : Optional[StateValidationErrorType]<br ALIGN="LEFT"/>|from_dict(data: Dict[str, Any]): 'QuantumStateValidationResult'<br ALIGN="LEFT"/>merge(other: ValidationResult): 'QuantumStateValidationResult'<br ALIGN="LEFT"/>to_dict(): Dict[str, Any]<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.validation.quantum.state.QuantumStateValidator" [color="black", fontcolor="black", label=<{src.validation.quantum.state.QuantumStateValidator|density_validator<br ALIGN="LEFT"/>preparation_validator<br ALIGN="LEFT"/>tomography_validator<br ALIGN="LEFT"/>|validate(target: QuantumState, prepared: QuantumState, measurements: torch.Tensor, bases: List[torch.Tensor]): QuantumStateValidationResult<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.validation.quantum.state.StatePreparationValidation" [color="black", fontcolor="black", label=<{src.validation.quantum.state.StatePreparationValidation|concurrence : float<br ALIGN="LEFT"/>fidelity : float<br ALIGN="LEFT"/>purity : float<br ALIGN="LEFT"/>trace_distance : float<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"src.validation.quantum.state.StatePreparationValidator" [color="black", fontcolor="black", label=<{src.validation.quantum.state.StatePreparationValidator|density_validator<br ALIGN="LEFT"/>tolerance : float<br ALIGN="LEFT"/>tomography_validator<br ALIGN="LEFT"/>|correct_state(state: QuantumState, error_type: StateValidationErrorType): QuantumState<br ALIGN="LEFT"/>validate_preparation(target: QuantumState, prepared: QuantumState): QuantumStateValidationResult<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.validation.quantum.state.StateProperties" [color="black", fontcolor="black", label=<{src.validation.quantum.state.StateProperties|eigenvalues<br ALIGN="LEFT"/>is_normalized : bool<br ALIGN="LEFT"/>is_pure : bool<br ALIGN="LEFT"/>purity : float<br ALIGN="LEFT"/>rank : int<br ALIGN="LEFT"/>trace : complex<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"src.validation.quantum.state.StateValidationErrorType" [color="black", fontcolor="black", label=<{src.validation.quantum.state.StateValidationErrorType|name<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"src.validation.quantum.state.StateValidator" [color="black", fontcolor="black", label=<{src.validation.quantum.state.StateValidator|density_validator<br ALIGN="LEFT"/>preparation_validator<br ALIGN="LEFT"/>tolerance : float<br ALIGN="LEFT"/>tomography_validator<br ALIGN="LEFT"/>|validate_state(state: QuantumState): StateProperties<br ALIGN="LEFT"/>validate_uncertainty(state: QuantumState): UncertaintyMetrics<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.validation.quantum.state.TomographyValidation" [color="black", fontcolor="black", label=<{src.validation.quantum.state.TomographyValidation|completeness : float<br ALIGN="LEFT"/>confidence : float<br ALIGN="LEFT"/>estimated_state<br ALIGN="LEFT"/>reconstruction_error : float<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"src.validation.quantum.state.TomographyValidator" [color="black", fontcolor="black", label=<{src.validation.quantum.state.TomographyValidator|confidence_level : float<br ALIGN="LEFT"/>max_iterations : int<br ALIGN="LEFT"/>|validate_tomography(true_state: QuantumState, measurements: torch.Tensor, bases: List[torch.Tensor]): QuantumStateValidationResult<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.validation.quantum.state.UncertaintyMetrics" [color="black", fontcolor="black", label=<{src.validation.quantum.state.UncertaintyMetrics|energy_uncertainty : float<br ALIGN="LEFT"/>heisenberg_product : float<br ALIGN="LEFT"/>momentum_uncertainty : float<br ALIGN="LEFT"/>position_uncertainty : float<br ALIGN="LEFT"/>robertson_product : float<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"torch._C.Size" [color="black", fontcolor="black", label=<{torch._C.Size|<br ALIGN="LEFT"/>|numel(): _int<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"torch._C.TensorBase" [color="black", fontcolor="black", label=<{torch._C.TensorBase|H<br ALIGN="LEFT"/>T<br ALIGN="LEFT"/>data<br ALIGN="LEFT"/>device<br ALIGN="LEFT"/>dtype<br ALIGN="LEFT"/>grad : Optional[Tensor]<br ALIGN="LEFT"/>grad_fn : Optional[_Node]<br ALIGN="LEFT"/>imag<br ALIGN="LEFT"/>is_cpu : bool<br ALIGN="LEFT"/>is_cuda : bool<br ALIGN="LEFT"/>is_ipu : bool<br ALIGN="LEFT"/>is_leaf : bool<br ALIGN="LEFT"/>is_maia : bool<br ALIGN="LEFT"/>is_meta : bool<br ALIGN="LEFT"/>is_mkldnn : bool<br ALIGN="LEFT"/>is_mps : bool<br ALIGN="LEFT"/>is_mtia : bool<br ALIGN="LEFT"/>is_nested : bool<br ALIGN="LEFT"/>is_quantized : bool<br ALIGN="LEFT"/>is_sparse : bool<br ALIGN="LEFT"/>is_sparse_csr : bool<br ALIGN="LEFT"/>is_vulkan : bool<br ALIGN="LEFT"/>is_xpu : bool<br ALIGN="LEFT"/>itemsize : int<br ALIGN="LEFT"/>layout<br ALIGN="LEFT"/>mH<br ALIGN="LEFT"/>mT<br ALIGN="LEFT"/>names : List[str]<br ALIGN="LEFT"/>nbytes : int<br ALIGN="LEFT"/>ndim : int<br ALIGN="LEFT"/>output_nr : int<br ALIGN="LEFT"/>real<br ALIGN="LEFT"/>requires_grad : bool<br ALIGN="LEFT"/>retains_grad : bool<br ALIGN="LEFT"/>shape<br ALIGN="LEFT"/>|abs(): Tensor<br ALIGN="LEFT"/>abs_(): Tensor<br ALIGN="LEFT"/>absolute(): Tensor<br ALIGN="LEFT"/>absolute_(): Tensor<br ALIGN="LEFT"/>acos(): Tensor<br ALIGN="LEFT"/>acos_(): Tensor<br ALIGN="LEFT"/>acosh(): Tensor<br ALIGN="LEFT"/>acosh_(): Tensor<br ALIGN="LEFT"/>add(other: Union[Tensor, Number, _complex, torch.SymInt, torch.SymFloat]): Tensor<br ALIGN="LEFT"/>add_(other: Union[Tensor, Number, _complex, torch.SymInt, torch.SymFloat]): Tensor<br ALIGN="LEFT"/>addbmm(batch1: Tensor, batch2: Tensor): Tensor<br ALIGN="LEFT"/>addbmm_(batch1: Tensor, batch2: Tensor): Tensor<br ALIGN="LEFT"/>addcdiv(tensor1: Tensor, tensor2: Tensor): Tensor<br ALIGN="LEFT"/>addcdiv_(tensor1: Tensor, tensor2: Tensor): Tensor<br ALIGN="LEFT"/>addcmul(tensor1: Tensor, tensor2: Tensor): Tensor<br ALIGN="LEFT"/>addcmul_(tensor1: Tensor, tensor2: Tensor): Tensor<br ALIGN="LEFT"/>addmm(mat1: Tensor, mat2: Tensor): Tensor<br ALIGN="LEFT"/>addmm_(mat1: Tensor, mat2: Tensor): Tensor<br ALIGN="LEFT"/>addmv(mat: Tensor, vec: Tensor): Tensor<br ALIGN="LEFT"/>addmv_(mat: Tensor, vec: Tensor): Tensor<br ALIGN="LEFT"/>addr(vec1: Tensor, vec2: Tensor): Tensor<br ALIGN="LEFT"/>addr_(vec1: Tensor, vec2: Tensor): Tensor<br ALIGN="LEFT"/>adjoint(): Tensor<br ALIGN="LEFT"/>align_as(other: Tensor): Tensor<br ALIGN="LEFT"/>align_to(order: Sequence[Union[str, ellipsis, None]], ellipsis_idx: _int): Tensor<br ALIGN="LEFT"/>all(): Tensor<br ALIGN="LEFT"/>allclose(other: Tensor, rtol: _float, atol: _float, equal_nan: _bool): _bool<br ALIGN="LEFT"/>amax(dim: Union[_int, _size], keepdim: _bool): Tensor<br ALIGN="LEFT"/>amin(dim: Union[_int, _size], keepdim: _bool): Tensor<br ALIGN="LEFT"/>aminmax(): torch.return_types.aminmax<br ALIGN="LEFT"/>angle(): Tensor<br ALIGN="LEFT"/>any(): Tensor<br ALIGN="LEFT"/>apply_(callable: Callable): Tensor<br ALIGN="LEFT"/>arccos(): Tensor<br ALIGN="LEFT"/>arccos_(): Tensor<br ALIGN="LEFT"/>arccosh(): Tensor<br ALIGN="LEFT"/>arccosh_(): Tensor<br ALIGN="LEFT"/>arcsin(): Tensor<br ALIGN="LEFT"/>arcsin_(): Tensor<br ALIGN="LEFT"/>arcsinh(): Tensor<br ALIGN="LEFT"/>arcsinh_(): Tensor<br ALIGN="LEFT"/>arctan(): Tensor<br ALIGN="LEFT"/>arctan2(other: Tensor): Tensor<br ALIGN="LEFT"/>arctan2_(other: Tensor): Tensor<br ALIGN="LEFT"/>arctan_(): Tensor<br ALIGN="LEFT"/>arctanh(): Tensor<br ALIGN="LEFT"/>arctanh_(): Tensor<br ALIGN="LEFT"/>argmax(dim: Optional[_int], keepdim: _bool): Tensor<br ALIGN="LEFT"/>argmin(dim: Optional[_int], keepdim: _bool): Tensor<br ALIGN="LEFT"/>argsort(): Tensor<br ALIGN="LEFT"/>argwhere(): Tensor<br ALIGN="LEFT"/>as_strided(size: Sequence[Union[_int, SymInt]], stride: Sequence[Union[_int, SymInt]], storage_offset: Optional[Union[_int, SymInt]]): Tensor<br ALIGN="LEFT"/>as_strided_(size: Sequence[Union[_int, SymInt]], stride: Sequence[Union[_int, SymInt]], storage_offset: Optional[Union[_int, SymInt]]): Tensor<br ALIGN="LEFT"/>as_strided_scatter(src: Tensor, size: Sequence[Union[_int, SymInt]], stride: Sequence[Union[_int, SymInt]], storage_offset: Optional[Union[_int, SymInt]]): Tensor<br ALIGN="LEFT"/>as_subclass(cls: _Type[S]): S<br ALIGN="LEFT"/>asin(): Tensor<br ALIGN="LEFT"/>asin_(): Tensor<br ALIGN="LEFT"/>asinh(): Tensor<br ALIGN="LEFT"/>asinh_(): Tensor<br ALIGN="LEFT"/>atan(): Tensor<br ALIGN="LEFT"/>atan2(other: Tensor): Tensor<br ALIGN="LEFT"/>atan2_(other: Tensor): Tensor<br ALIGN="LEFT"/>atan_(): Tensor<br ALIGN="LEFT"/>atanh(): Tensor<br ALIGN="LEFT"/>atanh_(): Tensor<br ALIGN="LEFT"/>baddbmm(batch1: Tensor, batch2: Tensor): Tensor<br ALIGN="LEFT"/>baddbmm_(batch1: Tensor, batch2: Tensor): Tensor<br ALIGN="LEFT"/>bernoulli(): Tensor<br ALIGN="LEFT"/>bernoulli_(p: Tensor): Tensor<br ALIGN="LEFT"/>bfloat16(): Tensor<br ALIGN="LEFT"/>bincount(weights: Optional[Tensor], minlength: _int): Tensor<br ALIGN="LEFT"/>bitwise_and(other: Tensor): Tensor<br ALIGN="LEFT"/>bitwise_and_(other: Tensor): Tensor<br ALIGN="LEFT"/>bitwise_left_shift(other: Tensor): Tensor<br ALIGN="LEFT"/>bitwise_left_shift_(other: Tensor): Tensor<br ALIGN="LEFT"/>bitwise_not(): Tensor<br ALIGN="LEFT"/>bitwise_not_(): Tensor<br ALIGN="LEFT"/>bitwise_or(other: Tensor): Tensor<br ALIGN="LEFT"/>bitwise_or_(other: Tensor): Tensor<br ALIGN="LEFT"/>bitwise_right_shift(other: Tensor): Tensor<br ALIGN="LEFT"/>bitwise_right_shift_(other: Tensor): Tensor<br ALIGN="LEFT"/>bitwise_xor(other: Tensor): Tensor<br ALIGN="LEFT"/>bitwise_xor_(other: Tensor): Tensor<br ALIGN="LEFT"/>bmm(mat2: Tensor): Tensor<br ALIGN="LEFT"/>bool(): Tensor<br ALIGN="LEFT"/>broadcast_to(size: Sequence[Union[_int, SymInt]]): Tensor<br ALIGN="LEFT"/>byte(): Tensor<br ALIGN="LEFT"/>cauchy_(median: _float, sigma: _float): Tensor<br ALIGN="LEFT"/>ccol_indices(): Tensor<br ALIGN="LEFT"/>ceil(): Tensor<br ALIGN="LEFT"/>ceil_(): Tensor<br ALIGN="LEFT"/>chalf(): Tensor<br ALIGN="LEFT"/>char(): Tensor<br ALIGN="LEFT"/>cholesky(upper: _bool): Tensor<br ALIGN="LEFT"/>cholesky_inverse(upper: _bool): Tensor<br ALIGN="LEFT"/>cholesky_solve(input2: Tensor, upper: _bool): Tensor<br ALIGN="LEFT"/>chunk(chunks: _int, dim: _int): tuple[Tensor, ...]<br ALIGN="LEFT"/>clamp(min: Optional[Tensor], max: Optional[Tensor]): Tensor<br ALIGN="LEFT"/>clamp_(min: Optional[Tensor], max: Optional[Tensor]): Tensor<br ALIGN="LEFT"/>clamp_max(max: Tensor): Tensor<br ALIGN="LEFT"/>clamp_max_(max: Tensor): Tensor<br ALIGN="LEFT"/>clamp_min(min: Tensor): Tensor<br ALIGN="LEFT"/>clamp_min_(min: Tensor): Tensor<br ALIGN="LEFT"/>clip(min: Optional[Tensor], max: Optional[Tensor]): Tensor<br ALIGN="LEFT"/>clip_(min: Optional[Tensor], max: Optional[Tensor]): Tensor<br ALIGN="LEFT"/>clone(): Tensor<br ALIGN="LEFT"/>coalesce(): Tensor<br ALIGN="LEFT"/>col_indices(): Tensor<br ALIGN="LEFT"/>conj(): Tensor<br ALIGN="LEFT"/>conj_physical(): Tensor<br ALIGN="LEFT"/>conj_physical_(): Tensor<br ALIGN="LEFT"/>contiguous(memory_format): Tensor<br ALIGN="LEFT"/>copy_(src: Tensor, non_blocking: _bool): Tensor<br ALIGN="LEFT"/>copysign(other: Tensor): Tensor<br ALIGN="LEFT"/>copysign_(other: Tensor): Tensor<br ALIGN="LEFT"/>corrcoef(): Tensor<br ALIGN="LEFT"/>cos(): Tensor<br ALIGN="LEFT"/>cos_(): Tensor<br ALIGN="LEFT"/>cosh(): Tensor<br ALIGN="LEFT"/>cosh_(): Tensor<br ALIGN="LEFT"/>count_nonzero(dim: Optional[_int]): Tensor<br ALIGN="LEFT"/>cov(): Tensor<br ALIGN="LEFT"/>cpu(memory_format: torch.memory_format): Tensor<br ALIGN="LEFT"/>cross(other: Tensor, dim: Optional[_int]): Tensor<br ALIGN="LEFT"/>crow_indices(): Tensor<br ALIGN="LEFT"/>cuda(device: Optional[Union[_device, _int, str]], non_blocking: _bool, memory_format: torch.memory_format): Tensor<br ALIGN="LEFT"/>cummax(dim: _int): torch.return_types.cummax<br ALIGN="LEFT"/>cummin(dim: _int): torch.return_types.cummin<br ALIGN="LEFT"/>cumprod(dim: _int): Tensor<br ALIGN="LEFT"/>cumprod_(dim: _int): Tensor<br ALIGN="LEFT"/>cumsum(dim: _int): Tensor<br ALIGN="LEFT"/>cumsum_(dim: _int): Tensor<br ALIGN="LEFT"/>data_ptr(): _int<br ALIGN="LEFT"/>deg2rad(): Tensor<br ALIGN="LEFT"/>deg2rad_(): Tensor<br ALIGN="LEFT"/>dense_dim(): _int<br ALIGN="LEFT"/>dequantize(): Tensor<br ALIGN="LEFT"/>det(): Tensor<br ALIGN="LEFT"/>detach(): Tensor<br ALIGN="LEFT"/>detach_(): Tensor<br ALIGN="LEFT"/>diag(diagonal: _int): Tensor<br ALIGN="LEFT"/>diag_embed(offset: _int, dim1: _int, dim2: _int): Tensor<br ALIGN="LEFT"/>diagflat(offset: _int): Tensor<br ALIGN="LEFT"/>diagonal(): Tensor<br ALIGN="LEFT"/>diagonal_scatter(src: Tensor, offset: _int, dim1: _int, dim2: _int): Tensor<br ALIGN="LEFT"/>diff(n: _int, dim: _int, prepend: Optional[Tensor], append: Optional[Tensor]): Tensor<br ALIGN="LEFT"/>digamma(): Tensor<br ALIGN="LEFT"/>digamma_(): Tensor<br ALIGN="LEFT"/>dim(): _int<br ALIGN="LEFT"/>dist(other: Tensor, p: Union[Number, _complex]): Tensor<br ALIGN="LEFT"/>div(other: Union[Tensor, Number]): Tensor<br ALIGN="LEFT"/>div_(other: Union[Tensor, Number]): Tensor<br ALIGN="LEFT"/>divide(other: Tensor): Tensor<br ALIGN="LEFT"/>divide_(other: Tensor): Tensor<br ALIGN="LEFT"/>dot(tensor: Tensor): Tensor<br ALIGN="LEFT"/>double(): Tensor<br ALIGN="LEFT"/>dsplit(sections: _int): tuple[Tensor, ...]<br ALIGN="LEFT"/>element_size(): _int<br ALIGN="LEFT"/>eq(other: Tensor): Tensor<br ALIGN="LEFT"/>eq_(other: Tensor): Tensor<br ALIGN="LEFT"/>equal(other: Tensor): _bool<br ALIGN="LEFT"/>erf(): Tensor<br ALIGN="LEFT"/>erf_(): Tensor<br ALIGN="LEFT"/>erfc(): Tensor<br ALIGN="LEFT"/>erfc_(): Tensor<br ALIGN="LEFT"/>erfinv(): Tensor<br ALIGN="LEFT"/>erfinv_(): Tensor<br ALIGN="LEFT"/>exp(): Tensor<br ALIGN="LEFT"/>exp2(): Tensor<br ALIGN="LEFT"/>exp2_(): Tensor<br ALIGN="LEFT"/>exp_(): Tensor<br ALIGN="LEFT"/>expand(size: Sequence[Union[_int, SymInt]]): Tensor<br ALIGN="LEFT"/>expand_as(other: Tensor): Tensor<br ALIGN="LEFT"/>expm1(): Tensor<br ALIGN="LEFT"/>expm1_(): Tensor<br ALIGN="LEFT"/>exponential_(lambd: _float): Tensor<br ALIGN="LEFT"/>fill_(value: Tensor): Tensor<br ALIGN="LEFT"/>fill_diagonal_(fill_value: Union[Number, _complex], wrap: _bool): Tensor<br ALIGN="LEFT"/>fix(): Tensor<br ALIGN="LEFT"/>fix_(): Tensor<br ALIGN="LEFT"/>flatten(start_dim: _int, end_dim: _int): Tensor<br ALIGN="LEFT"/>flip(dims: _size): Tensor<br ALIGN="LEFT"/>fliplr(): Tensor<br ALIGN="LEFT"/>flipud(): Tensor<br ALIGN="LEFT"/>float(): Tensor<br ALIGN="LEFT"/>float_power(exponent: Tensor): Tensor<br ALIGN="LEFT"/>float_power_(exponent: Tensor): Tensor<br ALIGN="LEFT"/>floor(): Tensor<br ALIGN="LEFT"/>floor_(): Tensor<br ALIGN="LEFT"/>floor_divide(other: Union[Tensor, Number, torch.SymInt, torch.SymFloat]): Tensor<br ALIGN="LEFT"/>floor_divide_(other: Union[Tensor, Number, torch.SymInt, torch.SymFloat]): Tensor<br ALIGN="LEFT"/>fmax(other: Tensor): Tensor<br ALIGN="LEFT"/>fmin(other: Tensor): Tensor<br ALIGN="LEFT"/>fmod(other: Tensor): Tensor<br ALIGN="LEFT"/>fmod_(other: Tensor): Tensor<br ALIGN="LEFT"/>frac(): Tensor<br ALIGN="LEFT"/>frac_(): Tensor<br ALIGN="LEFT"/>frexp(): torch.return_types.frexp<br ALIGN="LEFT"/>gather(dim: _int, index: Tensor): Tensor<br ALIGN="LEFT"/>gcd(other: Tensor): Tensor<br ALIGN="LEFT"/>gcd_(other: Tensor): Tensor<br ALIGN="LEFT"/>ge(other: Tensor): Tensor<br ALIGN="LEFT"/>ge_(other: Tensor): Tensor<br ALIGN="LEFT"/>geometric_(p: _float): Tensor<br ALIGN="LEFT"/>geqrf(): torch.return_types.geqrf<br ALIGN="LEFT"/>ger(vec2: Tensor): Tensor<br ALIGN="LEFT"/>get_device(): _int<br ALIGN="LEFT"/>greater(other: Tensor): Tensor<br ALIGN="LEFT"/>greater_(other: Tensor): Tensor<br ALIGN="LEFT"/>greater_equal(other: Tensor): Tensor<br ALIGN="LEFT"/>greater_equal_(other: Tensor): Tensor<br ALIGN="LEFT"/>gt(other: Tensor): Tensor<br ALIGN="LEFT"/>gt_(other: Tensor): Tensor<br ALIGN="LEFT"/>half(): Tensor<br ALIGN="LEFT"/>hardshrink(lambd: Union[Number, _complex]): Tensor<br ALIGN="LEFT"/>has_names(): _bool<br ALIGN="LEFT"/>heaviside(values: Tensor): Tensor<br ALIGN="LEFT"/>heaviside_(values: Tensor): Tensor<br ALIGN="LEFT"/>histc(bins: _int, min: Union[Number, _complex], max: Union[Number, _complex]): Tensor<br ALIGN="LEFT"/>histogram(bins: Tensor): torch.return_types.histogram<br ALIGN="LEFT"/>hsplit(sections: _int): tuple[Tensor, ...]<br ALIGN="LEFT"/>hypot(other: Tensor): Tensor<br ALIGN="LEFT"/>hypot_(other: Tensor): Tensor<br ALIGN="LEFT"/>i0(): Tensor<br ALIGN="LEFT"/>i0_(): Tensor<br ALIGN="LEFT"/>igamma(other: Tensor): Tensor<br ALIGN="LEFT"/>igamma_(other: Tensor): Tensor<br ALIGN="LEFT"/>igammac(other: Tensor): Tensor<br ALIGN="LEFT"/>igammac_(other: Tensor): Tensor<br ALIGN="LEFT"/>index_add(dim: _int, index: Tensor, source: Tensor): Tensor<br ALIGN="LEFT"/>index_add_(dim: _int, index: Tensor, source: Tensor): Tensor<br ALIGN="LEFT"/>index_copy(dim: _int, index: Tensor, source: Tensor): Tensor<br ALIGN="LEFT"/>index_copy_(dim: _int, index: Tensor, source: Tensor): Tensor<br ALIGN="LEFT"/>index_fill(dim: _int, index: Tensor, value: Tensor): Tensor<br ALIGN="LEFT"/>index_fill_(dim: _int, index: Tensor, value: Tensor): Tensor<br ALIGN="LEFT"/>index_put(indices: Optional[Union[tuple[Tensor, ...], list[Tensor]]], values: Tensor, accumulate: _bool): Tensor<br ALIGN="LEFT"/>index_put_(indices: Optional[Union[tuple[Tensor, ...], list[Tensor]]], values: Tensor, accumulate: _bool): Tensor<br ALIGN="LEFT"/>index_reduce(dim: _int, index: Tensor, source: Tensor, reduce: str): Tensor<br ALIGN="LEFT"/>index_reduce_(dim: _int, index: Tensor, source: Tensor, reduce: str): Tensor<br ALIGN="LEFT"/>index_select(dim: _int, index: Tensor): Tensor<br ALIGN="LEFT"/>indices(): Tensor<br ALIGN="LEFT"/>inner(other: Tensor): Tensor<br ALIGN="LEFT"/>int(): Tensor<br ALIGN="LEFT"/>int_repr(): Tensor<br ALIGN="LEFT"/>inverse(): Tensor<br ALIGN="LEFT"/>is_coalesced(): _bool<br ALIGN="LEFT"/>is_complex(): _bool<br ALIGN="LEFT"/>is_conj(): _bool<br ALIGN="LEFT"/>is_contiguous(memory_format): _bool<br ALIGN="LEFT"/>is_distributed(): _bool<br ALIGN="LEFT"/>is_floating_point(): _bool<br ALIGN="LEFT"/>is_inference(): _bool<br ALIGN="LEFT"/>is_neg(): _bool<br ALIGN="LEFT"/>is_nonzero(): _bool<br ALIGN="LEFT"/>is_pinned(device: Optional[Optional[DeviceLikeType]]): _bool<br ALIGN="LEFT"/>is_same_size(other: Tensor): _bool<br ALIGN="LEFT"/>is_set_to(tensor: Tensor): _bool<br ALIGN="LEFT"/>is_signed(): _bool<br ALIGN="LEFT"/>isclose(other: Tensor, rtol: _float, atol: _float, equal_nan: _bool): Tensor<br ALIGN="LEFT"/>isfinite(): Tensor<br ALIGN="LEFT"/>isinf(): Tensor<br ALIGN="LEFT"/>isnan(): Tensor<br ALIGN="LEFT"/>isneginf(): Tensor<br ALIGN="LEFT"/>isposinf(): Tensor<br ALIGN="LEFT"/>isreal(): Tensor<br ALIGN="LEFT"/>istft(n_fft: _int, hop_length: Optional[_int], win_length: Optional[_int], window: Optional[Tensor], center: _bool, normalized: _bool, onesided: Optional[_bool], length: Optional[_int], return_complex: _bool): Tensor<br ALIGN="LEFT"/>item(): Number<br ALIGN="LEFT"/>kron(other: Tensor): Tensor<br ALIGN="LEFT"/>kthvalue(k: _int, dim: _int, keepdim: _bool): torch.return_types.kthvalue<br ALIGN="LEFT"/>lcm(other: Tensor): Tensor<br ALIGN="LEFT"/>lcm_(other: Tensor): Tensor<br ALIGN="LEFT"/>ldexp(other: Tensor): Tensor<br ALIGN="LEFT"/>ldexp_(other: Tensor): Tensor<br ALIGN="LEFT"/>le(other: Tensor): Tensor<br ALIGN="LEFT"/>le_(other: Tensor): Tensor<br ALIGN="LEFT"/>lerp(end: Tensor, weight: Tensor): Tensor<br ALIGN="LEFT"/>lerp_(end: Tensor, weight: Tensor): Tensor<br ALIGN="LEFT"/>less(other: Tensor): Tensor<br ALIGN="LEFT"/>less_(other: Tensor): Tensor<br ALIGN="LEFT"/>less_equal(other: Tensor): Tensor<br ALIGN="LEFT"/>less_equal_(other: Tensor): Tensor<br ALIGN="LEFT"/>lgamma(): Tensor<br ALIGN="LEFT"/>lgamma_(): Tensor<br ALIGN="LEFT"/>log(): Tensor<br ALIGN="LEFT"/>log10(): Tensor<br ALIGN="LEFT"/>log10_(): Tensor<br ALIGN="LEFT"/>log1p(): Tensor<br ALIGN="LEFT"/>log1p_(): Tensor<br ALIGN="LEFT"/>log2(): Tensor<br ALIGN="LEFT"/>log2_(): Tensor<br ALIGN="LEFT"/>log_(): Tensor<br ALIGN="LEFT"/>log_normal_(mean: _float, std: _float): Tensor<br ALIGN="LEFT"/>log_softmax(dim: _int, dtype: Optional[_dtype]): Tensor<br ALIGN="LEFT"/>logaddexp(other: Tensor): Tensor<br ALIGN="LEFT"/>logaddexp2(other: Tensor): Tensor<br ALIGN="LEFT"/>logcumsumexp(dim: _int): Tensor<br ALIGN="LEFT"/>logdet(): Tensor<br ALIGN="LEFT"/>logical_and(other: Tensor): Tensor<br ALIGN="LEFT"/>logical_and_(other: Tensor): Tensor<br ALIGN="LEFT"/>logical_not(): Tensor<br ALIGN="LEFT"/>logical_not_(): Tensor<br ALIGN="LEFT"/>logical_or(other: Tensor): Tensor<br ALIGN="LEFT"/>logical_or_(other: Tensor): Tensor<br ALIGN="LEFT"/>logical_xor(other: Tensor): Tensor<br ALIGN="LEFT"/>logical_xor_(other: Tensor): Tensor<br ALIGN="LEFT"/>logit(eps: Optional[_float]): Tensor<br ALIGN="LEFT"/>logit_(eps: Optional[_float]): Tensor<br ALIGN="LEFT"/>logsumexp(dim: Union[_int, _size], keepdim: _bool): Tensor<br ALIGN="LEFT"/>long(): Tensor<br ALIGN="LEFT"/>lt(other: Tensor): Tensor<br ALIGN="LEFT"/>lt_(other: Tensor): Tensor<br ALIGN="LEFT"/>lu_solve(LU_data: Tensor, LU_pivots: Tensor): Tensor<br ALIGN="LEFT"/>map2_(x: Tensor, y: Tensor, callable: Callable): Tensor<br ALIGN="LEFT"/>map_(tensor: Tensor, callable: Callable): Tensor<br ALIGN="LEFT"/>masked_fill(mask: Tensor, value: Tensor): Tensor<br ALIGN="LEFT"/>masked_fill_(mask: Tensor, value: Tensor): Tensor<br ALIGN="LEFT"/>masked_scatter(mask: Tensor, source: Tensor): Tensor<br ALIGN="LEFT"/>masked_scatter_(mask: Tensor, source: Tensor): Tensor<br ALIGN="LEFT"/>masked_select(mask: Tensor): Tensor<br ALIGN="LEFT"/>matmul(other: Tensor): Tensor<br ALIGN="LEFT"/>matrix_exp(): Tensor<br ALIGN="LEFT"/>matrix_power(n: _int): Tensor<br ALIGN="LEFT"/>max(): Tensor<br ALIGN="LEFT"/>maximum(other: Tensor): Tensor<br ALIGN="LEFT"/>mean(): Tensor<br ALIGN="LEFT"/>median(): Tensor<br ALIGN="LEFT"/>min(): Tensor<br ALIGN="LEFT"/>minimum(other: Tensor): Tensor<br ALIGN="LEFT"/>mm(mat2: Tensor): Tensor<br ALIGN="LEFT"/>mode(dim: _int, keepdim: _bool): torch.return_types.mode<br ALIGN="LEFT"/>moveaxis(source: _int, destination: _int): Tensor<br ALIGN="LEFT"/>movedim(source: _int, destination: _int): Tensor<br ALIGN="LEFT"/>msort(): Tensor<br ALIGN="LEFT"/>mul(other: Union[Tensor, Number, _complex, torch.SymInt, torch.SymFloat]): Tensor<br ALIGN="LEFT"/>mul_(other: Union[Tensor, Number, _complex, torch.SymInt, torch.SymFloat]): Tensor<br ALIGN="LEFT"/>multinomial(num_samples: _int, replacement: _bool): Tensor<br ALIGN="LEFT"/>multiply(other: Tensor): Tensor<br ALIGN="LEFT"/>multiply_(other: Tensor): Tensor<br ALIGN="LEFT"/>mv(vec: Tensor): Tensor<br ALIGN="LEFT"/>mvlgamma(p: _int): Tensor<br ALIGN="LEFT"/>mvlgamma_(p: _int): Tensor<br ALIGN="LEFT"/>nan_to_num(nan: Optional[_float], posinf: Optional[_float], neginf: Optional[_float]): Tensor<br ALIGN="LEFT"/>nan_to_num_(nan: Optional[_float], posinf: Optional[_float], neginf: Optional[_float]): Tensor<br ALIGN="LEFT"/>nanmean(dim: Optional[Union[_int, _size]], keepdim: _bool): Tensor<br ALIGN="LEFT"/>nanmedian(): Tensor<br ALIGN="LEFT"/>nanquantile(q: Tensor, dim: Optional[_int], keepdim: _bool): Tensor<br ALIGN="LEFT"/>nansum(dim: Optional[Union[_int, _size]], keepdim: _bool): Tensor<br ALIGN="LEFT"/>narrow(dim: _int, start: Tensor, length: Union[_int, SymInt]): Tensor<br ALIGN="LEFT"/>narrow_copy(dim: _int, start: Union[_int, SymInt], length: Union[_int, SymInt]): Tensor<br ALIGN="LEFT"/>ndimension(): _int<br ALIGN="LEFT"/>ne(other: Tensor): Tensor<br ALIGN="LEFT"/>ne_(other: Tensor): Tensor<br ALIGN="LEFT"/>neg(): Tensor<br ALIGN="LEFT"/>neg_(): Tensor<br ALIGN="LEFT"/>negative(): Tensor<br ALIGN="LEFT"/>negative_(): Tensor<br ALIGN="LEFT"/>nelement(): _int<br ALIGN="LEFT"/>new(): Self<br ALIGN="LEFT"/>new_empty(size: Sequence[Union[_int, SymInt]]): Tensor<br ALIGN="LEFT"/>new_empty_strided(size: Sequence[Union[_int, SymInt]], stride: Sequence[Union[_int, SymInt]]): Tensor<br ALIGN="LEFT"/>new_full(size: Sequence[Union[_int, SymInt]], fill_value: Union[Number, _complex]): Tensor<br ALIGN="LEFT"/>new_ones(size: _size, dtype: Optional[_dtype], device: Optional[DeviceLikeType], requires_grad: _bool, pin_memory: _bool): Tensor<br ALIGN="LEFT"/>new_tensor(data: Any, dtype: Optional[_dtype], device: Optional[DeviceLikeType], requires_grad: _bool, pin_memory: _bool): Tensor<br ALIGN="LEFT"/>new_zeros(size: Sequence[Union[_int, SymInt]]): Tensor<br ALIGN="LEFT"/>nextafter(other: Tensor): Tensor<br ALIGN="LEFT"/>nextafter_(other: Tensor): Tensor<br ALIGN="LEFT"/>nonzero(): Tensor<br ALIGN="LEFT"/>nonzero_static(): Tensor<br ALIGN="LEFT"/>normal_(mean: _float, std: _float): Tensor<br ALIGN="LEFT"/>not_equal(other: Tensor): Tensor<br ALIGN="LEFT"/>not_equal_(other: Tensor): Tensor<br ALIGN="LEFT"/>numel(): _int<br ALIGN="LEFT"/>numpy(): numpy.ndarray<br ALIGN="LEFT"/>orgqr(input2: Tensor): Tensor<br ALIGN="LEFT"/>ormqr(input2: Tensor, input3: Tensor, left: _bool, transpose: _bool): Tensor<br ALIGN="LEFT"/>outer(vec2: Tensor): Tensor<br ALIGN="LEFT"/>permute(dims: _size): Tensor<br ALIGN="LEFT"/>pin_memory(device: Optional[Optional[DeviceLikeType]]): Tensor<br ALIGN="LEFT"/>pinverse(rcond: _float): Tensor<br ALIGN="LEFT"/>polygamma(n: _int): Tensor<br ALIGN="LEFT"/>polygamma_(n: _int): Tensor<br ALIGN="LEFT"/>positive(): Tensor<br ALIGN="LEFT"/>pow(exponent: Tensor): Tensor<br ALIGN="LEFT"/>pow_(exponent: Tensor): Tensor<br ALIGN="LEFT"/>prelu(weight: Tensor): Tensor<br ALIGN="LEFT"/>prod(): Tensor<br ALIGN="LEFT"/>put(index: Tensor, source: Tensor, accumulate: _bool): Tensor<br ALIGN="LEFT"/>put_(index: Tensor, source: Tensor, accumulate: _bool): Tensor<br ALIGN="LEFT"/>q_per_channel_axis(): _int<br ALIGN="LEFT"/>q_per_channel_scales(): Tensor<br ALIGN="LEFT"/>q_per_channel_zero_points(): Tensor<br ALIGN="LEFT"/>q_scale(): _float<br ALIGN="LEFT"/>q_zero_point(): _int<br ALIGN="LEFT"/>qr(some: _bool): torch.return_types.qr<br ALIGN="LEFT"/>qscheme(): _qscheme<br ALIGN="LEFT"/>quantile(q: Tensor, dim: Optional[_int], keepdim: _bool): Tensor<br ALIGN="LEFT"/>rad2deg(): Tensor<br ALIGN="LEFT"/>rad2deg_(): Tensor<br ALIGN="LEFT"/>random_(): Tensor<br ALIGN="LEFT"/>ravel(): Tensor<br ALIGN="LEFT"/>reciprocal(): Tensor<br ALIGN="LEFT"/>reciprocal_(): Tensor<br ALIGN="LEFT"/>record_stream(s: Stream): None<br ALIGN="LEFT"/>refine_names(names: Sequence[Union[str, ellipsis, None]]): Tensor<br ALIGN="LEFT"/>relu(): Tensor<br ALIGN="LEFT"/>relu_(): Tensor<br ALIGN="LEFT"/>remainder(other: Tensor): Tensor<br ALIGN="LEFT"/>remainder_(other: Tensor): Tensor<br ALIGN="LEFT"/>rename(names: Optional[Sequence[Union[str, ellipsis, None]]]): Tensor<br ALIGN="LEFT"/>rename_(names: Optional[Sequence[Union[str, ellipsis, None]]]): Tensor<br ALIGN="LEFT"/>renorm(p: Union[Number, _complex], dim: _int, maxnorm: Union[Number, _complex]): Tensor<br ALIGN="LEFT"/>renorm_(p: Union[Number, _complex], dim: _int, maxnorm: Union[Number, _complex]): Tensor<br ALIGN="LEFT"/>repeat(repeats: Sequence[Union[_int, SymInt]]): Tensor<br ALIGN="LEFT"/>repeat_interleave(repeats: Tensor, dim: Optional[_int]): Tensor<br ALIGN="LEFT"/>requires_grad_(mode: _bool): Tensor<br ALIGN="LEFT"/>reshape(shape: Sequence[Union[_int, SymInt]]): Tensor<br ALIGN="LEFT"/>reshape_as(other: Tensor): Tensor<br ALIGN="LEFT"/>resize_(size: Sequence[Union[_int, SymInt]]): Tensor<br ALIGN="LEFT"/>resize_as_(the_template: Tensor): Tensor<br ALIGN="LEFT"/>resize_as_sparse_(the_template: Tensor): Tensor<br ALIGN="LEFT"/>resolve_conj(): Tensor<br ALIGN="LEFT"/>resolve_neg(): Tensor<br ALIGN="LEFT"/>retain_grad(): None<br ALIGN="LEFT"/>roll(shifts: Union[Union[_int, SymInt], Sequence[Union[_int, SymInt]]], dims: Union[_int, _size]): Tensor<br ALIGN="LEFT"/>rot90(k: _int, dims: _size): Tensor<br ALIGN="LEFT"/>round(): Tensor<br ALIGN="LEFT"/>round_(): Tensor<br ALIGN="LEFT"/>row_indices(): Tensor<br ALIGN="LEFT"/>rsqrt(): Tensor<br ALIGN="LEFT"/>rsqrt_(): Tensor<br ALIGN="LEFT"/>scatter(dim: _int, index: Tensor, src: Tensor): Tensor<br ALIGN="LEFT"/>scatter_(dim: _int, index: Tensor, src: Tensor): Tensor<br ALIGN="LEFT"/>scatter_add(dim: _int, index: Tensor, src: Tensor): Tensor<br ALIGN="LEFT"/>scatter_add_(dim: _int, index: Tensor, src: Tensor): Tensor<br ALIGN="LEFT"/>scatter_reduce(dim: _int, index: Tensor, src: Tensor, reduce: str): Tensor<br ALIGN="LEFT"/>scatter_reduce_(dim: _int, index: Tensor, src: Tensor, reduce: str): Tensor<br ALIGN="LEFT"/>select(dim: _int, index: Union[_int, SymInt]): Tensor<br ALIGN="LEFT"/>select_scatter(src: Tensor, dim: _int, index: Union[_int, SymInt]): Tensor<br ALIGN="LEFT"/>set_(storage: Union[Storage, TypedStorage, UntypedStorage], offset: IntLikeType, size: _symsize, stride: _symsize): Tensor<br ALIGN="LEFT"/>sgn(): Tensor<br ALIGN="LEFT"/>sgn_(): Tensor<br ALIGN="LEFT"/>short(): Tensor<br ALIGN="LEFT"/>sigmoid(): Tensor<br ALIGN="LEFT"/>sigmoid_(): Tensor<br ALIGN="LEFT"/>sign(): Tensor<br ALIGN="LEFT"/>sign_(): Tensor<br ALIGN="LEFT"/>signbit(): Tensor<br ALIGN="LEFT"/>sin(): Tensor<br ALIGN="LEFT"/>sin_(): Tensor<br ALIGN="LEFT"/>sinc(): Tensor<br ALIGN="LEFT"/>sinc_(): Tensor<br ALIGN="LEFT"/>sinh(): Tensor<br ALIGN="LEFT"/>sinh_(): Tensor<br ALIGN="LEFT"/>size(dim: None): Size<br ALIGN="LEFT"/>slice_inverse(src: Tensor, dim: _int, start: Optional[Union[_int, SymInt]], end: Optional[Union[_int, SymInt]], step: Union[_int, SymInt]): Tensor<br ALIGN="LEFT"/>slice_scatter(src: Tensor, dim: _int, start: Optional[Union[_int, SymInt]], end: Optional[Union[_int, SymInt]], step: Union[_int, SymInt]): Tensor<br ALIGN="LEFT"/>slogdet(): torch.return_types.slogdet<br ALIGN="LEFT"/>smm(mat2: Tensor): Tensor<br ALIGN="LEFT"/>softmax(dim: _int, dtype: Optional[_dtype]): Tensor<br ALIGN="LEFT"/>sort(): torch.return_types.sort<br ALIGN="LEFT"/>sparse_dim(): _int<br ALIGN="LEFT"/>sparse_mask(mask: Tensor): Tensor<br ALIGN="LEFT"/>sparse_resize_(size: _size, sparse_dim: _int, dense_dim: _int): Tensor<br ALIGN="LEFT"/>sparse_resize_and_clear_(size: _size, sparse_dim: _int, dense_dim: _int): Tensor<br ALIGN="LEFT"/>split(split_size: _int, dim: _int): Sequence[Tensor]<br ALIGN="LEFT"/>split_with_sizes(split_sizes: Sequence[Union[_int, SymInt]], dim: _int): tuple[Tensor, ...]<br ALIGN="LEFT"/>sqrt(): Tensor<br ALIGN="LEFT"/>sqrt_(): Tensor<br ALIGN="LEFT"/>square(): Tensor<br ALIGN="LEFT"/>square_(): Tensor<br ALIGN="LEFT"/>squeeze(): Tensor<br ALIGN="LEFT"/>squeeze_(): Tensor<br ALIGN="LEFT"/>sspaddmm(mat1: Tensor, mat2: Tensor): Tensor<br ALIGN="LEFT"/>std(dim: Optional[Union[_int, _size]], unbiased: _bool, keepdim: _bool): Tensor<br ALIGN="LEFT"/>storage_offset(): Union[_int, SymInt]<br ALIGN="LEFT"/>storage_type(): Storage<br ALIGN="LEFT"/>stride(dim: None): tuple[_int, ...]<br ALIGN="LEFT"/>sub(other: Union[Tensor, Number, _complex, torch.SymInt, torch.SymFloat]): Tensor<br ALIGN="LEFT"/>sub_(other: Union[Tensor, Number, _complex, torch.SymInt, torch.SymFloat]): Tensor<br ALIGN="LEFT"/>subtract(other: Tensor): Tensor<br ALIGN="LEFT"/>subtract_(other: Tensor): Tensor<br ALIGN="LEFT"/>sum(): Tensor<br ALIGN="LEFT"/>sum_to_size(size: Sequence[Union[_int, SymInt]]): Tensor<br ALIGN="LEFT"/>svd(some: _bool, compute_uv: _bool): torch.return_types.svd<br ALIGN="LEFT"/>swapaxes(axis0: _int, axis1: _int): Tensor<br ALIGN="LEFT"/>swapaxes_(axis0: _int, axis1: _int): Tensor<br ALIGN="LEFT"/>swapdims(dim0: _int, dim1: _int): Tensor<br ALIGN="LEFT"/>swapdims_(dim0: _int, dim1: _int): Tensor<br ALIGN="LEFT"/>t(): Tensor<br ALIGN="LEFT"/>t_(): Tensor<br ALIGN="LEFT"/>take(index: Tensor): Tensor<br ALIGN="LEFT"/>take_along_dim(indices: Tensor, dim: Optional[_int]): Tensor<br ALIGN="LEFT"/>tan(): Tensor<br ALIGN="LEFT"/>tan_(): Tensor<br ALIGN="LEFT"/>tanh(): Tensor<br ALIGN="LEFT"/>tanh_(): Tensor<br ALIGN="LEFT"/>tensor_split(indices: Sequence[Union[_int, SymInt]], dim: _int): tuple[Tensor, ...]<br ALIGN="LEFT"/>tile(dims: Sequence[Union[_int, SymInt]]): Tensor<br ALIGN="LEFT"/>to(dtype: _dtype, non_blocking: _bool, copy: _bool): Tensor<br ALIGN="LEFT"/>to_dense(dtype: Optional[_dtype]): Tensor<br ALIGN="LEFT"/>to_mkldnn(dtype: Optional[_dtype]): Tensor<br ALIGN="LEFT"/>to_padded_tensor(padding: _float, output_size: Optional[Sequence[Union[_int, SymInt]]]): Tensor<br ALIGN="LEFT"/>to_sparse(): Tensor<br ALIGN="LEFT"/>to_sparse_bsc(blocksize: Union[_int, _size], dense_dim: Optional[_int]): Tensor<br ALIGN="LEFT"/>to_sparse_bsr(blocksize: Union[_int, _size], dense_dim: Optional[_int]): Tensor<br ALIGN="LEFT"/>to_sparse_csc(dense_dim: Optional[_int]): Tensor<br ALIGN="LEFT"/>to_sparse_csr(dense_dim: Optional[_int]): Tensor<br ALIGN="LEFT"/>tolist(): list<br ALIGN="LEFT"/>topk(k: Union[_int, SymInt], dim: _int, largest: _bool, sorted: _bool): torch.return_types.topk<br ALIGN="LEFT"/>trace(): Tensor<br ALIGN="LEFT"/>transpose(dim0: _int, dim1: _int): Tensor<br ALIGN="LEFT"/>transpose_(dim0: _int, dim1: _int): Tensor<br ALIGN="LEFT"/>triangular_solve(A: Tensor, upper: _bool, transpose: _bool, unitriangular: _bool): torch.return_types.triangular_solve<br ALIGN="LEFT"/>tril(diagonal: _int): Tensor<br ALIGN="LEFT"/>tril_(diagonal: _int): Tensor<br ALIGN="LEFT"/>triu(diagonal: _int): Tensor<br ALIGN="LEFT"/>triu_(diagonal: _int): Tensor<br ALIGN="LEFT"/>true_divide(other: Union[Tensor, Number, torch.SymInt, torch.SymFloat]): Tensor<br ALIGN="LEFT"/>true_divide_(other: Union[Tensor, Number, torch.SymInt, torch.SymFloat]): Tensor<br ALIGN="LEFT"/>trunc(): Tensor<br ALIGN="LEFT"/>trunc_(): Tensor<br ALIGN="LEFT"/>type(dtype: None, non_blocking: _bool): str<br ALIGN="LEFT"/>type_as(other: Tensor): Tensor<br ALIGN="LEFT"/>unbind(dim: _int): tuple[Tensor, ...]<br ALIGN="LEFT"/>unflatten(dim: Union[str, ellipsis, None], sizes: Sequence[Union[_int, SymInt]], names: Sequence[Union[str, ellipsis, None]]): Tensor<br ALIGN="LEFT"/>unfold(dimension: _int, size: _int, step: _int): Tensor<br ALIGN="LEFT"/>uniform_(from_: _float, to: _float): Tensor<br ALIGN="LEFT"/>unsafe_chunk(chunks: _int, dim: _int): tuple[Tensor, ...]<br ALIGN="LEFT"/>unsafe_split(split_size: Union[_int, SymInt], dim: _int): tuple[Tensor, ...]<br ALIGN="LEFT"/>unsafe_split_with_sizes(split_sizes: Sequence[Union[_int, SymInt]], dim: _int): tuple[Tensor, ...]<br ALIGN="LEFT"/>unsqueeze(dim: _int): Tensor<br ALIGN="LEFT"/>unsqueeze_(dim: _int): Tensor<br ALIGN="LEFT"/>untyped_storage(): UntypedStorage<br ALIGN="LEFT"/>values(): Tensor<br ALIGN="LEFT"/>var(dim: Optional[Union[_int, _size]], unbiased: _bool, keepdim: _bool): Tensor<br ALIGN="LEFT"/>vdot(other: Tensor): Tensor<br ALIGN="LEFT"/>view(dtype: _dtype): Tensor<br ALIGN="LEFT"/>view_as(other: Tensor): Tensor<br ALIGN="LEFT"/>vsplit(sections: _int): tuple[Tensor, ...]<br ALIGN="LEFT"/>where(condition: Tensor, other: Tensor): Tensor<br ALIGN="LEFT"/>xlogy(other: Tensor): Tensor<br ALIGN="LEFT"/>xlogy_(other: Tensor): Tensor<br ALIGN="LEFT"/>xpu(device: Optional[Union[_device, _int, str]], non_blocking: _bool, memory_format: torch.memory_format): Tensor<br ALIGN="LEFT"/>zero_(): Tensor<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"torch._C.device" [color="black", fontcolor="black", label=<{torch._C.device|index : int<br ALIGN="LEFT"/>type : str<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"torch._C.dtype" [color="black", fontcolor="black", label=<{torch._C.dtype|is_complex : bool<br ALIGN="LEFT"/>is_floating_point : bool<br ALIGN="LEFT"/>is_signed : bool<br ALIGN="LEFT"/>itemsize : int<br ALIGN="LEFT"/>|to_complex(): dtype<br ALIGN="LEFT"/>to_real(): dtype<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"torch._C.layout" [color="black", fontcolor="black", label=<{torch._C.layout|<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"torch._dynamo.eval_frame.OptimizedModule" [color="black", fontcolor="black", label=<{torch._dynamo.eval_frame.OptimizedModule|dynamo_ctx<br ALIGN="LEFT"/>forward<br ALIGN="LEFT"/>get_compiler_config : Callable[[], Any]<br ALIGN="LEFT"/>training<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"torch._tensor.Tensor" [color="black", fontcolor="black", label=<{torch._tensor.Tensor|data<br ALIGN="LEFT"/>detach : NoneType<br ALIGN="LEFT"/>detach_ : NoneType<br ALIGN="LEFT"/>requires_grad<br ALIGN="LEFT"/>|align_to()<br ALIGN="LEFT"/>backward(gradient, retain_graph, create_graph, inputs)<br ALIGN="LEFT"/>dim_order()<br ALIGN="LEFT"/>eig(eigenvectors)<br ALIGN="LEFT"/>is_shared()<br ALIGN="LEFT"/>istft(n_fft: int, hop_length: Optional[int], win_length: Optional[int], window: 'Optional[Tensor]', center: bool, normalized: bool, onesided: Optional[bool], length: Optional[int], return_complex: bool)<br ALIGN="LEFT"/>lstsq(other)<br ALIGN="LEFT"/>lu(pivot, get_infos)<br ALIGN="LEFT"/>module_load(other, assign)<br ALIGN="LEFT"/>norm(p: Optional[Union[float, str]], dim, keepdim, dtype)<br ALIGN="LEFT"/>refine_names()<br ALIGN="LEFT"/>register_hook(hook)<br ALIGN="LEFT"/>register_post_accumulate_grad_hook(hook)<br ALIGN="LEFT"/>reinforce(reward)<br ALIGN="LEFT"/>rename()<br ALIGN="LEFT"/>rename_()<br ALIGN="LEFT"/>resize()<br ALIGN="LEFT"/>resize_as(tensor)<br ALIGN="LEFT"/>share_memory_()<br ALIGN="LEFT"/>solve(other)<br ALIGN="LEFT"/>split(split_size, dim)<br ALIGN="LEFT"/>stft(n_fft: int, hop_length: Optional[int], win_length: Optional[int], window: 'Optional[Tensor]', center: bool, pad_mode: str, normalized: bool, onesided: Optional[bool], return_complex: Optional[bool])<br ALIGN="LEFT"/>storage()<br ALIGN="LEFT"/>storage_type()<br ALIGN="LEFT"/>symeig(eigenvectors)<br ALIGN="LEFT"/>to_sparse_coo()<br ALIGN="LEFT"/>unflatten(dim, sizes)<br ALIGN="LEFT"/>unique(sorted, return_inverse, return_counts, dim)<br ALIGN="LEFT"/>unique_consecutive(return_inverse, return_counts, dim)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"torch.nn.modules.container.ModuleDict" [color="black", fontcolor="black", label=<{torch.nn.modules.container.ModuleDict|<br ALIGN="LEFT"/>|clear(): None<br ALIGN="LEFT"/>items(): Iterable[Tuple[str, Module]]<br ALIGN="LEFT"/>keys(): Iterable[str]<br ALIGN="LEFT"/>pop(key: str): Module<br ALIGN="LEFT"/>update(modules: Mapping[str, Module]): None<br ALIGN="LEFT"/>values(): Iterable[Module]<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"torch.nn.modules.container.ModuleList" [color="black", fontcolor="black", label=<{torch.nn.modules.container.ModuleList|<br ALIGN="LEFT"/>|append(module: Module): 'ModuleList'<br ALIGN="LEFT"/>extend(modules: Iterable[Module]): Self<br ALIGN="LEFT"/>insert(index: int, module: Module): None<br ALIGN="LEFT"/>pop(key: Union[int, slice]): Module<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"torch.nn.modules.container.Sequential" [color="black", fontcolor="black", label=<{torch.nn.modules.container.Sequential|<br ALIGN="LEFT"/>|append(module: Module): 'Sequential'<br ALIGN="LEFT"/>extend(sequential): 'Sequential'<br ALIGN="LEFT"/>forward(input)<br ALIGN="LEFT"/>insert(index: int, module: Module): 'Sequential'<br ALIGN="LEFT"/>pop(key: Union[int, slice]): Module<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"torch.nn.modules.dropout.Dropout" [color="black", fontcolor="black", label=<{torch.nn.modules.dropout.Dropout|<br ALIGN="LEFT"/>|forward(input: Tensor): Tensor<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"torch.nn.modules.dropout._DropoutNd" [color="black", fontcolor="black", label=<{torch.nn.modules.dropout._DropoutNd|inplace : bool<br ALIGN="LEFT"/>p : float<br ALIGN="LEFT"/>|extra_repr(): str<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"torch.nn.modules.linear.Linear" [color="black", fontcolor="black", label=<{torch.nn.modules.linear.Linear|bias<br ALIGN="LEFT"/>in_features : int<br ALIGN="LEFT"/>out_features : int<br ALIGN="LEFT"/>weight<br ALIGN="LEFT"/>|extra_repr(): str<br ALIGN="LEFT"/>forward(input: Tensor): Tensor<br ALIGN="LEFT"/>reset_parameters(): None<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"torch.nn.modules.module.Module" [color="black", fontcolor="black", label=<{torch.nn.modules.module.Module|T_destination<br ALIGN="LEFT"/>call_super_init : bool<br ALIGN="LEFT"/>dump_patches : bool<br ALIGN="LEFT"/>forward : Callable[..., Any]<br ALIGN="LEFT"/>training : bool<br ALIGN="LEFT"/>|add_module(name: str, module: Optional['Module']): None<br ALIGN="LEFT"/>apply(fn: Callable[['Module'], None]): T<br ALIGN="LEFT"/>bfloat16(): T<br ALIGN="LEFT"/>buffers(recurse: bool): Iterator[Tensor]<br ALIGN="LEFT"/>children(): Iterator['Module']<br ALIGN="LEFT"/>compile()<br ALIGN="LEFT"/>cpu(): T<br ALIGN="LEFT"/>cuda(device: Optional[Union[int, device]]): T<br ALIGN="LEFT"/>double(): T<br ALIGN="LEFT"/>eval(): T<br ALIGN="LEFT"/>extra_repr(): str<br ALIGN="LEFT"/>float(): T<br ALIGN="LEFT"/>get_buffer(target: str): 'Tensor'<br ALIGN="LEFT"/>get_extra_state(): Any<br ALIGN="LEFT"/>get_parameter(target: str): 'Parameter'<br ALIGN="LEFT"/>get_submodule(target: str): 'Module'<br ALIGN="LEFT"/>half(): T<br ALIGN="LEFT"/>ipu(device: Optional[Union[int, device]]): T<br ALIGN="LEFT"/>load_state_dict(state_dict: Mapping[str, Any], strict: bool, assign: bool)<br ALIGN="LEFT"/>modules(): Iterator['Module']<br ALIGN="LEFT"/>mtia(device: Optional[Union[int, device]]): T<br ALIGN="LEFT"/>named_buffers(prefix: str, recurse: bool, remove_duplicate: bool): Iterator[Tuple[str, Tensor]]<br ALIGN="LEFT"/>named_children(): Iterator[Tuple[str, 'Module']]<br ALIGN="LEFT"/>named_modules(memo: Optional[Set['Module']], prefix: str, remove_duplicate: bool)<br ALIGN="LEFT"/>named_parameters(prefix: str, recurse: bool, remove_duplicate: bool): Iterator[Tuple[str, Parameter]]<br ALIGN="LEFT"/>parameters(recurse: bool): Iterator[Parameter]<br ALIGN="LEFT"/>register_backward_hook(hook: Callable[['Module', _grad_t, _grad_t], Union[None, _grad_t]]): RemovableHandle<br ALIGN="LEFT"/>register_buffer(name: str, tensor: Optional[Tensor], persistent: bool): None<br ALIGN="LEFT"/>register_forward_hook(hook: Union[Callable[[T, Tuple[Any, ...], Any], Optional[Any]], Callable[[T, Tuple[Any, ...], Dict[str, Any], Any], Optional[Any]]]): RemovableHandle<br ALIGN="LEFT"/>register_forward_pre_hook(hook: Union[Callable[[T, Tuple[Any, ...]], Optional[Any]], Callable[[T, Tuple[Any, ...], Dict[str, Any]], Optional[Tuple[Any, Dict[str, Any]]]]]): RemovableHandle<br ALIGN="LEFT"/>register_full_backward_hook(hook: Callable[['Module', _grad_t, _grad_t], Union[None, _grad_t]], prepend: bool): RemovableHandle<br ALIGN="LEFT"/>register_full_backward_pre_hook(hook: Callable[['Module', _grad_t], Union[None, _grad_t]], prepend: bool): RemovableHandle<br ALIGN="LEFT"/>register_load_state_dict_post_hook(hook)<br ALIGN="LEFT"/>register_load_state_dict_pre_hook(hook)<br ALIGN="LEFT"/>register_module(name: str, module: Optional['Module']): None<br ALIGN="LEFT"/>register_parameter(name: str, param: Optional[Parameter]): None<br ALIGN="LEFT"/>register_state_dict_post_hook(hook)<br ALIGN="LEFT"/>register_state_dict_pre_hook(hook)<br ALIGN="LEFT"/>requires_grad_(requires_grad: bool): T<br ALIGN="LEFT"/>set_extra_state(state: Any): None<br ALIGN="LEFT"/>set_submodule(target: str, module: 'Module'): None<br ALIGN="LEFT"/>share_memory(): T<br ALIGN="LEFT"/>state_dict(): T_destination<br ALIGN="LEFT"/>to(device: Optional[DeviceLikeType], dtype: Optional[dtype], non_blocking: bool): Self<br ALIGN="LEFT"/>to_empty(): T<br ALIGN="LEFT"/>train(mode: bool): T<br ALIGN="LEFT"/>type(dst_type: Union[dtype, str]): T<br ALIGN="LEFT"/>xpu(device: Optional[Union[int, device]]): T<br ALIGN="LEFT"/>zero_grad(set_to_none: bool): None<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"torch.nn.modules.normalization.LayerNorm" [color="black", fontcolor="black", label=<{torch.nn.modules.normalization.LayerNorm|bias<br ALIGN="LEFT"/>elementwise_affine : bool<br ALIGN="LEFT"/>eps : float<br ALIGN="LEFT"/>normalized_shape : Tuple[int, ...]<br ALIGN="LEFT"/>weight<br ALIGN="LEFT"/>|extra_repr(): str<br ALIGN="LEFT"/>forward(input: Tensor): Tensor<br ALIGN="LEFT"/>reset_parameters(): None<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"torch.nn.modules.rnn.GRU" [color="black", fontcolor="black", label=<{torch.nn.modules.rnn.GRU|<br ALIGN="LEFT"/>|<I>forward</I>(input: Tensor, hx: Optional[Tensor]): Tuple[Tensor, Tensor]<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"torch.nn.modules.rnn.RNNBase" [color="black", fontcolor="black", label=<{torch.nn.modules.rnn.RNNBase|all_weights<br ALIGN="LEFT"/>batch_first : bool<br ALIGN="LEFT"/>bias : bool<br ALIGN="LEFT"/>bidirectional : bool<br ALIGN="LEFT"/>dropout : float<br ALIGN="LEFT"/>hidden_size : int<br ALIGN="LEFT"/>input_size : int<br ALIGN="LEFT"/>mode : str<br ALIGN="LEFT"/>num_layers : int<br ALIGN="LEFT"/>proj_size : int<br ALIGN="LEFT"/>|check_forward_args(input: Tensor, hidden: Tensor, batch_sizes: Optional[Tensor])<br ALIGN="LEFT"/>check_hidden_size(hx: Tensor, expected_hidden_size: Tuple[int, int, int], msg: str): None<br ALIGN="LEFT"/>check_input(input: Tensor, batch_sizes: Optional[Tensor]): None<br ALIGN="LEFT"/>extra_repr(): str<br ALIGN="LEFT"/>flatten_parameters(): None<br ALIGN="LEFT"/>get_expected_hidden_size(input: Tensor, batch_sizes: Optional[Tensor]): Tuple[int, int, int]<br ALIGN="LEFT"/>permute_hidden(hx: Tensor, permutation: Optional[Tensor])<br ALIGN="LEFT"/>reset_parameters(): None<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"torch.nn.parameter.Parameter" [color="black", fontcolor="black", label=<{torch.nn.parameter.Parameter|data<br ALIGN="LEFT"/>grad<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"torch.optim.adam.Adam" [color="black", fontcolor="black", label=<{torch.optim.adam.Adam|<br ALIGN="LEFT"/>|step(closure)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"torch.optim.optimizer.Optimizer" [color="black", fontcolor="black", label=<{torch.optim.optimizer.Optimizer|OptimizerPostHook : TypeAlias<br ALIGN="LEFT"/>OptimizerPreHook : TypeAlias<br ALIGN="LEFT"/>defaults : Dict[str, Any]<br ALIGN="LEFT"/>param_groups : List[Dict[str, Any]]<br ALIGN="LEFT"/>state : DefaultDict[torch.Tensor, Any]<br ALIGN="LEFT"/>|add_param_group(param_group: Dict[str, Any]): None<br ALIGN="LEFT"/>load_state_dict(state_dict: StateDict): None<br ALIGN="LEFT"/>profile_hook_step(func: Callable[_P, R]): Callable[_P, R]<br ALIGN="LEFT"/>register_load_state_dict_post_hook(hook: Callable[['Optimizer'], None], prepend: bool): RemovableHandle<br ALIGN="LEFT"/>register_load_state_dict_pre_hook(hook: Callable[['Optimizer', StateDict], Optional[StateDict]], prepend: bool): RemovableHandle<br ALIGN="LEFT"/>register_state_dict_post_hook(hook: Callable[['Optimizer', StateDict], Optional[StateDict]], prepend: bool): RemovableHandle<br ALIGN="LEFT"/>register_state_dict_pre_hook(hook: Callable[['Optimizer'], None], prepend: bool): RemovableHandle<br ALIGN="LEFT"/>register_step_post_hook(hook: OptimizerPostHook): RemovableHandle<br ALIGN="LEFT"/>register_step_pre_hook(hook: OptimizerPreHook): RemovableHandle<br ALIGN="LEFT"/>state_dict(): StateDict<br ALIGN="LEFT"/>step(closure: None): None<br ALIGN="LEFT"/>zero_grad(set_to_none: bool): None<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"typing_extensions.Protocol" [color="black", fontcolor="black", label=<{typing_extensions.Protocol|<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"typing_extensions._ExtensionsSpecialForm" [color="black", fontcolor="black", label=<{typing_extensions._ExtensionsSpecialForm|<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"src.core.attention.compute.AttentionCompute" -> "torch.nn.modules.module.Module" [arrowhead="empty", arrowtail="none"];
"src.core.attention.geometric.EuclideanExponential" -> "torch.nn.modules.module.Module" [arrowhead="empty", arrowtail="none"];
"src.core.attention.geometric.EuclideanLogarithm" -> "torch.nn.modules.module.Module" [arrowhead="empty", arrowtail="none"];
"src.core.attention.geometric.GeometricStructures" -> "torch.nn.modules.module.Module" [arrowhead="empty", arrowtail="none"];
"src.core.attention.geometric.HyperbolicExponential" -> "torch.nn.modules.module.Module" [arrowhead="empty", arrowtail="none"];
"src.core.attention.geometric.HyperbolicLogarithm" -> "torch.nn.modules.module.Module" [arrowhead="empty", arrowtail="none"];
"src.core.attention.geometric.ParallelTransport" -> "torch.nn.modules.module.Module" [arrowhead="empty", arrowtail="none"];
"src.core.attention.routing.InformationRouter" -> "torch.nn.modules.module.Module" [arrowhead="empty", arrowtail="none"];
"src.core.flow.base.BaseGeometricFlow" -> "torch.nn.modules.module.Module" [arrowhead="empty", arrowtail="none"];
"src.core.flow.higher_order.HigherOrderFlow" -> "src.core.flow.pattern_heat.PatternHeatFlow" [arrowhead="empty", arrowtail="none"];
"src.core.flow.information_ricci.InformationRicciFlow" -> "src.core.flow.neural.NeuralGeometricFlow" [arrowhead="empty", arrowtail="none"];
"src.core.flow.neural.NeuralGeometricFlow" -> "src.core.flow.pattern.PatternFormationFlow" [arrowhead="empty", arrowtail="none"];
"src.core.flow.pattern.PatternFormationFlow" -> "src.core.flow.base.BaseGeometricFlow" [arrowhead="empty", arrowtail="none"];
"src.core.flow.pattern_heat.PatternHeatFlow" -> "src.core.flow.information_ricci.InformationRicciFlow" [arrowhead="empty", arrowtail="none"];
"src.core.flow.protocol.GeometricFlowProtocol" -> ".Protocol" [arrowhead="empty", arrowtail="none"];
"src.core.flow.protocol.QuantumFlowMetrics" -> "src.core.flow.protocol.FlowMetrics" [arrowhead="empty", arrowtail="none"];
"src.core.flow.protocol.RicciTensorNetwork" -> "torch.nn.modules.module.Module" [arrowhead="empty", arrowtail="none"];
"src.core.flow.quantum.QuantumGeometricFlow" -> "src.core.flow.base.BaseGeometricFlow" [arrowhead="empty", arrowtail="none"];
"src.core.models.base.LayerGeometry" -> "torch.nn.modules.module.Module" [arrowhead="empty", arrowtail="none"];
"src.core.models.base.LayerGeometryDict" -> "torch.nn.modules.container.ModuleDict" [arrowhead="empty", arrowtail="none"];
"src.core.models.base.ModelGeometry" -> "torch.nn.modules.module.Module" [arrowhead="empty", arrowtail="none"];
"src.core.patterns.base_flow.BaseGeometricFlow" -> "src.core.types.GeometricFlowProtocol" [arrowhead="empty", arrowtail="none"];
"src.core.patterns.base_flow.BaseGeometricFlow" -> "torch.nn.modules.module.Module" [arrowhead="empty", arrowtail="none"];
"src.core.patterns.enriched_structure.PatternTransition" -> "src.core.patterns.enriched_structure.EnrichedTransition" [arrowhead="empty", arrowtail="none"];
"src.core.patterns.fiber_bundle.BaseFiberBundle" -> "torch.nn.modules.module.Module" [arrowhead="empty", arrowtail="none"];
"src.core.patterns.fiber_types.FiberBundle" -> ".Protocol" [arrowhead="empty", arrowtail="none"];
"src.core.patterns.motivic_integration.MotivicIntegrationSystem" -> "torch.nn.modules.module.Module" [arrowhead="empty", arrowtail="none"];
"src.core.patterns.motivic_integration.MotivicRiemannianStructureImpl" -> "src.core.patterns.riemannian.PatternRiemannianStructure" [arrowhead="empty", arrowtail="none"];
"src.core.patterns.motivic_riemannian.MotivicRiemannianStructure" -> "src.core.patterns.fiber_bundle.BaseFiberBundle" [arrowhead="empty", arrowtail="none"];
"src.core.patterns.motivic_riemannian.MotivicRiemannianStructure" -> "src.core.patterns.riemannian_base.ValidationMixin" [arrowhead="empty", arrowtail="none"];
"src.core.patterns.motivic_riemannian.MotivicRiemannianStructure" -> "src.core.tiling.patterns.cohomology.RiemannianFiberBundle" [arrowhead="empty", arrowtail="none"];
"src.core.patterns.motivic_riemannian.MotivicRiemannianStructure" -> "torch.nn.modules.module.Module" [arrowhead="empty", arrowtail="none"];
"src.core.patterns.operadic_handler.OperadicStructureHandler" -> "torch.nn.modules.module.Module" [arrowhead="empty", arrowtail="none"];
"src.core.patterns.operadic_structure.AttentionOperad" -> "src.core.patterns.operadic_structure.OperadicComposition" [arrowhead="empty", arrowtail="none"];
"src.core.patterns.pattern_processor.PatternProcessor" -> "torch.nn.modules.module.Module" [arrowhead="empty", arrowtail="none"];
"src.core.patterns.riemannian.BaseRiemannianStructure" -> "src.core.patterns.riemannian_base.ValidationMixin" [arrowhead="empty", arrowtail="none"];
"src.core.patterns.riemannian.BaseRiemannianStructure" -> "torch.nn.modules.module.Module" [arrowhead="empty", arrowtail="none"];
"src.core.patterns.riemannian.PatternRiemannianStructure" -> "src.core.patterns.riemannian.BaseRiemannianStructure" [arrowhead="empty", arrowtail="none"];
"src.core.patterns.riemannian.RiemannianFramework" -> "typing_extensions.Protocol" [arrowhead="empty", arrowtail="none"];
"src.core.patterns.riemannian_base.RiemannianStructure" -> ".Protocol" [arrowhead="empty", arrowtail="none"];
"src.core.patterns.riemannian_base.RiemannianValidator" -> ".Protocol" [arrowhead="empty", arrowtail="none"];
"src.core.patterns.riemannian_flow.RiemannianFlow" -> "src.core.patterns.base_flow.BaseGeometricFlow" [arrowhead="empty", arrowtail="none"];
"src.core.patterns.symplectic.EnrichedOperator" -> "src.core.patterns.symplectic.WaveOperator" [arrowhead="empty", arrowtail="none"];
"src.core.performance.cpu_memory.CPUMemoryManager" -> "src.core.performance.memory_base.MemoryManagerBase" [arrowhead="empty", arrowtail="none"];
"src.core.performance.vulkan_memory.VulkanMemoryManager" -> "src.core.performance.memory_base.MemoryManagerBase" [arrowhead="empty", arrowtail="none"];
"src.core.quantum.neural_quantum_bridge.NeuralQuantumBridge" -> "torch.nn.modules.module.Module" [arrowhead="empty", arrowtail="none"];
"src.core.scale_transition.ScaleFlowIntegrator" -> "torch.nn.modules.module.Module" [arrowhead="empty", arrowtail="none"];
"src.core.scale_transition.ScaleTransitionLayer" -> "torch.nn.modules.module.Module" [arrowhead="empty", arrowtail="none"];
"src.core.tiling.arithmetic_dynamics.ArithmeticDynamics" -> "torch.nn.modules.module.Module" [arrowhead="empty", arrowtail="none"];
"src.core.tiling.arithmetic_dynamics.ArithmeticPattern" -> "torch.nn.modules.module.Module" [arrowhead="empty", arrowtail="none"];
"src.core.tiling.arithmetic_dynamics.ModularFormComputer" -> "torch.nn.modules.module.Module" [arrowhead="empty", arrowtail="none"];
"src.core.tiling.arithmetic_dynamics.MotivicIntegrator" -> "torch.nn.modules.module.Module" [arrowhead="empty", arrowtail="none"];
"src.core.tiling.geometric_flow.GeometricFlow" -> "src.core.patterns.riemannian_flow.RiemannianFlow" [arrowhead="empty", arrowtail="none"];
"src.core.tiling.patterns.cohomology.RiemannianFiberBundle" -> "torch.nn.modules.module.Module" [arrowhead="empty", arrowtail="none"];
"src.core.tiling.patterns.pattern_fiber_bundle.PatternFiberBundle" -> "src.core.patterns.fiber_bundle.BaseFiberBundle" [arrowhead="empty", arrowtail="none"];
"src.core.tiling.patterns.pattern_fiber_bundle.TensorStateManager" -> ".Protocol" [arrowhead="empty", arrowtail="none"];
"src.core.tiling.quantum_attention_tile.QuantumMotivicTile" -> "torch.nn.modules.module.Module" [arrowhead="empty", arrowtail="none"];
"src.core.tiling.quantum_geometric_attention.QuantumGeometricAttention" -> "torch.nn.modules.module.Module" [arrowhead="empty", arrowtail="none"];
"src.core.tiling.quantum_geometric_attention.QuantumGeometricTransformer" -> "torch.nn.modules.module.Module" [arrowhead="empty", arrowtail="none"];
"src.neural.attention.pattern.diffusion.DiffusionSystem" -> "torch.nn.modules.module.Module" [arrowhead="empty", arrowtail="none"];
"src.validation.base.BasicValidationResult" -> "src.validation.base.ValidationResult" [arrowhead="empty", arrowtail="none"];
"src.validation.framework.ConcreteValidationResult" -> "src.validation.base.ValidationResult" [arrowhead="empty", arrowtail="none"];
"src.validation.framework.FrameworkValidationResult" -> "src.validation.base.ValidationResult" [arrowhead="empty", arrowtail="none"];
"src.validation.quantum.state.QuantumStateValidationResult" -> "src.validation.base.ValidationResult" [arrowhead="empty", arrowtail="none"];
"torch._dynamo.eval_frame.OptimizedModule" -> "torch.nn.modules.module.Module" [arrowhead="empty", arrowtail="none"];
"torch._tensor.Tensor" -> "torch._C.TensorBase" [arrowhead="empty", arrowtail="none"];
"torch.nn.modules.container.ModuleDict" -> "torch.nn.modules.module.Module" [arrowhead="empty", arrowtail="none"];
"torch.nn.modules.container.ModuleList" -> "torch.nn.modules.module.Module" [arrowhead="empty", arrowtail="none"];
"torch.nn.modules.container.Sequential" -> "torch.nn.modules.module.Module" [arrowhead="empty", arrowtail="none"];
"torch.nn.modules.dropout.Dropout" -> "torch.nn.modules.dropout._DropoutNd" [arrowhead="empty", arrowtail="none"];
"torch.nn.modules.dropout._DropoutNd" -> "torch.nn.modules.module.Module" [arrowhead="empty", arrowtail="none"];
"torch.nn.modules.linear.Linear" -> "torch.nn.modules.module.Module" [arrowhead="empty", arrowtail="none"];
"torch.nn.modules.normalization.LayerNorm" -> "torch.nn.modules.module.Module" [arrowhead="empty", arrowtail="none"];
"torch.nn.modules.rnn.GRU" -> "torch.nn.modules.rnn.RNNBase" [arrowhead="empty", arrowtail="none"];
"torch.nn.modules.rnn.RNNBase" -> "torch.nn.modules.module.Module" [arrowhead="empty", arrowtail="none"];
"torch.nn.parameter.Parameter" -> "torch._tensor.Tensor" [arrowhead="empty", arrowtail="none"];
"torch.optim.adam.Adam" -> "torch.optim.optimizer.Optimizer" [arrowhead="empty", arrowtail="none"];
".StructureGroup" -> "src.core.patterns.fiber_types.FiberChart" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="structure_group", style="solid"];
".T" -> "src.core.patterns.fiber_types.FiberChart" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="fiber_coordinates", style="solid"];
".T" -> "src.core.patterns.fiber_types.LocalChart" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="coordinates", style="solid"];
".T" -> "src.core.patterns.riemannian_base.ChristoffelSymbols" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="values", style="solid"];
".T" -> "src.core.patterns.riemannian_base.CurvatureTensor" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="riemann", style="solid"];
".T" -> "src.core.patterns.riemannian_base.CurvatureTensor" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="ricci", style="solid"];
".T" -> "src.core.patterns.riemannian_base.CurvatureTensor" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="scalar_curvatures", style="solid"];
".T" -> "src.core.patterns.riemannian_base.MetricTensor" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="values", style="solid"];
".T_destination" -> "torch.nn.modules.module.Module" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="T_destination", style="solid"];
"line_profiler.line_profiler.LineProfiler" -> "src.core.performance.cpu_optimizer.CPUOptimizer" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="line_profiler", style="solid"];
"src.core.attention.geometric.EuclideanExponential" -> "src.core.tiling.quantum_geometric_attention.GeometricStructures" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="exp_map", style="solid"];
"src.core.attention.geometric.EuclideanExponential" -> "src.core.tiling.quantum_geometric_attention.QuantumGeometricAttention" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="exp_map", style="solid"];
"src.core.attention.geometric.EuclideanLogarithm" -> "src.core.tiling.quantum_geometric_attention.GeometricStructures" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="log_map", style="solid"];
"src.core.attention.geometric.EuclideanLogarithm" -> "src.core.tiling.quantum_geometric_attention.QuantumGeometricAttention" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="log_map", style="solid"];
"src.core.attention.geometric.HyperbolicExponential" -> "src.core.tiling.quantum_geometric_attention.GeometricStructures" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="exp_map", style="solid"];
"src.core.attention.geometric.HyperbolicExponential" -> "src.core.tiling.quantum_geometric_attention.QuantumGeometricAttention" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="exp_map", style="solid"];
"src.core.attention.geometric.HyperbolicLogarithm" -> "src.core.tiling.quantum_geometric_attention.GeometricStructures" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="log_map", style="solid"];
"src.core.attention.geometric.HyperbolicLogarithm" -> "src.core.tiling.quantum_geometric_attention.QuantumGeometricAttention" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="log_map", style="solid"];
"src.core.attention.geometric.ParallelTransport" -> "src.core.attention.geometric.GeometricStructures" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="transport", style="solid"];
"src.core.attention.geometric.ParallelTransport" -> "src.core.tiling.quantum_geometric_attention.GeometricStructures" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="transport", style="solid"];
"src.core.attention.geometric.ParallelTransport" -> "src.core.tiling.quantum_geometric_attention.QuantumGeometricAttention" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="transport", style="solid"];
"src.core.backends.base.AttentionBackend" -> "src.core.attention.base.BaseAttention" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="backend", style="solid"];
"src.core.crystal.scale.AnomalyDetector" -> "src.core.crystal.scale.ScaleCohomology" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="anomaly_det", style="solid"];
"src.core.crystal.scale.AnomalyDetector" -> "src.core.crystal.scale.ScaleSystem" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="anomaly", style="solid"];
"src.core.crystal.scale.RenormalizationFlow" -> "src.core.crystal.scale.ScaleCohomology" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="rg_flow", style="solid"];
"src.core.crystal.scale.RenormalizationFlow" -> "src.core.crystal.scale.ScaleSystem" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="rg_flow", style="solid"];
"src.core.crystal.scale.ScaleCohomology" -> "src.core.crystal.scale.ScaleSystem" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="cohomology", style="solid"];
"src.core.crystal.scale.ScaleConnection" -> "src.core.crystal.scale.ScaleCohomology" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="scale_conn", style="solid"];
"src.core.crystal.scale.ScaleConnection" -> "src.core.crystal.scale.ScaleSystem" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="connection", style="solid"];
"src.core.crystal.scale.ScaleInvariance" -> "src.core.crystal.scale.ScaleCohomology" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="scale_inv", style="solid"];
"src.core.crystal.scale.ScaleInvariance" -> "src.core.crystal.scale.ScaleSystem" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="invariance", style="solid"];
"src.core.crystal.scale.ScaleSystem" -> "src.core.quantum.neural_quantum_bridge.NeuralQuantumBridge" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="scale_system", style="solid"];
"src.core.crystal.scale.ScaleSystem" -> "src.core.scale_transition.ScaleTransitionLayer" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="scale_system", style="solid"];
"src.core.flow.pattern_heat.PatternHeatFlow" -> "src.core.patterns.pattern_processor.PatternProcessor" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="flow", style="solid"];
"src.core.metrics.evolution.ErgodicAnalysis" -> "src.core.metrics.evolution.EvolutionAnalyzer" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="ergodic", style="solid"];
"src.core.metrics.evolution.FlowEvolution" -> "src.core.metrics.evolution.EvolutionAnalyzer" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="flow", style="solid"];
"src.core.metrics.evolution.LFunctionComputation" -> "src.core.metrics.evolution.EvolutionAnalyzer" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="l_function", style="solid"];
"src.core.metrics.evolution.OrbitAnalysis" -> "src.core.metrics.evolution.EvolutionAnalyzer" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="orbit", style="solid"];
"src.core.metrics.height_theory.HeightStructure" -> "src.core.metrics.height_theory.AdaptiveHeightTheory" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="height_structure", style="solid"];
"src.core.models.base.LayerGeometryDict" -> "src.core.models.base.ModelGeometry" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="layers", style="solid"];
"src.core.patterns.dynamics.PatternDynamics" -> "src.core.flow.pattern.PatternFormationFlow" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="pattern_dynamics", style="solid"];
"src.core.patterns.dynamics.PatternDynamics" -> "src.core.patterns.pattern_processor.PatternProcessor" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="pattern_dynamics", style="solid"];
"src.core.patterns.dynamics.PatternDynamics" -> "src.core.tiling.patterns.pattern_fiber_bundle.PatternFiberBundle" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="pattern_dynamics", style="solid"];
"src.core.patterns.enriched_structure.PatternTransition" -> "src.core.flow.pattern.PatternFormationFlow" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="transition", style="solid"];
"src.core.patterns.enriched_structure.PatternTransition" -> "src.core.patterns.pattern_processor.PatternProcessor" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="transition", style="solid"];
"src.core.patterns.enriched_structure.PatternTransition" -> "src.core.tiling.patterns.pattern_fiber_bundle.PatternFiberBundle" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="transition", style="solid"];
"src.core.patterns.enriched_structure.WaveEmergence" -> "src.core.flow.pattern.PatternFormationFlow" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="wave", style="solid"];
"src.core.patterns.enriched_structure.WaveEmergence" -> "src.core.patterns.enriched_structure.PatternTransition" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="wave", style="solid"];
"src.core.patterns.enriched_structure.WaveEmergence" -> "src.core.patterns.pattern_processor.PatternProcessor" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="wave", style="solid"];
"src.core.patterns.enriched_structure.WaveEmergence" -> "src.core.tiling.patterns.pattern_fiber_bundle.PatternFiberBundle" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="wave", style="solid"];
"src.core.patterns.evolution.PatternEvolution" -> "src.core.flow.pattern.PatternFormationFlow" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="pattern_evolution", style="solid"];
"src.core.patterns.evolution.PatternEvolution" -> "src.core.patterns.pattern_processor.PatternProcessor" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="pattern_evolution", style="solid"];
"src.core.patterns.evolution.PatternEvolution" -> "src.core.tiling.patterns.pattern_fiber_bundle.PatternFiberBundle" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="pattern_evolution", style="solid"];
"src.core.patterns.fiber_types.FiberTypeManager" -> "src.core.tiling.patterns.pattern_fiber_bundle.PatternFiberBundle" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="fiber_type_manager", style="solid"];
"src.core.patterns.formation.PatternFormation" -> "src.core.flow.pattern.PatternFormationFlow" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="pattern_formation", style="solid"];
"src.core.patterns.formation.PatternFormation" -> "src.core.patterns.pattern_processor.PatternProcessor" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="pattern_formation", style="solid"];
"src.core.patterns.formation.PatternFormation" -> "src.core.tiling.patterns.pattern_fiber_bundle.PatternFiberBundle" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="pattern_formation", style="solid"];
"src.core.patterns.motivic_integration.MotivicIntegrationSystem" -> "src.core.patterns.operadic_handler.OperadicStructureHandler" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="motivic", style="solid"];
"src.core.patterns.motivic_integration.MotivicRiemannianStructureImpl" -> "src.core.patterns.motivic_integration.MotivicIntegrationSystem" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="geometry", style="solid"];
"src.core.patterns.motivic_integration.MotivicRiemannianStructureImpl" -> "src.core.patterns.pattern_processor.PatternProcessor" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="riemannian", style="solid"];
"src.core.patterns.operadic_structure.AttentionOperad" -> "src.core.flow.pattern.PatternFormationFlow" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="operadic", style="solid"];
"src.core.patterns.operadic_structure.AttentionOperad" -> "src.core.patterns.evolution.PatternEvolution" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="operadic", style="solid"];
"src.core.patterns.operadic_structure.AttentionOperad" -> "src.core.patterns.evolution.PatternEvolution" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="operadic", style="solid"];
"src.core.patterns.operadic_structure.AttentionOperad" -> "src.core.patterns.formation.BifurcationAnalyzer" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="operadic", style="solid"];
"src.core.patterns.operadic_structure.AttentionOperad" -> "src.core.patterns.formation.PatternFormation" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="operadic", style="solid"];
"src.core.patterns.operadic_structure.AttentionOperad" -> "src.core.patterns.operadic_handler.OperadicStructureHandler" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="operad", style="solid"];
"src.core.patterns.operadic_structure.AttentionOperad" -> "src.core.patterns.pattern_processor.PatternProcessor" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="operadic", style="solid"];
"src.core.patterns.operadic_structure.AttentionOperad" -> "src.core.patterns.symplectic.SymplecticStructure" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="operadic", style="solid"];
"src.core.patterns.operadic_structure.AttentionOperad" -> "src.core.tiling.patterns.pattern_fiber_bundle.PatternFiberBundle" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="operadic", style="solid"];
"src.core.patterns.operadic_structure.EnrichedAttention" -> "src.core.patterns.evolution.PatternEvolution" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="enriched", style="solid"];
"src.core.patterns.operadic_structure.EnrichedAttention" -> "src.core.patterns.formation.BifurcationAnalyzer" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="enriched", style="solid"];
"src.core.patterns.operadic_structure.EnrichedAttention" -> "src.core.patterns.formation.PatternFormation" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="enriched", style="solid"];
"src.core.patterns.operadic_structure.EnrichedAttention" -> "src.core.patterns.symplectic.SymplecticStructure" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="enriched", style="solid"];
"src.core.patterns.riemannian.PatternRiemannianStructure" -> "src.core.tiling.patterns.pattern_fiber_bundle.PatternFiberBundle" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="riemannian_framework", style="solid"];
"src.core.patterns.riemannian_flow.RiemannianFlow" -> "src.core.tiling.patterns.pattern_fiber_bundle.PatternFiberBundle" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="geometric_flow", style="solid"];
"src.core.patterns.symplectic.SymplecticStructure" -> "src.core.flow.pattern.PatternFormationFlow" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="symplectic", style="solid"];
"src.core.patterns.symplectic.SymplecticStructure" -> "src.core.patterns.evolution.PatternEvolution" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="symplectic", style="solid"];
"src.core.patterns.symplectic.SymplecticStructure" -> "src.core.patterns.evolution.PatternEvolution" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="symplectic", style="solid"];
"src.core.patterns.symplectic.SymplecticStructure" -> "src.core.patterns.formation.BifurcationAnalyzer" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="symplectic", style="solid"];
"src.core.patterns.symplectic.SymplecticStructure" -> "src.core.patterns.formation.PatternFormation" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="symplectic", style="solid"];
"src.core.patterns.symplectic.SymplecticStructure" -> "src.core.patterns.pattern_processor.PatternProcessor" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="symplectic", style="solid"];
"src.core.patterns.symplectic.SymplecticStructure" -> "src.core.tiling.patterns.pattern_fiber_bundle.PatternFiberBundle" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="symplectic", style="solid"];
"src.core.performance.cpu.algorithms.BranchOptimizer" -> "src.core.performance.cpu.algorithms.AlgorithmOptimizer" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="branch_opt", style="solid"];
"src.core.performance.cpu.algorithms.BranchOptimizer" -> "src.core.performance.cpu.algorithms.AlgorithmOptimizer" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="branch_opt", style="solid"];
"src.core.performance.cpu.algorithms.BranchOptimizer" -> "src.core.performance.cpu.algorithms.AlgorithmOptimizer" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="branch_opt", style="solid"];
"src.core.performance.cpu.algorithms.FastPathOptimizer" -> "src.core.performance.cpu.algorithms.AlgorithmOptimizer" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="fast_path", style="solid"];
"src.core.performance.cpu.algorithms.FastPathOptimizer" -> "src.core.performance.cpu.algorithms.AlgorithmOptimizer" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="fast_path", style="solid"];
"src.core.performance.cpu.algorithms.FastPathOptimizer" -> "src.core.performance.cpu.algorithms.AlgorithmOptimizer" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="fast_path", style="solid"];
"src.core.performance.cpu.algorithms.FastPathOptimizer" -> "src.core.performance.cpu.algorithms.AlgorithmOptimizer" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="fast_path", style="solid"];
"src.core.performance.cpu.algorithms.InstructionCounter" -> "src.core.performance.cpu.algorithms.AlgorithmOptimizer" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="instruction_counter", style="solid"];
"src.core.performance.cpu.algorithms.LoopOptimizer" -> "src.core.performance.cpu.algorithms.AlgorithmOptimizer" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="loop_opt", style="solid"];
"src.core.performance.cpu.algorithms.LoopOptimizer" -> "src.core.performance.cpu.algorithms.AlgorithmOptimizer" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="loop_opt", style="solid"];
"src.core.performance.cpu.algorithms.LoopOptimizer" -> "src.core.performance.cpu.algorithms.AlgorithmOptimizer" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="loop_opt", style="solid"];
"src.core.performance.cpu.algorithms.NumericalOptimizer" -> "src.core.performance.cpu.algorithms.AlgorithmOptimizer" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="numerical_opt", style="solid"];
"src.core.performance.cpu.algorithms.NumericalOptimizer" -> "src.core.performance.cpu.algorithms.AlgorithmOptimizer" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="numerical_opt", style="solid"];
"src.core.performance.cpu.memory.CacheOptimizer" -> "src.core.performance.cpu.memory.MemoryManager" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="cache_optimizer", style="solid"];
"src.core.performance.cpu.memory.MemoryPool" -> "src.core.performance.cpu.memory.MemoryManager" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="pool", style="solid"];
"src.core.performance.cpu.memory.MemoryPool" -> "src.core.performance.cpu.memory.MemoryManager" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="pool", style="solid"];
"src.core.quantum.neural_quantum_bridge.NeuralQuantumBridge" -> "src.core.flow.neural.NeuralGeometricFlow" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="quantum_bridge", style="solid"];
"src.core.quantum.neural_quantum_bridge.NeuralQuantumBridge" -> "src.core.patterns.pattern_processor.PatternProcessor" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="quantum_bridge", style="solid"];
"src.core.quantum.neural_quantum_bridge.NeuralQuantumBridge" -> "src.core.scale_transition.ScaleTransitionLayer" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="quantum_bridge", style="solid"];
"src.core.quantum.state_space.HilbertSpace" -> "src.core.quantum.neural_quantum_bridge.NeuralQuantumBridge" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="hilbert_space", style="solid"];
"src.core.scale_transition.ScaleTransitionLayer" -> "src.core.scale_transition.ScaleTransitionSystem" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="transition_layer", style="solid"];
"src.core.tiling.arithmetic_dynamics.ArithmeticDynamics" -> "src.core.flow.pattern.PatternFormationFlow" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="arithmetic", style="solid"];
"src.core.tiling.arithmetic_dynamics.ArithmeticDynamics" -> "src.core.patterns.motivic_integration.MotivicIntegrationSystem" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="dynamics", style="solid"];
"src.core.tiling.arithmetic_dynamics.ArithmeticDynamics" -> "src.core.patterns.pattern_processor.PatternProcessor" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="arithmetic", style="solid"];
"src.core.tiling.arithmetic_dynamics.ArithmeticDynamics" -> "src.core.tiling.geometric_flow.GeometricFlow" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="arithmetic", style="solid"];
"src.core.tiling.arithmetic_dynamics.ArithmeticPattern" -> "src.core.tiling.quantum_geometric_attention.QuantumGeometricAttention" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="arithmetic", style="solid"];
"src.core.tiling.arithmetic_dynamics.MotivicIntegrator" -> "src.core.patterns.motivic_integration.MotivicIntegrationSystem" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="integrator", style="solid"];
"src.core.tiling.geometric_flow.GeometricFlow" -> "src.core.tiling.quantum_geometric_attention.QuantumGeometricAttention" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="flow", style="solid"];
"src.core.tiling.optimization.parameter_manager.ParameterMonitor" -> "src.core.tiling.optimization.parameter_manager.AdaptiveParameterManager" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="monitor", style="solid"];
"src.core.tiling.patterns.cohomology.AdvancedMetricsAnalyzer" -> "src.core.tiling.patterns.cohomology.MotivicCohomology" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="metrics", style="solid"];
"src.core.tiling.patterns.cohomology.ArithmeticDynamics" -> "src.core.patterns.motivic_riemannian.MotivicRiemannianStructure" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="dynamics", style="solid"];
"src.core.tiling.patterns.cohomology.ArithmeticDynamics" -> "src.core.tiling.patterns.cohomology.MotivicCohomology" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="dynamics", style="solid"];
"src.core.tiling.patterns.cohomology.HeightStructure" -> "src.core.patterns.motivic_riemannian.MotivicRiemannianStructure" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="height_structure", style="solid"];
"src.core.tiling.patterns.cohomology.HeightStructure" -> "src.core.tiling.patterns.cohomology.MotivicCohomology" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="height_structure", style="solid"];
"src.core.tiling.patterns.cohomology.HeightStructure" -> "src.core.tiling.patterns.pattern_fiber_bundle.PatternFiberBundle" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="height_structure", style="solid"];
"src.core.tiling.patterns.cohomology.MotivicCohomology" -> "src.core.patterns.motivic_riemannian.MotivicRiemannianStructure" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="motive", style="solid"];
"src.core.tiling.patterns.cohomology.MotivicCohomology" -> "src.core.quantum.neural_quantum_bridge.NeuralQuantumBridge" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="motivic_system", style="solid"];
"src.core.tiling.patterns.cohomology.MotivicCohomology" -> "src.core.tiling.patterns.cohomology.QuantumMotivicCohomology" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="motivic", style="solid"];
"src.core.tiling.patterns.cohomology.QuantumMotivicCohomology" -> "src.core.patterns.motivic_integration.MotivicIntegrationSystem" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="cohomology", style="solid"];
"src.core.tiling.patterns.cohomology.RiemannianFiberBundle" -> "src.core.quantum.neural_quantum_bridge.NeuralQuantumBridge" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="riemannian_bundle", style="solid"];
"src.core.tiling.patterns.pattern_fiber_bundle.BundleConfig" -> "src.core.tiling.patterns.pattern_fiber_bundle.PatternFiberBundle" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="_config", style="solid"];
"src.core.tiling.patterns.pattern_fiber_bundle.PatternFiberBundle" -> "src.core.patterns.pattern_processor.PatternProcessor" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="pattern_bundle", style="solid"];
"src.core.tiling.patterns.pattern_fiber_bundle.PatternFiberBundle" -> "src.core.quantum.neural_quantum_bridge.NeuralQuantumBridge" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="pattern_bundle", style="solid"];
"src.core.tiling.quantum_attention_tile.QuantumMotivicTile" -> "src.core.quantum.neural_quantum_bridge.NeuralQuantumBridge" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="quantum_tile", style="solid"];
"src.core.tiling.quantum_attention_tile.QuantumMotivicTile" -> "src.core.tiling.quantum_geometric_attention.QuantumGeometricAttention" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="attention", style="solid"];
"src.core.tiling.quantum_geometric_attention.QuantumGeometricAttention" -> "src.core.quantum.neural_quantum_bridge.NeuralQuantumBridge" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="quantum_attention", style="solid"];
"src.core.tiling.state_manager.StateManager" -> "src.core.quantum.neural_quantum_bridge.NeuralQuantumBridge" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="state_manager", style="solid"];
"src.core.tiling.state_manager.StateType" -> "src.core.tiling.state_manager.StateConfig" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="type", style="solid"];
"src.core.vulkan.memory.MemoryBlock" -> "src.core.vulkan.resources.BufferResource" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="memory", style="solid"];
"src.core.vulkan.memory.MemoryBlock" -> "src.core.vulkan.resources.ImageResource" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="memory", style="solid"];
"src.infrastructure.base.DeviceInfo" -> "src.infrastructure.base.VulkanIntegration" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="_device_info", style="solid"];
"src.infrastructure.metrics.PerformanceMetrics" -> "src.infrastructure.metrics.InfrastructureMetrics" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="performance", style="solid"];
"src.infrastructure.metrics.ResourceMetrics" -> "src.infrastructure.metrics.InfrastructureMetrics" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="resources", style="solid"];
"src.metrics.quantum_geometric_metrics.ArithmeticMetrics" -> "src.metrics.quantum_geometric_metrics.UnifiedMetrics" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="arithmetic", style="solid"];
"src.metrics.quantum_geometric_metrics.GeometricMetrics" -> "src.metrics.quantum_geometric_metrics.UnifiedMetrics" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="geometric", style="solid"];
"src.metrics.quantum_geometric_metrics.PatternMetrics" -> "src.metrics.quantum_geometric_metrics.UnifiedMetrics" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="pattern", style="solid"];
"src.metrics.quantum_geometric_metrics.QuantumMetrics" -> "src.metrics.quantum_geometric_metrics.UnifiedMetrics" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="quantum", style="solid"];
"src.neural.attention.pattern.diffusion.DiffusionSystem" -> "src.neural.attention.pattern.dynamics.PatternDynamics" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="diffusion", style="solid"];
"src.neural.attention.pattern.dynamics.PatternDynamics" -> "src.core.attention.routing.InformationRouter" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="pattern_dynamics", style="solid"];
"src.neural.attention.pattern.quantum.QuantumGeometricTensor" -> "src.neural.attention.pattern.dynamics.PatternDynamics" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="quantum_tensor", style="solid"];
"src.neural.attention.pattern.reaction.ReactionSystem" -> "src.neural.attention.pattern.dynamics.PatternDynamics" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="reaction", style="solid"];
"src.neural.attention.pattern.stability.StabilityAnalyzer" -> "src.neural.attention.pattern.dynamics.PatternDynamics" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="stability", style="solid"];
"src.utils.memory_management.TensorManager" -> "src.utils.memory_management.MemoryOptimizer" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="tensor_manager", style="solid"];
"src.validation.flow.stability.LinearStabilityValidator" -> "src.validation.patterns.stability.PatternValidator" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="linear_validator", style="solid"];
"src.validation.flow.stability.NonlinearStabilityValidator" -> "src.validation.patterns.stability.PatternValidator" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="nonlinear_validator", style="solid"];
"src.validation.flow.stability.StructuralStabilityValidator" -> "src.validation.patterns.stability.PatternValidator" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="structural_validator", style="solid"];
"src.validation.geometric.symplectic.OperadicValidator" -> "src.validation.geometric.symplectic.SymplecticStructureValidator" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="operadic_validator", style="solid"];
"src.validation.geometric.symplectic.QuantumGeometricValidator" -> "src.validation.geometric.symplectic.SymplecticStructureValidator" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="quantum_validator", style="solid"];
"src.validation.geometric.symplectic.SymplecticStructureValidator" -> "src.validation.framework.ValidationFramework" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="symplectic_validator", style="solid"];
"src.validation.geometric.symplectic.WavePacketValidator" -> "src.validation.geometric.symplectic.SymplecticStructureValidator" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="wave_validator", style="solid"];
"src.validation.quantum.evolution.AdiabaticValidator" -> "src.validation.quantum.evolution.QuantumEvolutionValidator" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="adiabatic_validator", style="solid"];
"src.validation.quantum.evolution.DecoherenceValidator" -> "src.validation.quantum.evolution.QuantumEvolutionValidator" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="decoherence_validator", style="solid"];
"src.validation.quantum.evolution.UnitaryValidator" -> "src.validation.quantum.evolution.QuantumEvolutionValidator" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="unitary_validator", style="solid"];
"src.validation.quantum.state.DensityMatrixValidator" -> "src.validation.quantum.state.QuantumStateValidator" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="density_validator", style="solid"];
"src.validation.quantum.state.DensityMatrixValidator" -> "src.validation.quantum.state.StatePreparationValidator" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="density_validator", style="solid"];
"src.validation.quantum.state.DensityMatrixValidator" -> "src.validation.quantum.state.StateValidator" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="density_validator", style="solid"];
"src.validation.quantum.state.StatePreparationValidator" -> "src.core.flow.quantum.GeometricFlowAnalyzer" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="preparation_validator", style="solid"];
"src.validation.quantum.state.StatePreparationValidator" -> "src.core.quantum.neural_quantum_bridge.NeuralQuantumBridge" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="state_preparation", style="solid"];
"src.validation.quantum.state.StatePreparationValidator" -> "src.validation.quantum.state.QuantumStateValidator" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="preparation_validator", style="solid"];
"src.validation.quantum.state.StatePreparationValidator" -> "src.validation.quantum.state.StateValidator" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="preparation_validator", style="solid"];
"src.validation.quantum.state.StateValidator" -> "src.core.flow.quantum.GeometricFlowAnalyzer" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="state_validator", style="solid"];
"src.validation.quantum.state.StateValidator" -> "src.core.flow.quantum.QuantumGeometricFlow" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="state_validator", style="solid"];
"src.validation.quantum.state.StateValidator" -> "src.core.quantum.neural_quantum_bridge.NeuralQuantumBridge" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="state_validator", style="solid"];
"src.validation.quantum.state.StateValidator" -> "src.validation.quantum.evolution.DecoherenceValidator" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="state_validator", style="solid"];
"src.validation.quantum.state.TomographyValidator" -> "src.core.flow.quantum.QuantumGeometricFlow" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="tomography_validator", style="solid"];
"src.validation.quantum.state.TomographyValidator" -> "src.validation.quantum.state.QuantumStateValidator" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="tomography_validator", style="solid"];
"src.validation.quantum.state.TomographyValidator" -> "src.validation.quantum.state.StatePreparationValidator" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="tomography_validator", style="solid"];
"src.validation.quantum.state.TomographyValidator" -> "src.validation.quantum.state.StateValidator" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="tomography_validator", style="solid"];
"torch._C.Size" -> "torch._C.TensorBase" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="shape", style="solid"];
"torch._C.device" -> "src.core.patterns.motivic_integration.MotivicIntegrationSystem" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="device", style="solid"];
"torch._C.device" -> "src.core.patterns.motivic_riemannian.MotivicRiemannianStructure" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="device", style="solid"];
"torch._C.device" -> "src.core.patterns.operadic_handler.OperadicStructureHandler" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="device", style="solid"];
"torch._C.device" -> "src.core.patterns.pattern_processor.PatternProcessor" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="device", style="solid"];
"torch._C.device" -> "src.core.patterns.riemannian.BaseRiemannianStructure" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="device", style="solid"];
"torch._C.device" -> "src.core.performance.gpu.memory_management.GPUMemoryManager" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="device", style="solid"];
"torch._C.device" -> "src.core.tiling.patterns.pattern_fiber_bundle.PatternFiberBundle" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="device", style="solid"];
"torch._C.device" -> "src.core.tiling.state_manager.StateManager" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="device", style="solid"];
"torch._C.device" -> "src.metrics.quantum_geometric_metrics.MetricContext" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="device", style="solid"];
"torch._C.device" -> "torch._C.TensorBase" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="device", style="solid"];
"torch._C.dtype" -> "torch._C.TensorBase" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="dtype", style="solid"];
"torch._C.layout" -> "torch._C.TensorBase" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="layout", style="solid"];
"torch._dynamo.eval_frame.OptimizedModule" -> "torch.nn.modules.module.Module" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="_compiled_call_impl", style="solid"];
"torch._tensor.Tensor" -> "src.core.flow.protocol.QuantumFlowMetrics" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="quantum_entropy", style="solid"];
"torch._tensor.Tensor" -> "src.core.metrics.evolution.EvolutionMetrics" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="l_values", style="solid"];
"torch._tensor.Tensor" -> "src.core.metrics.evolution.EvolutionMetrics" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="flow_metrics", style="solid"];
"torch._tensor.Tensor" -> "src.core.metrics.evolution.EvolutionMetrics" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="ergodic_avg", style="solid"];
"torch._tensor.Tensor" -> "src.core.patterns.enriched_structure.EnrichedMorphism" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="source_space", style="solid"];
"torch._tensor.Tensor" -> "src.core.patterns.enriched_structure.EnrichedMorphism" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="target_space", style="solid"];
"torch._tensor.Tensor" -> "src.core.patterns.enriched_structure.EnrichedMorphism" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="structure_map", style="solid"];
"torch._tensor.Tensor" -> "src.core.patterns.evolution.PatternEvolutionMetrics" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="quantum_metric", style="solid"];
"torch._tensor.Tensor" -> "src.core.patterns.evolution.PatternEvolutionMetrics" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="geometric_flow", style="solid"];
"torch._tensor.Tensor" -> "src.core.patterns.formation.BifurcationMetrics" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="quantum_metric", style="solid"];
"torch._tensor.Tensor" -> "src.core.patterns.formation.BifurcationMetrics" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="geometric_flow", style="solid"];
"torch._tensor.Tensor" -> "src.core.patterns.operadic_structure.OperadicOperation" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="composition_law", style="solid"];
"torch._tensor.Tensor" -> "src.core.patterns.symplectic.SymplecticForm" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="matrix", style="solid"];
"torch._tensor.Tensor" -> "src.core.tiling.patterns.cohomology.ArithmeticForm" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="coefficients", style="solid"];
"torch._tensor.Tensor" -> "src.core.tiling.quantum_geometric_attention.AttentionMetrics" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="entropy", style="solid"];
"torch._tensor.Tensor" -> "src.core.tiling.quantum_geometric_attention.AttentionMetrics" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="complexity", style="solid"];
"torch._tensor.Tensor" -> "src.core.tiling.quantum_geometric_attention.AttentionState" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="quantum_state", style="solid"];
"torch._tensor.Tensor" -> "src.core.tiling.quantum_geometric_attention.AttentionState" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="geometric_state", style="solid"];
"torch._tensor.Tensor" -> "src.core.tiling.quantum_geometric_attention.FlowMetrics" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="curvature", style="solid"];
"torch._tensor.Tensor" -> "src.core.tiling.quantum_geometric_attention.FlowMetrics" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="parallel_transport", style="solid"];
"torch._tensor.Tensor" -> "src.core.tiling.quantum_geometric_attention.FlowMetrics" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="geodesic_distance", style="solid"];
"torch._tensor.Tensor" -> "src.core.tiling.quantum_geometric_attention.FlowMetrics" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="energy", style="solid"];
"torch._tensor.Tensor" -> "src.core.types.PatternState" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="coordinates", style="solid"];
"torch._tensor.Tensor" -> "src.core.types.PatternState" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="metric", style="solid"];
"torch._tensor.Tensor" -> "src.core.types.RiemannianMetric" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="tensor", style="solid"];
"torch._tensor.Tensor" -> "src.validation.quantum.state.DensityMatrixValidation" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="eigenvalues", style="solid"];
"torch._tensor.Tensor" -> "src.validation.quantum.state.StateProperties" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="eigenvalues", style="solid"];
"torch._tensor.Tensor" -> "src.validation.quantum.state.TomographyValidation" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="estimated_state", style="solid"];
"torch._tensor.Tensor" -> "torch._C.TensorBase" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="data", style="solid"];
"torch._tensor.Tensor" -> "torch._C.TensorBase" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="real", style="solid"];
"torch._tensor.Tensor" -> "torch._C.TensorBase" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="imag", style="solid"];
"torch._tensor.Tensor" -> "torch._C.TensorBase" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="T", style="solid"];
"torch._tensor.Tensor" -> "torch._C.TensorBase" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="H", style="solid"];
"torch._tensor.Tensor" -> "torch._C.TensorBase" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="mT", style="solid"];
"torch._tensor.Tensor" -> "torch._C.TensorBase" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="mH", style="solid"];
"torch.nn.modules.container.ModuleList" -> "src.core.crystal.scale.ScaleConnection" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="connections", style="solid"];
"torch.nn.modules.container.ModuleList" -> "src.core.crystal.scale.ScaleInvariance" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="scale_transform", style="solid"];
"torch.nn.modules.container.ModuleList" -> "src.core.metrics.evolution.ErgodicAnalysis" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="observables", style="solid"];
"torch.nn.modules.container.ModuleList" -> "src.core.models.base.ModelGeometry" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="attention_heads", style="solid"];
"torch.nn.modules.container.ModuleList" -> "src.core.patterns.base_flow.BaseGeometricFlow" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="flow_layers", style="solid"];
"torch.nn.modules.container.ModuleList" -> "src.core.scale_transition.ScaleFlowIntegrator" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="scale_dependent_ops", style="solid"];
"torch.nn.modules.container.ModuleList" -> "src.core.scale_transition.ScaleTransitionLayer" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="scale_up", style="solid"];
"torch.nn.modules.container.ModuleList" -> "src.core.scale_transition.ScaleTransitionLayer" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="scale_down", style="solid"];
"torch.nn.modules.container.ModuleList" -> "src.core.tiling.arithmetic_dynamics.ArithmeticPattern" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="layers", style="solid"];
"torch.nn.modules.container.ModuleList" -> "src.core.tiling.quantum_geometric_attention.QuantumGeometricAttention" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="tiles", style="solid"];
"torch.nn.modules.container.ModuleList" -> "src.core.tiling.quantum_geometric_attention.QuantumGeometricTransformer" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="layers", style="solid"];
"torch.nn.modules.container.Sequential" -> "src.core.attention.routing.InformationRouter" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="route_scorer", style="solid"];
"torch.nn.modules.container.Sequential" -> "src.core.attention.routing.InformationRouter" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="bottleneck_detector", style="solid"];
"torch.nn.modules.container.Sequential" -> "src.core.crystal.scale.AnomalyDetector" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="detector", style="solid"];
"torch.nn.modules.container.Sequential" -> "src.core.crystal.scale.RenormalizationFlow" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="beta_network", style="solid"];
"torch.nn.modules.container.Sequential" -> "src.core.crystal.scale.RenormalizationFlow" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="fp_detector", style="solid"];
"torch.nn.modules.container.Sequential" -> "src.core.crystal.scale.ScaleCohomology" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="callan_symanzik_net", style="solid"];
"torch.nn.modules.container.Sequential" -> "src.core.crystal.scale.ScaleCohomology" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="ope_net", style="solid"];
"torch.nn.modules.container.Sequential" -> "src.core.crystal.scale.ScaleCohomology" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="conformal_net", style="solid"];
"torch.nn.modules.container.Sequential" -> "src.core.crystal.scale.ScaleConnection" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="holonomy_computer", style="solid"];
"torch.nn.modules.container.Sequential" -> "src.core.crystal.scale.ScaleInvariance" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="invariant_detector", style="solid"];
"torch.nn.modules.container.Sequential" -> "src.core.flow.base.BaseGeometricFlow" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="metric_net", style="solid"];
"torch.nn.modules.container.Sequential" -> "src.core.flow.base.BaseGeometricFlow" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="connection_net", style="solid"];
"torch.nn.modules.container.Sequential" -> "src.core.flow.base.BaseGeometricFlow" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="curvature_net", style="solid"];
"torch.nn.modules.container.Sequential" -> "src.core.flow.computation.FlowComputation" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="vector_field", style="solid"];
"torch.nn.modules.container.Sequential" -> "src.core.flow.computation.FlowComputation" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="potential", style="solid"];
"torch.nn.modules.container.Sequential" -> "src.core.flow.higher_order.HigherOrderFlow" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="fourth_order_net", style="solid"];
"torch.nn.modules.container.Sequential" -> "src.core.flow.higher_order.HigherOrderFlow" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="bach_tensor_net", style="solid"];
"torch.nn.modules.container.Sequential" -> "src.core.flow.higher_order.HigherOrderFlow" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="calabi_net", style="solid"];
"torch.nn.modules.container.Sequential" -> "src.core.flow.higher_order.HigherOrderFlow" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="cross_curvature_net", style="solid"];
"torch.nn.modules.container.Sequential" -> "src.core.flow.information_ricci.InformationRicciFlow" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="potential_net", style="solid"];
"torch.nn.modules.container.Sequential" -> "src.core.flow.information_ricci.InformationRicciFlow" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="stress_energy_net", style="solid"];
"torch.nn.modules.container.Sequential" -> "src.core.flow.neural.NeuralGeometricFlow" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="fisher_net", style="solid"];
"torch.nn.modules.container.Sequential" -> "src.core.flow.neural.NeuralGeometricFlow" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="quantum_correction_net", style="solid"];
"torch.nn.modules.container.Sequential" -> "src.core.flow.pattern.PatternFormationFlow" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="reaction_net", style="solid"];
"torch.nn.modules.container.Sequential" -> "src.core.flow.pattern.PatternFormationFlow" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="diffusion_net", style="solid"];
"torch.nn.modules.container.Sequential" -> "src.core.flow.pattern.PatternFormationFlow" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="stability_net", style="solid"];
"torch.nn.modules.container.Sequential" -> "src.core.flow.pattern.PatternFormationFlow" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="control_net", style="solid"];
"torch.nn.modules.container.Sequential" -> "src.core.flow.pattern_heat.PatternHeatFlow" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="pattern_net", style="solid"];
"torch.nn.modules.container.Sequential" -> "src.core.flow.protocol.RicciTensorNetwork" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="hidden", style="solid"];
"torch.nn.modules.container.Sequential" -> "src.core.flow.quantum.QuantumGeometricFlow" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="uncertainty_net", style="solid"];
"torch.nn.modules.container.Sequential" -> "src.core.flow.quantum.QuantumGeometricFlow" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="entanglement_net", style="solid"];
"torch.nn.modules.container.Sequential" -> "src.core.flow.quantum.QuantumGeometricFlow" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="mean_curvature_net", style="solid"];
"torch.nn.modules.container.Sequential" -> "src.core.flow.quantum.QuantumGeometricFlow" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="fubini_study_net", style="solid"];
"torch.nn.modules.container.Sequential" -> "src.core.flow.quantum.QuantumGeometricFlow" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="quantum_transport_net", style="solid"];
"torch.nn.modules.container.Sequential" -> "src.core.flow.quantum.QuantumGeometricFlow" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="state_reconstruction_net", style="solid"];
"torch.nn.modules.container.Sequential" -> "src.core.metrics.evolution.LFunctionComputation" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="network", style="solid"];
"torch.nn.modules.container.Sequential" -> "src.core.patterns.base_flow.BaseGeometricFlow" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="metric_net", style="solid"];
"torch.nn.modules.container.Sequential" -> "src.core.patterns.pattern_processor.PatternProcessor" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="pattern_net", style="solid"];
"torch.nn.modules.container.Sequential" -> "src.core.patterns.pattern_processor.PatternProcessor" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="flow_net", style="solid"];
"torch.nn.modules.container.Sequential" -> "src.core.patterns.pattern_processor.PatternProcessor" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="quantum_net", style="solid"];
"torch.nn.modules.container.Sequential" -> "src.core.patterns.riemannian_flow.RiemannianFlow" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="christoffel_net", style="solid"];
"torch.nn.modules.container.Sequential" -> "src.core.tiling.arithmetic_dynamics.ArithmeticDynamics" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="l_function", style="solid"];
"torch.nn.modules.container.Sequential" -> "src.core.tiling.arithmetic_dynamics.ArithmeticDynamics" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="quantum_height", style="solid"];
"torch.nn.modules.container.Sequential" -> "src.core.tiling.arithmetic_dynamics.ArithmeticDynamics" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="quantum_l_function", style="solid"];
"torch.nn.modules.container.Sequential" -> "src.core.tiling.arithmetic_dynamics.ModularFormComputer" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="coeff_net", style="solid"];
"torch.nn.modules.container.Sequential" -> "src.core.tiling.arithmetic_dynamics.ModularFormComputer" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="symmetry_net", style="solid"];
"torch.nn.modules.container.Sequential" -> "src.core.tiling.arithmetic_dynamics.MotivicIntegrator" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="measure_net", style="solid"];
"torch.nn.modules.container.Sequential" -> "src.core.tiling.arithmetic_dynamics.MotivicIntegrator" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="domain_net", style="solid"];
"torch.nn.modules.container.Sequential" -> "src.core.tiling.geometric_flow.GeometricFlow" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="hamiltonian", style="solid"];
"torch.nn.modules.container.Sequential" -> "src.core.tiling.patterns.cohomology.ArithmeticDynamics" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="hidden_proj", style="solid"];
"torch.nn.modules.container.Sequential" -> "src.core.tiling.patterns.cohomology.ArithmeticDynamics" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="l_function", style="solid"];
"torch.nn.modules.container.Sequential" -> "src.core.tiling.quantum_geometric_attention.QuantumGeometricAttention" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="to_out", style="solid"];
"torch.nn.modules.container.Sequential" -> "src.neural.attention.pattern.reaction.ReactionSystem" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="activator_network", style="solid"];
"torch.nn.modules.container.Sequential" -> "src.neural.attention.pattern.reaction.ReactionSystem" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="inhibitor_network", style="solid"];
"torch.nn.modules.dropout.Dropout" -> "src.core.tiling.quantum_attention_tile.QuantumMotivicTile" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="dropout_layer", style="solid"];
"torch.nn.modules.dropout.Dropout" -> "src.core.tiling.quantum_geometric_attention.QuantumGeometricAttention" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="dropout", style="solid"];
"torch.nn.modules.linear.Linear" -> "src.core.flow.protocol.RicciTensorNetwork" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="projection", style="solid"];
"torch.nn.modules.linear.Linear" -> "src.core.flow.protocol.RicciTensorNetwork" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="output", style="solid"];
"torch.nn.modules.linear.Linear" -> "src.core.metrics.evolution.FlowEvolution" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="flow", style="solid"];
"torch.nn.modules.linear.Linear" -> "src.core.metrics.evolution.OrbitAnalysis" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="projection", style="solid"];
"torch.nn.modules.linear.Linear" -> "src.core.metrics.height_theory.AdaptiveHeightTheory" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="height_projection", style="solid"];
"torch.nn.modules.linear.Linear" -> "src.core.patterns.motivic_riemannian.MotivicRiemannianStructure" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="fiber_map", style="solid"];
"torch.nn.modules.linear.Linear" -> "src.core.patterns.motivic_riemannian.MotivicRiemannianStructure" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="connection_map", style="solid"];
"torch.nn.modules.linear.Linear" -> "src.core.scale_transition.ScaleFlowIntegrator" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="scale_quantum_proj", style="solid"];
"torch.nn.modules.linear.Linear" -> "src.core.scale_transition.ScaleFlowIntegrator" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="scale_classical_proj", style="solid"];
"torch.nn.modules.linear.Linear" -> "src.core.tiling.arithmetic_dynamics.ArithmeticDynamics" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="height_map", style="solid"];
"torch.nn.modules.linear.Linear" -> "src.core.tiling.arithmetic_dynamics.ArithmeticDynamics" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="flow", style="solid"];
"torch.nn.modules.linear.Linear" -> "src.core.tiling.arithmetic_dynamics.ArithmeticDynamics" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="adelic_proj", style="solid"];
"torch.nn.modules.linear.Linear" -> "src.core.tiling.arithmetic_dynamics.ArithmeticDynamics" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="output_proj", style="solid"];
"torch.nn.modules.linear.Linear" -> "src.core.tiling.arithmetic_dynamics.ArithmeticPattern" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="pattern_proj", style="solid"];
"torch.nn.modules.linear.Linear" -> "src.core.tiling.patterns.cohomology.ArithmeticDynamics" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="flow", style="solid"];
"torch.nn.modules.linear.Linear" -> "src.core.tiling.patterns.cohomology.RiemannianFiberBundle" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="fiber_map", style="solid"];
"torch.nn.modules.linear.Linear" -> "src.core.tiling.patterns.cohomology.RiemannianFiberBundle" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="connection_map", style="solid"];
"torch.nn.modules.linear.Linear" -> "src.core.tiling.quantum_attention_tile.QuantumMotivicTile" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="query", style="solid"];
"torch.nn.modules.linear.Linear" -> "src.core.tiling.quantum_attention_tile.QuantumMotivicTile" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="key", style="solid"];
"torch.nn.modules.linear.Linear" -> "src.core.tiling.quantum_attention_tile.QuantumMotivicTile" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="value", style="solid"];
"torch.nn.modules.linear.Linear" -> "src.core.tiling.quantum_attention_tile.QuantumMotivicTile" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="output", style="solid"];
"torch.nn.modules.linear.Linear" -> "src.core.tiling.quantum_attention_tile.QuantumMotivicTile" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="cohomology_proj", style="solid"];
"torch.nn.modules.linear.Linear" -> "src.core.tiling.quantum_attention_tile.QuantumMotivicTile" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="field_proj", style="solid"];
"torch.nn.modules.linear.Linear" -> "src.core.tiling.quantum_attention_tile.QuantumMotivicTile" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="height_proj", style="solid"];
"torch.nn.modules.linear.Linear" -> "src.core.tiling.quantum_geometric_attention.QuantumGeometricAttention" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="to_qkv", style="solid"];
"torch.nn.modules.linear.Linear" -> "src.core.tiling.quantum_geometric_attention.QuantumGeometricAttention" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="pattern_proj", style="solid"];
"torch.nn.modules.linear.Linear" -> "src.metrics.quantum_geometric_metrics.ArithmeticMetrics" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="motive_proj", style="solid"];
"torch.nn.modules.normalization.LayerNorm" -> "src.core.scale_transition.ScaleTransitionLayer" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="scale_norm", style="solid"];
"torch.nn.modules.normalization.LayerNorm" -> "src.core.tiling.quantum_geometric_attention.QuantumGeometricTransformer" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="norm", style="solid"];
"torch.nn.modules.rnn.GRU" -> "src.core.attention.routing.InformationRouter" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="path_predictor", style="solid"];
"torch.nn.parameter.Parameter" -> "src.core.attention.geometric.GeometricStructures" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="metric", style="solid"];
"torch.nn.parameter.Parameter" -> "src.core.attention.geometric.GeometricStructures" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="connection", style="solid"];
"torch.nn.parameter.Parameter" -> "src.core.attention.geometric.GeometricStructures" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="curvature_tensor", style="solid"];
"torch.nn.parameter.Parameter" -> "src.core.attention.geometric.HyperbolicExponential" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="curvature", style="solid"];
"torch.nn.parameter.Parameter" -> "src.core.attention.geometric.HyperbolicLogarithm" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="curvature", style="solid"];
"torch.nn.parameter.Parameter" -> "src.core.flow.quantum.QuantumGeometricFlow" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="berry_connection", style="solid"];
"torch.nn.parameter.Parameter" -> "src.core.models.base.LayerGeometry" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="metric_tensor", style="solid"];
"torch.nn.parameter.Parameter" -> "src.core.models.base.LayerGeometry" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="connection_coeffs", style="solid"];
"torch.nn.parameter.Parameter" -> "src.core.patterns.motivic_riemannian.MotivicRiemannianStructure" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="metric_factors", style="solid"];
"torch.nn.parameter.Parameter" -> "src.core.patterns.motivic_riemannian.MotivicRiemannianStructure" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="connection_coeffs", style="solid"];
"torch.nn.parameter.Parameter" -> "src.core.patterns.riemannian.BaseRiemannianStructure" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="metric_factors", style="solid"];
"torch.nn.parameter.Parameter" -> "src.core.patterns.riemannian.BaseRiemannianStructure" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="connection_coeffs", style="solid"];
"torch.nn.parameter.Parameter" -> "src.core.patterns.riemannian.PatternRiemannianStructure" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="metric_factors", style="solid"];
"torch.nn.parameter.Parameter" -> "src.core.patterns.riemannian.PatternRiemannianStructure" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="connection_coeffs", style="solid"];
"torch.nn.parameter.Parameter" -> "src.core.quantum.state_space.HilbertSpace" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="hamiltonian", style="solid"];
"torch.nn.parameter.Parameter" -> "src.core.scale_transition.ScaleFlowIntegrator" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="entanglement_tracker", style="solid"];
"torch.nn.parameter.Parameter" -> "src.core.tiling.arithmetic_dynamics.ArithmeticDynamics" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="coupling", style="solid"];
"torch.nn.parameter.Parameter" -> "src.core.tiling.geometric_flow.GeometricFlow" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="chart_embedding", style="solid"];
"torch.nn.parameter.Parameter" -> "src.core.tiling.quantum_geometric_attention.PatternDynamics" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="patterns", style="solid"];
"torch.nn.parameter.Parameter" -> "src.core.tiling.quantum_geometric_attention.PatternDynamics" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="pattern_scores", style="solid"];
"torch.nn.parameter.Parameter" -> "src.core.tiling.quantum_geometric_attention.QuantumGeometricAttention" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="metric", style="solid"];
"torch.nn.parameter.Parameter" -> "src.metrics.quantum_geometric_metrics.ArithmeticMetrics" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="prime_bases", style="solid"];
"torch.nn.parameter.Parameter" -> "torch.nn.modules.linear.Linear" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="weight", style="solid"];
"torch.nn.parameter.Parameter" -> "torch.nn.modules.linear.Linear" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="bias", style="solid"];
"torch.nn.parameter.Parameter" -> "torch.nn.modules.normalization.LayerNorm" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="weight", style="solid"];
"torch.nn.parameter.Parameter" -> "torch.nn.modules.normalization.LayerNorm" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="bias", style="solid"];
"torch.optim.adam.Adam" -> "src.core.metrics.height_theory.AdaptiveHeightTheory" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="optimizer", style="solid"];
"typing_extensions._ExtensionsSpecialForm" -> "torch.optim.optimizer.Optimizer" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="OptimizerPreHook", style="solid"];
"typing_extensions._ExtensionsSpecialForm" -> "torch.optim.optimizer.Optimizer" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="OptimizerPostHook", style="solid"];
"src.core.flow.quantum.QuantumGeometricFlow" -> "src.core.flow.quantum.GeometricFlowAnalyzer" [arrowhead="odiamond", arrowtail="none", fontcolor="green", label="flow", style="solid"];
"src.core.models.base.ModelGeometry" -> "src.validation.geometric.model.ModelGeometricValidator" [arrowhead="odiamond", arrowtail="none", fontcolor="green", label="model_geometry", style="solid"];
"src.core.patterns.riemannian.PatternRiemannianStructure" -> "src.core.tiling.patterns.cohomology.DeRhamCohomology" [arrowhead="odiamond", arrowtail="none", fontcolor="green", label="manifold", style="solid"];
"src.core.patterns.riemannian.PatternRiemannianStructure" -> "src.core.tiling.patterns.cohomology.Integration" [arrowhead="odiamond", arrowtail="none", fontcolor="green", label="manifold", style="solid"];
"src.core.patterns.riemannian.PatternRiemannianStructure" -> "src.core.tiling.patterns.cohomology.QuantumMotivicCohomology" [arrowhead="odiamond", arrowtail="none", fontcolor="green", label="metric", style="solid"];
"src.core.patterns.riemannian.RiemannianFramework" -> "src.core.patterns.evolution.PatternEvolution" [arrowhead="odiamond", arrowtail="none", fontcolor="green", label="framework", style="solid"];
"src.core.scale_transition.ScaleTransitionConfig" -> "src.core.scale_transition.ScaleFlowIntegrator" [arrowhead="odiamond", arrowtail="none", fontcolor="green", label="config", style="solid"];
"src.core.scale_transition.ScaleTransitionConfig" -> "src.core.scale_transition.ScaleTransitionLayer" [arrowhead="odiamond", arrowtail="none", fontcolor="green", label="config", style="solid"];
"src.core.scale_transition.ScaleTransitionConfig" -> "src.core.scale_transition.ScaleTransitionSystem" [arrowhead="odiamond", arrowtail="none", fontcolor="green", label="config", style="solid"];
"src.core.tiling.patterns.cohomology.ArithmeticDynamics" -> "src.core.patterns.motivic_riemannian.MotivicChristoffelSymbols" [arrowhead="odiamond", arrowtail="none", fontcolor="green", label="dynamics", style="solid"];
"src.core.tiling.patterns.cohomology.FiberBundle" -> "src.core.tiling.patterns.cohomology.CohomologyGroup" [arrowhead="odiamond", arrowtail="none", fontcolor="green", label="base_space", style="solid"];
"src.core.tiling.patterns.cohomology.HeightStructure" -> "src.core.patterns.motivic_riemannian.MotivicMetricTensor" [arrowhead="odiamond", arrowtail="none", fontcolor="green", label="height_structure", style="solid"];
"src.core.tiling.patterns.cohomology.MotivicCohomology" -> "src.core.patterns.motivic_riemannian.MotivicCurvatureTensor" [arrowhead="odiamond", arrowtail="none", fontcolor="green", label="motive", style="solid"];
"src.core.tiling.patterns.cohomology.RiemannianFiberBundle" -> "src.core.tiling.patterns.cohomology.MotivicCohomology" [arrowhead="odiamond", arrowtail="none", fontcolor="green", label="base_space", style="solid"];
"src.core.tiling.state_manager.StateConfig" -> "src.core.tiling.state_manager.StateManager" [arrowhead="odiamond", arrowtail="none", fontcolor="green", label="config", style="solid"];
"src.core.vulkan.memory.VulkanMemory" -> "src.core.vulkan.resources.VulkanResources" [arrowhead="odiamond", arrowtail="none", fontcolor="green", label="memory", style="solid"];
"src.metrics.quantum_geometric_metrics.MetricDomain" -> "src.metrics.quantum_geometric_metrics.BaseMetric" [arrowhead="odiamond", arrowtail="none", fontcolor="green", label="domain", style="solid"];
"src.validation.geometric.model.ModelGeometricValidator" -> "src.validation.framework.ValidationFramework" [arrowhead="odiamond", arrowtail="none", fontcolor="green", label="geometric_validator", style="solid"];
"src.validation.patterns.stability.PatternValidator" -> "src.validation.framework.ValidationFramework" [arrowhead="odiamond", arrowtail="none", fontcolor="green", label="pattern_validator", style="solid"];
"src.validation.quantum.state.QuantumStateValidator" -> "src.validation.framework.ValidationFramework" [arrowhead="odiamond", arrowtail="none", fontcolor="green", label="quantum_validator", style="solid"];
"torch._C.device" -> "src.core.patterns.dynamics.PatternDynamics" [arrowhead="odiamond", arrowtail="none", fontcolor="green", label="device", style="solid"];
"torch._tensor.Tensor" -> "src.core.flow.quantum.QuantumGeometricFlow" [arrowhead="odiamond", arrowtail="none", fontcolor="green", label="_points", style="solid"];
"torch._tensor.Tensor" -> "src.core.tiling.patterns.pattern_fiber_bundle.TensorStateContext" [arrowhead="odiamond", arrowtail="none", fontcolor="green", label="original_tensor", style="solid"];
"torch.nn.modules.module.Module" -> "torch._dynamo.eval_frame.OptimizedModule" [arrowhead="odiamond", arrowtail="none", fontcolor="green", label="_orig_mod", style="solid"];
}

digraph "classes_adaptive_attention" {
rankdir=BT
charset="utf-8"
"src.core.metrics.height_theory.AdaptiveHeightTheory" [color="black", fontcolor="black", label=<{AdaptiveHeightTheory|height_projection : Linear<br ALIGN="LEFT"/>height_structure<br ALIGN="LEFT"/>hidden_dim : int<br ALIGN="LEFT"/>history<br ALIGN="LEFT"/>optimizer : Adam<br ALIGN="LEFT"/>|adapt(loss: torch.Tensor): None<br ALIGN="LEFT"/>forward(x: torch.Tensor): Tuple[torch.Tensor, Dict[str, torch.Tensor]]<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.core.tiling.optimization.parameter_manager.AdaptiveParameterManager" [color="black", fontcolor="black", label=<{AdaptiveParameterManager|adapt_factor : float<br ALIGN="LEFT"/>base_lr : float<br ALIGN="LEFT"/>learning_rates : Dict[str, float]<br ALIGN="LEFT"/>max_lr : float<br ALIGN="LEFT"/>min_lr : float<br ALIGN="LEFT"/>momentum : float<br ALIGN="LEFT"/>monitor<br ALIGN="LEFT"/>velocities : Dict[str, torch.Tensor]<br ALIGN="LEFT"/>|get_lr(name: str): float<br ALIGN="LEFT"/>get_state_dict(): Dict<br ALIGN="LEFT"/>load_state_dict(state_dict: Dict)<br ALIGN="LEFT"/>step(name: str, param: nn.Parameter, grad: Optional[torch.Tensor])<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.validation.quantum.evolution.AdiabaticValidation" [color="black", fontcolor="black", label=<{AdiabaticValidation|adiabatic : bool<br ALIGN="LEFT"/>energy_gap : float<br ALIGN="LEFT"/>fidelity : float<br ALIGN="LEFT"/>transition_prob : float<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"src.validation.quantum.evolution.AdiabaticValidator" [color="black", fontcolor="black", label=<{AdiabaticValidator|tolerance : float<br ALIGN="LEFT"/>|validate_adiabatic(initial: QuantumState, trajectory: List[QuantumState], hamiltonians: List[torch.Tensor]): AdiabaticValidation<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.core.metrics.advanced_metrics.AdvancedMetricsAnalyzer" [color="black", fontcolor="black", label=<{AdvancedMetricsAnalyzer|history : Dict[str, List[float]]<br ALIGN="LEFT"/>|compute_cross_tile_flow(pattern: torch.Tensor, tile_size: int): float<br ALIGN="LEFT"/>compute_edge_utilization(pattern: torch.Tensor, edge_threshold: float): float<br ALIGN="LEFT"/>compute_ifq(pattern: torch.Tensor, tile_size: int, window_size: int, edge_threshold: float): InformationFlowMetrics<br ALIGN="LEFT"/>compute_info_density(pattern: torch.Tensor): float<br ALIGN="LEFT"/>compute_pattern_stability(pattern: torch.Tensor, window_size: int): float<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.core.tiling.patterns.cohomology.AdvancedMetricsAnalyzer" [color="black", fontcolor="black", label=<{AdvancedMetricsAnalyzer|<br ALIGN="LEFT"/>|compute_ifq(pattern_stability: float, cross_tile_flow: float, edge_utilization: float, info_density: float): float<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.core.performance.cpu.algorithms.AlgorithmMetrics" [color="black", fontcolor="black", label=<{AlgorithmMetrics|branch_misses : int<br ALIGN="LEFT"/>execution_time : float<br ALIGN="LEFT"/>instruction_count : int<br ALIGN="LEFT"/>numerical_error : float<br ALIGN="LEFT"/>optimization_type : str<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"src.core.performance.cpu.algorithms.AlgorithmOptimizer" [color="black", fontcolor="black", label=<{AlgorithmOptimizer|branch_opt : NoneType<br ALIGN="LEFT"/>enable_profiling : bool<br ALIGN="LEFT"/>fast_path : NoneType<br ALIGN="LEFT"/>instruction_counter<br ALIGN="LEFT"/>loop_opt : NoneType<br ALIGN="LEFT"/>metrics : List[AlgorithmMetrics]<br ALIGN="LEFT"/>numerical_opt : NoneType<br ALIGN="LEFT"/>operations : Dict[str, Callable]<br ALIGN="LEFT"/>optimization_level : str<br ALIGN="LEFT"/>|clear_metrics(): None<br ALIGN="LEFT"/>get_metrics(): List[AlgorithmMetrics]<br ALIGN="LEFT"/>optimize_algorithm(func: Callable): Callable<br ALIGN="LEFT"/>optimize_operation(operation_name: str): Any<br ALIGN="LEFT"/>register_fast_path(name: str, implementation: Callable, condition: Callable[..., bool]): None<br ALIGN="LEFT"/>register_operation(name: str, operation: Callable): None<br ALIGN="LEFT"/>set_optimization_level(level: str): None<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.core.flow.quantum.AnalyzerMetrics" [color="black", fontcolor="black", label=<{AnalyzerMetrics|berry_phase : float<br ALIGN="LEFT"/>convergence : float<br ALIGN="LEFT"/>energy_conservation : float<br ALIGN="LEFT"/>holonomy : float<br ALIGN="LEFT"/>mean_curvature : float<br ALIGN="LEFT"/>quantum_corrections : float<br ALIGN="LEFT"/>ricci_scalar : float<br ALIGN="LEFT"/>stability : float<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"src.core.tiling.arithmetic_dynamics.ArithmeticDynamics" [color="black", fontcolor="black", label=<{ArithmeticDynamics|adelic_proj : Linear<br ALIGN="LEFT"/>coupling : Parameter<br ALIGN="LEFT"/>flow : Linear<br ALIGN="LEFT"/>height_dim : int<br ALIGN="LEFT"/>height_map : Linear<br ALIGN="LEFT"/>hidden_dim : int<br ALIGN="LEFT"/>l_function : Sequential<br ALIGN="LEFT"/>motive_rank : int<br ALIGN="LEFT"/>num_primes : int<br ALIGN="LEFT"/>output_proj : Linear<br ALIGN="LEFT"/>quantum_height : Sequential<br ALIGN="LEFT"/>quantum_l_function : Sequential<br ALIGN="LEFT"/>quantum_weight : float<br ALIGN="LEFT"/>|compute_dynamics(x: torch.Tensor): torch.Tensor<br ALIGN="LEFT"/>compute_height(x: torch.Tensor): torch.Tensor<br ALIGN="LEFT"/>compute_l_function(x: torch.Tensor): torch.Tensor<br ALIGN="LEFT"/>compute_modular_form(x: torch.Tensor): torch.Tensor<br ALIGN="LEFT"/>compute_motivic_integral(x: torch.Tensor, num_samples: int): torch.Tensor<br ALIGN="LEFT"/>compute_quantum_correction(metric: torch.Tensor): torch.Tensor<br ALIGN="LEFT"/>compute_quantum_metric(x: torch.Tensor): torch.Tensor<br ALIGN="LEFT"/>forward(x: torch.Tensor, steps: int, return_trajectory: bool): Tuple[torch.Tensor, Dict]<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.core.tiling.patterns.cohomology.ArithmeticDynamics" [color="black", fontcolor="black", label=<{ArithmeticDynamics|flow : Linear<br ALIGN="LEFT"/>hidden_dim : int<br ALIGN="LEFT"/>hidden_proj : Sequential<br ALIGN="LEFT"/>l_function : Sequential<br ALIGN="LEFT"/>motive_rank : int<br ALIGN="LEFT"/>num_primes : int<br ALIGN="LEFT"/>|compute_dynamics(state: torch.Tensor): torch.Tensor<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.core.tiling.patterns.cohomology.ArithmeticForm" [color="black", fontcolor="black", label=<{ArithmeticForm|coefficients : Tensor<br ALIGN="LEFT"/>degree : int<br ALIGN="LEFT"/>dynamics_state : Optional[torch.Tensor]<br ALIGN="LEFT"/>height_data : Optional[torch.Tensor]<br ALIGN="LEFT"/>prime_bases : Optional[torch.Tensor]<br ALIGN="LEFT"/>|exterior_derivative(): 'ArithmeticForm'<br ALIGN="LEFT"/>wedge(other: 'ArithmeticForm'): 'ArithmeticForm'<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.metrics.quantum_geometric_metrics.ArithmeticMetrics" [color="black", fontcolor="black", label=<{ArithmeticMetrics|hidden_dim : int<br ALIGN="LEFT"/>motive_proj : Linear<br ALIGN="LEFT"/>motive_rank : int<br ALIGN="LEFT"/>num_primes : int<br ALIGN="LEFT"/>prime_bases : Parameter<br ALIGN="LEFT"/>|compute_adelic_norm(patterns: torch.Tensor, context: MetricContext): torch.Tensor<br ALIGN="LEFT"/>compute_global_height(patterns: torch.Tensor, context: MetricContext): torch.Tensor<br ALIGN="LEFT"/>compute_height_distribution(patterns: torch.Tensor, context: MetricContext, num_bins: int): Tuple[torch.Tensor, torch.Tensor]<br ALIGN="LEFT"/>compute_l_function(patterns: torch.Tensor, context: MetricContext): torch.Tensor<br ALIGN="LEFT"/>compute_local_height(patterns: torch.Tensor, context: MetricContext): torch.Tensor<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.core.tiling.arithmetic_dynamics.ArithmeticPattern" [color="black", fontcolor="black", label=<{ArithmeticPattern|hidden_dim : int<br ALIGN="LEFT"/>input_dim : int<br ALIGN="LEFT"/>layers : ModuleList<br ALIGN="LEFT"/>motive_rank : int<br ALIGN="LEFT"/>num_layers : int<br ALIGN="LEFT"/>pattern_proj : Linear<br ALIGN="LEFT"/>|forward(x: torch.Tensor): Tuple[torch.Tensor, List[Dict]]<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.core.attention.compute.AttentionCompute" [color="black", fontcolor="black", label=<{AttentionCompute|dropout : float<br ALIGN="LEFT"/>|compute_output(scores: torch.Tensor, value: torch.Tensor): torch.Tensor<br ALIGN="LEFT"/>compute_scores(query: torch.Tensor, key: torch.Tensor, mask: Optional[torch.Tensor], scale: Optional[float]): torch.Tensor<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.core.tiling.quantum_geometric_attention.AttentionMetrics" [color="black", fontcolor="black", label=<{AttentionMetrics|complexity : Tensor<br ALIGN="LEFT"/>entropy : Tensor<br ALIGN="LEFT"/>sparsity : Optional[torch.Tensor]<br ALIGN="LEFT"/>stability : Optional[torch.Tensor]<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"src.core.patterns.operadic_structure.AttentionOperad" [color="black", fontcolor="black", label=<{AttentionOperad|base_dim : int<br ALIGN="LEFT"/>preserve_metric : bool<br ALIGN="LEFT"/>preserve_symplectic : bool<br ALIGN="LEFT"/>|compose(operations: List[OperadicOperation]): OperadicOperation<br ALIGN="LEFT"/>create_operation(source_dim: int, target_dim: int, preserve_structure: Optional[str]): OperadicOperation<br ALIGN="LEFT"/>natural_transformation(source_op: OperadicOperation, target_op: OperadicOperation): Tensor<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.core.tiling.quantum_attention_tile.AttentionResult" [color="black", fontcolor="black", label=<{AttentionResult|<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"src.core.tiling.quantum_geometric_attention.AttentionState" [color="black", fontcolor="black", label=<{AttentionState|attention_scores : Optional[torch.Tensor]<br ALIGN="LEFT"/>geometric_state : Tensor<br ALIGN="LEFT"/>quantum_state : Tensor<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"src.core.attention.base.BaseAttention" [color="black", fontcolor="black", label=<{BaseAttention|backend : AttentionBackend<br ALIGN="LEFT"/>|forward(query: torch.Tensor, key: torch.Tensor, value: torch.Tensor, mask: Optional[torch.Tensor]): torch.Tensor<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.core.patterns.fiber_bundle.BaseFiberBundle" [color="black", fontcolor="black", label=<{BaseFiberBundle|base_dim : int<br ALIGN="LEFT"/>connection<br ALIGN="LEFT"/>fiber_dim<br ALIGN="LEFT"/>metric<br ALIGN="LEFT"/>structure_group : Optional[str]<br ALIGN="LEFT"/>total_dim<br ALIGN="LEFT"/>|bundle_projection(total_space: Tensor): Tensor<br ALIGN="LEFT"/>compute_holonomy_algebra(holonomies: List[Tensor]): Tensor<br ALIGN="LEFT"/>compute_holonomy_group(holonomies: List[Tensor]): Tensor<br ALIGN="LEFT"/>compute_metric(points: torch.Tensor): MetricTensor[torch.Tensor]<br ALIGN="LEFT"/>connection_form(tangent_vector: Tensor): Tensor<br ALIGN="LEFT"/>local_trivialization(point: Tensor): Tuple[LocalChart[Tensor], FiberChart[Tensor, str]]<br ALIGN="LEFT"/>parallel_transport(section: Tensor, path: Tensor): Tensor<br ALIGN="LEFT"/>transition_functions(chart1: LocalChart[Tensor], chart2: LocalChart[Tensor]): Tensor<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.core.flow.base.BaseGeometricFlow" [color="black", fontcolor="black", label=<{BaseGeometricFlow|connection_net : Sequential<br ALIGN="LEFT"/>curvature_net : Sequential<br ALIGN="LEFT"/>dt : float<br ALIGN="LEFT"/>hidden_dim : int<br ALIGN="LEFT"/>manifold_dim : int<br ALIGN="LEFT"/>metric_net : Sequential<br ALIGN="LEFT"/>stability_threshold : float<br ALIGN="LEFT"/>|compute_connection(metric: Tensor, points: Optional[Tensor]): Tensor<br ALIGN="LEFT"/>compute_curvature(metric: Tensor, connection: Optional[Tensor]): Tensor<br ALIGN="LEFT"/>compute_geodesic(start_point: Tensor, end_point: Tensor, num_steps: int): Tensor<br ALIGN="LEFT"/>compute_metric(points: Tensor, connection: Optional[Tensor]): Tensor<br ALIGN="LEFT"/>compute_ricci_tensor(metric: Tensor, points: Optional[Tensor], connection: Optional[Tensor]): Tensor<br ALIGN="LEFT"/>detect_singularities(metric: Tensor, points: Optional[Tensor], threshold: float): List[SingularityInfo[Tensor]]<br ALIGN="LEFT"/>flow_step(metric: Tensor, ricci: Optional[Tensor], timestep: float): Tuple[Tensor, FlowMetrics]<br ALIGN="LEFT"/>normalize_flow(flow: Tensor, metric: Optional[Tensor], method: str): Tensor<br ALIGN="LEFT"/>parallel_transport(vector: Tensor, start_point: Tensor, end_point: Tensor, connection: Optional[Tensor]): Tensor<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.core.patterns.base_flow.BaseGeometricFlow" [color="black", fontcolor="black", label=<{BaseGeometricFlow|dt : float<br ALIGN="LEFT"/>flow_layers : ModuleList<br ALIGN="LEFT"/>hidden_dim<br ALIGN="LEFT"/>manifold_dim : int<br ALIGN="LEFT"/>metric_net : Sequential<br ALIGN="LEFT"/>num_layers : int<br ALIGN="LEFT"/>stability_threshold : float<br ALIGN="LEFT"/>|compute_metric(x: torch.Tensor): torch.Tensor<br ALIGN="LEFT"/>compute_ricci_tensor(metric: torch.Tensor, connection: Optional[torch.Tensor]): torch.Tensor<br ALIGN="LEFT"/>detect_singularities(flow: torch.Tensor, threshold: float): List[Dict[str, Any]]<br ALIGN="LEFT"/>flow_step(metric: torch.Tensor, ricci: torch.Tensor, timestep: float): Tuple[torch.Tensor, Dict[str, Any]]<br ALIGN="LEFT"/>forward(x: torch.Tensor, return_path: bool): Tuple[torch.Tensor, Dict[str, Any]]<br ALIGN="LEFT"/>normalize_flow(flow: torch.Tensor, normalization: str): torch.Tensor<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.metrics.quantum_geometric_metrics.BaseMetric" [color="black", fontcolor="black", label=<{BaseMetric|domain<br ALIGN="LEFT"/>history : List[T]<br ALIGN="LEFT"/>name : str<br ALIGN="LEFT"/>|<I>compute</I>(): T<br ALIGN="LEFT"/>reset(): None<br ALIGN="LEFT"/>update(value: T, context: MetricContext): None<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.core.patterns.riemannian.BaseRiemannianStructure" [color="black", fontcolor="black", label=<{BaseRiemannianStructure|cache : Dict[str, Any]<br ALIGN="LEFT"/>connection_coeffs : Parameter<br ALIGN="LEFT"/>device : device<br ALIGN="LEFT"/>dtype : Ellipsis<br ALIGN="LEFT"/>manifold_dim : int<br ALIGN="LEFT"/>metric_factors : Parameter<br ALIGN="LEFT"/>|compute_christoffel(points: Tensor): ChristoffelSymbols[Tensor]<br ALIGN="LEFT"/>compute_curvature(points: Tensor, christoffel: Optional[ChristoffelSymbols[Tensor]]): CurvatureTensor[Tensor]<br ALIGN="LEFT"/>compute_metric(points: Tensor): MetricTensor[Tensor]<br ALIGN="LEFT"/>exp_map(point: Tensor, vector: Tensor): Tensor<br ALIGN="LEFT"/>geodesic_flow(initial_point: Tensor, initial_velocity: Tensor, steps: int, step_size: float): Tuple[Tensor, Tensor]<br ALIGN="LEFT"/>lie_derivative_metric(point: Tensor, vector_field: Callable[[Tensor], Tensor]): MetricTensor[Tensor]<br ALIGN="LEFT"/>parallel_transport(vector: Tensor, path: Tensor, connection: Optional[ChristoffelSymbols[Tensor]]): Tensor<br ALIGN="LEFT"/>sectional_curvature(point: Tensor, v1: Tensor, v2: Tensor): Tensor<br ALIGN="LEFT"/>validate_connection_properties(connection: ChristoffelSymbols[Tensor]): bool<br ALIGN="LEFT"/>validate_metric_properties(metric: MetricTensor[Tensor]): bool<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.validation.base.BasicValidationResult" [color="black", fontcolor="black", label=<{BasicValidationResult|<br ALIGN="LEFT"/>|from_dict(data: Dict[str, Any]): 'BasicValidationResult'<br ALIGN="LEFT"/>merge(other: ValidationResult): 'BasicValidationResult'<br ALIGN="LEFT"/>to_dict(): Dict[str, Any]<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.core.benchmarks.metrics.BenchmarkMetrics" [color="black", fontcolor="black", label=<{BenchmarkMetrics|backward_time : float<br ALIGN="LEFT"/>batch_size : int<br ALIGN="LEFT"/>device : str<br ALIGN="LEFT"/>efficiency : float<br ALIGN="LEFT"/>flops : float<br ALIGN="LEFT"/>forward_time : float<br ALIGN="LEFT"/>memory_allocated_mb : float<br ALIGN="LEFT"/>memory_pool : Optional[MemoryPoolManager]<br ALIGN="LEFT"/>num_parameters : int<br ALIGN="LEFT"/>operations : List[OperationMetrics]<br ALIGN="LEFT"/>peak_memory_mb : float<br ALIGN="LEFT"/>throughput : float<br ALIGN="LEFT"/>total_time : float<br ALIGN="LEFT"/>|compute_throughput()<br ALIGN="LEFT"/>from_model(model: torch.nn.Module, input_size: tuple): 'BenchmarkMetrics'<br ALIGN="LEFT"/>record_operation(name: str)<br ALIGN="LEFT"/>to_dict(): Dict[str, Union[float, int, Dict[str, Any]]]<br ALIGN="LEFT"/>update_memory()<br ALIGN="LEFT"/>update_timing(forward_time: float, backward_time: float)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.core.patterns.formation.BifurcationAnalyzer" [color="black", fontcolor="black", label=<{BifurcationAnalyzer|enriched<br ALIGN="LEFT"/>operadic<br ALIGN="LEFT"/>preserve_structure : bool<br ALIGN="LEFT"/>symplectic<br ALIGN="LEFT"/>threshold : float<br ALIGN="LEFT"/>wave_enabled : bool<br ALIGN="LEFT"/>window_size : int<br ALIGN="LEFT"/>|analyze_stability(pattern: torch.Tensor, parameter_range: Tuple[float, float], num_points: int): Dict[str, Any]<br ALIGN="LEFT"/>detect_bifurcations(pattern: torch.Tensor, parameter: torch.Tensor): List[float]<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.core.patterns.formation.BifurcationMetrics" [color="black", fontcolor="black", label=<{BifurcationMetrics|geometric_flow : Tensor<br ALIGN="LEFT"/>max_eigenvalue : float<br ALIGN="LEFT"/>pattern_height : float<br ALIGN="LEFT"/>quantum_metric : Tensor<br ALIGN="LEFT"/>stability_margin : float<br ALIGN="LEFT"/>symplectic_invariant : float<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"src.core.performance.cpu.algorithms.BranchOptimizer" [color="black", fontcolor="black", label=<{BranchOptimizer|branch_stats : Dict[str, Dict[bool, int]]<br ALIGN="LEFT"/>|likely(condition: bool, branch_id: str): bool<br ALIGN="LEFT"/>optimize_branches(func: Callable): Callable<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.core.vulkan.resources.BufferResource" [color="black", fontcolor="black", label=<{BufferResource|buffer : int<br ALIGN="LEFT"/>memory<br ALIGN="LEFT"/>size : int<br ALIGN="LEFT"/>usage : int<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"src.core.tiling.patterns.pattern_fiber_bundle.BundleConfig" [color="black", fontcolor="black", label=<{BundleConfig|base_dim : int<br ALIGN="LEFT"/>dt : float<br ALIGN="LEFT"/>fiber_dim : int<br ALIGN="LEFT"/>integration_steps : int<br ALIGN="LEFT"/>learning_rate : float<br ALIGN="LEFT"/>momentum : float<br ALIGN="LEFT"/>motive_rank : int<br ALIGN="LEFT"/>num_primes : int<br ALIGN="LEFT"/>stability_threshold : float<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"src.core.performance.cpu_memory.CPUMemoryManager" [color="black", fontcolor="black", label=<{CPUMemoryManager|<br ALIGN="LEFT"/>|allocate_tensor(size: Union[Tuple[int, ...], torch.Size], dtype: Any): torch.Tensor<br ALIGN="LEFT"/>cleanup(): None<br ALIGN="LEFT"/>copy_from_device(src: torch.Tensor, dst: Union[torch.Tensor, np.ndarray]): None<br ALIGN="LEFT"/>copy_to_device(src: Union[torch.Tensor, np.ndarray], dst: torch.Tensor): None<br ALIGN="LEFT"/>free_tensor(tensor: torch.Tensor): None<br ALIGN="LEFT"/>get_fragmentation_ratio(): float<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.infrastructure.base.CPUOptimizer" [color="black", fontcolor="black", label=<{CPUOptimizer|enable_profiling : bool<br ALIGN="LEFT"/>|get_metrics(): Dict[str, float]<br ALIGN="LEFT"/>get_thread_info(): List[Dict[str, Any]]<br ALIGN="LEFT"/>optimize(func: Callable, data: torch.Tensor): torch.Tensor<br ALIGN="LEFT"/>profile()<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.infrastructure.cpu_optimizer.CPUOptimizer" [color="black", fontcolor="black", label=<{CPUOptimizer|cache_optimization_enabled : bool<br ALIGN="LEFT"/>thread_pool_size<br ALIGN="LEFT"/>vectorization_enabled : bool<br ALIGN="LEFT"/>|enable_cache_optimization(enabled: bool): None<br ALIGN="LEFT"/>enable_vectorization(enabled: bool): None<br ALIGN="LEFT"/>optimize_memory_layout(data: np.ndarray): np.ndarray<br ALIGN="LEFT"/>set_thread_pool_size(size: int): None<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.core.performance.cpu_optimizer.CPUOptimizer" [color="black", fontcolor="black", label=<{CPUOptimizer|cpu_profiler : Profile<br ALIGN="LEFT"/>enable_memory_tracking : bool<br ALIGN="LEFT"/>enable_profiling : bool<br ALIGN="LEFT"/>line_profiler : LineProfiler<br ALIGN="LEFT"/>memory_profiler<br ALIGN="LEFT"/>|get_performance_metrics(): PerformanceMetrics<br ALIGN="LEFT"/>optimize_computation(computation_graph: torch.nn.Module, sample_input: torch.Tensor): torch.nn.Module<br ALIGN="LEFT"/>optimize_memory_access(tensor: torch.Tensor): torch.Tensor<br ALIGN="LEFT"/>profile_execution(func: Callable): Callable<br ALIGN="LEFT"/>vectorize_operation(func: Callable[..., torch.Tensor], inputs: List[torch.Tensor], chunk_size: Optional[int]): torch.Tensor<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.core.performance.cpu.memory.CacheOptimizer" [color="black", fontcolor="black", label=<{CacheOptimizer|cache_line_size : int<br ALIGN="LEFT"/>stats : dict<br ALIGN="LEFT"/>|optimize_layout(tensor: torch.Tensor): torch.Tensor<br ALIGN="LEFT"/>prefetch(tensor: torch.Tensor, indices: torch.Tensor): None<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.core.patterns.riemannian_base.ChristoffelSymbols" [color="black", fontcolor="black", label=<{ChristoffelSymbols|is_symmetric : bool<br ALIGN="LEFT"/>metric : MetricTensor[T]<br ALIGN="LEFT"/>values : T<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"src.core.tiling.patterns.cohomology.CohomologyGroup" [color="black", fontcolor="black", label=<{CohomologyGroup|base_space<br ALIGN="LEFT"/>boundaries : List[ArithmeticForm]<br ALIGN="LEFT"/>degree : int<br ALIGN="LEFT"/>representatives : List[ArithmeticForm]<br ALIGN="LEFT"/>|add_cocycle(form: ArithmeticForm): None<br ALIGN="LEFT"/>cup_product(other: 'CohomologyGroup'): 'CohomologyGroup'<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.core.performance.vulkan.shaders.ComputeShaderDispatcher" [color="black", fontcolor="black", label=<{ComputeShaderDispatcher|command_pool : c_void_p<br ALIGN="LEFT"/>device : c_void_p<br ALIGN="LEFT"/>queue : c_void_p<br ALIGN="LEFT"/>|dispatch(pipeline: VkPipeline, pipeline_layout: VkPipelineLayout, descriptor_set: VkDescriptorSet, push_constants: Optional[bytes], group_count: Tuple[int, int, int]): None<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.validation.framework.ConcreteValidationResult" [color="black", fontcolor="black", label=<{ConcreteValidationResult|bifurcation_points : Optional[List[torch.Tensor]]<br ALIGN="LEFT"/>component_scores : Dict[str, float]<br ALIGN="LEFT"/>curvature_bounds : Optional[Tuple[float, float]]<br ALIGN="LEFT"/>energy_metrics : Optional[Dict[str, float]]<br ALIGN="LEFT"/>framework_accuracy : float<br ALIGN="LEFT"/>framework_consistency : float<br ALIGN="LEFT"/>metrics : Dict[str, Any]<br ALIGN="LEFT"/>overall_score<br ALIGN="LEFT"/>stability_eigenvalues : Optional[torch.Tensor]<br ALIGN="LEFT"/>|from_dict(data: Dict[str, Any]): 'ConcreteValidationResult'<br ALIGN="LEFT"/>get_summary(): str<br ALIGN="LEFT"/>merge(other: ValidationResult): 'ConcreteValidationResult'<br ALIGN="LEFT"/>to_dict(): Dict[str, Any]<br ALIGN="LEFT"/>validate_metric(metric: torch.Tensor): bool<br ALIGN="LEFT"/>validate_positive_definite(metric: torch.Tensor): bool<br ALIGN="LEFT"/>validate_smoothness(metric: torch.Tensor): bool<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.core.vulkan.resources.ConvertibleToInt" [color="black", fontcolor="black", label=<{ConvertibleToInt|<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"src.core.patterns.riemannian_base.CurvatureTensor" [color="black", fontcolor="black", label=<{CurvatureTensor|ricci : T<br ALIGN="LEFT"/>riemann : T<br ALIGN="LEFT"/>scalar_curvatures : T<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"src.core.tiling.patterns.cohomology.DeRhamCohomology" [color="black", fontcolor="black", label=<{DeRhamCohomology|cohomology_groups : List[CohomologyGroup]<br ALIGN="LEFT"/>manifold<br ALIGN="LEFT"/>|betti_numbers(): List[int]<br ALIGN="LEFT"/>compute_cohomology(max_degree: int): None<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.validation.quantum.evolution.DecoherenceValidation" [color="black", fontcolor="black", label=<{DecoherenceValidation|decay_rate : float<br ALIGN="LEFT"/>decoherence_time : float<br ALIGN="LEFT"/>entropy_increase : float<br ALIGN="LEFT"/>purity_loss : float<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"src.validation.quantum.evolution.DecoherenceValidator" [color="black", fontcolor="black", label=<{DecoherenceValidator|state_validator<br ALIGN="LEFT"/>time_steps : int<br ALIGN="LEFT"/>|validate_decoherence(initial: QuantumState, trajectory: List[QuantumState]): DecoherenceValidation<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.validation.quantum.state.DensityMatrixValidation" [color="black", fontcolor="black", label=<{DensityMatrixValidation|eigenvalues : Tensor<br ALIGN="LEFT"/>hermitian : bool<br ALIGN="LEFT"/>positive : bool<br ALIGN="LEFT"/>trace_one : bool<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"src.validation.quantum.state.DensityMatrixValidator" [color="black", fontcolor="black", label=<{DensityMatrixValidator|tolerance : float<br ALIGN="LEFT"/>|validate_density_matrix(state: QuantumState): QuantumStateValidationResult<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.infrastructure.base.DeviceInfo" [color="black", fontcolor="black", label=<{DeviceInfo|compute_support : bool<br ALIGN="LEFT"/>memory_types : List[str]<br ALIGN="LEFT"/>queue_families : List[str]<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"src.core.patterns.operadic_structure.EnrichedAttention" [color="black", fontcolor="black", label=<{EnrichedAttention|base_category : str<br ALIGN="LEFT"/>wave_enabled : bool<br ALIGN="LEFT"/>|create_morphism(pattern: Tensor, operation: OperadicOperation, include_wave: bool): Tensor<br ALIGN="LEFT"/>create_wave_packet(position: Tensor, momentum: Tensor): Tensor<br ALIGN="LEFT"/>get_momentum(wave: Tensor): Tensor<br ALIGN="LEFT"/>get_position(wave: Tensor): Tensor<br ALIGN="LEFT"/>wave_operator(tensor: Tensor): Tensor<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.core.patterns.enriched_structure.EnrichedMorphism" [color="black", fontcolor="black", label=<{EnrichedMorphism|source_space : Tensor<br ALIGN="LEFT"/>structure_map : Tensor<br ALIGN="LEFT"/>target_space : Tensor<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"src.core.patterns.symplectic.EnrichedOperator" [color="black", fontcolor="black", label=<{EnrichedOperator|base_category : str<br ALIGN="LEFT"/>wave_enabled : bool<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"src.core.patterns.enriched_structure.EnrichedTransition" [color="black", fontcolor="black", label=<{EnrichedTransition|<br ALIGN="LEFT"/>|<I>compose</I>(first: EnrichedMorphism, second: EnrichedMorphism): EnrichedMorphism<br ALIGN="LEFT"/><I>create_morphism</I>(source: Tensor, target: Tensor): EnrichedMorphism<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.validation.quantum.state.EntanglementMetrics" [color="black", fontcolor="black", label=<{EntanglementMetrics|concurrence : float<br ALIGN="LEFT"/>log_negativity : float<br ALIGN="LEFT"/>negativity : float<br ALIGN="LEFT"/>ppt_criterion : bool<br ALIGN="LEFT"/>von_neumann_entropy : float<br ALIGN="LEFT"/>witness_value : float<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"src.core.metrics.evolution.ErgodicAnalysis" [color="black", fontcolor="black", label=<{ErgodicAnalysis|hidden_dim : int<br ALIGN="LEFT"/>history : List[torch.Tensor]<br ALIGN="LEFT"/>num_observables : int<br ALIGN="LEFT"/>observables : ModuleList<br ALIGN="LEFT"/>|compute_ergodic_average(pattern: torch.Tensor): torch.Tensor<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.core.attention.geometric.EuclideanExponential" [color="black", fontcolor="black", label=<{EuclideanExponential|dim : int<br ALIGN="LEFT"/>|forward(x: torch.Tensor, v: torch.Tensor): torch.Tensor<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.core.attention.geometric.EuclideanLogarithm" [color="black", fontcolor="black", label=<{EuclideanLogarithm|dim : int<br ALIGN="LEFT"/>|forward(x: torch.Tensor, y: torch.Tensor): torch.Tensor<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.core.metrics.evolution.EvolutionAnalyzer" [color="black", fontcolor="black", label=<{EvolutionAnalyzer|ergodic<br ALIGN="LEFT"/>flow<br ALIGN="LEFT"/>l_function<br ALIGN="LEFT"/>orbit<br ALIGN="LEFT"/>|analyze_evolution(pattern: torch.Tensor): EvolutionMetrics<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.core.metrics.evolution.EvolutionMetrics" [color="black", fontcolor="black", label=<{EvolutionMetrics|ergodic_avg : Tensor<br ALIGN="LEFT"/>flow_metrics : Tensor<br ALIGN="LEFT"/>l_values : Tensor<br ALIGN="LEFT"/>orbit_stats : Dict[str, float]<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"src.core.performance.cpu.algorithms.FastPathDict" [color="black", fontcolor="black", label=<{FastPathDict|condition : Callable[..., bool]<br ALIGN="LEFT"/>implementation : Callable[..., Any]<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"src.core.performance.cpu.algorithms.FastPathOptimizer" [color="black", fontcolor="black", label=<{FastPathOptimizer|fast_paths : Dict[str, FastPathDict]<br ALIGN="LEFT"/>path_stats : Dict[str, int]<br ALIGN="LEFT"/>|optimize(func: Callable[..., T]): Callable[..., T]<br ALIGN="LEFT"/>register_fast_path(name: str, condition: Callable[..., bool], implementation: Callable[..., Any]): None<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.core.tiling.patterns.cohomology.FiberBundle" [color="black", fontcolor="black", label=<{FiberBundle|<br ALIGN="LEFT"/>|get_connection(point: torch.Tensor): torch.Tensor<br ALIGN="LEFT"/>get_fiber(point: torch.Tensor): torch.Tensor<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.core.patterns.fiber_types.FiberBundle" [color="black", fontcolor="black", label=<{FiberBundle|<br ALIGN="LEFT"/>|bundle_projection(total_space: T): T<br ALIGN="LEFT"/>connection_form(tangent_vector: T): T<br ALIGN="LEFT"/>local_trivialization(point: T): Tuple[LocalChart[T], FiberChart[T, str]]<br ALIGN="LEFT"/>parallel_transport(section: T, path: T): T<br ALIGN="LEFT"/>transition_functions(chart1: T, chart2: T): T<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.core.types.FiberBundleProtocol" [color="black", fontcolor="black", label=<{FiberBundleProtocol|base_dim : int<br ALIGN="LEFT"/>fiber_dim : int<br ALIGN="LEFT"/>total_dim : int<br ALIGN="LEFT"/>|bundle_projection(total_space: torch.Tensor): torch.Tensor<br ALIGN="LEFT"/>get_connection(point: torch.Tensor): torch.Tensor<br ALIGN="LEFT"/>get_fiber(point: torch.Tensor): torch.Tensor<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.core.patterns.fiber_types.FiberChart" [color="black", fontcolor="black", label=<{FiberChart|fiber_coordinates : T<br ALIGN="LEFT"/>structure_group : StructureGroup<br ALIGN="LEFT"/>transition_functions : dict<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"src.core.patterns.fiber_types.FiberType" [color="black", fontcolor="black", label=<{FiberType|dimension : int<br ALIGN="LEFT"/>is_complex : bool<br ALIGN="LEFT"/>is_oriented : bool<br ALIGN="LEFT"/>metric_type : str<br ALIGN="LEFT"/>name : str<br ALIGN="LEFT"/>structure_group : str<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"src.core.patterns.fiber_types.FiberTypeManager" [color="black", fontcolor="black", label=<{FiberTypeManager|<br ALIGN="LEFT"/>|check_compatibility(fiber_type: str, structure_group: str): bool<br ALIGN="LEFT"/>convert_fiber_type(section: Tensor, source_type: str, target_type: str, fiber_dim: int): Tensor<br ALIGN="LEFT"/>get_fiber_type(name: str): Optional[FiberType]<br ALIGN="LEFT"/>get_structure_group(name: str): Optional[Dict]<br ALIGN="LEFT"/>list_fiber_types(): List[str]<br ALIGN="LEFT"/>list_structure_groups(): List[str]<br ALIGN="LEFT"/>register_conversion(source_type: str, target_type: str, conversion_fn: Callable[[Tensor], Tensor]): None<br ALIGN="LEFT"/>register_fiber_type(fiber_type: FiberType): None<br ALIGN="LEFT"/>validate_fiber_type(section: Tensor, fiber_type: str, fiber_dim: int): bool<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.core.flow.computation.FlowComputation" [color="black", fontcolor="black", label=<{FlowComputation|dim : int<br ALIGN="LEFT"/>potential : Sequential<br ALIGN="LEFT"/>vector_field : Sequential<br ALIGN="LEFT"/>|compute_gradient_flow(x: torch.Tensor, steps: int, step_size: float): List[torch.Tensor]<br ALIGN="LEFT"/>compute_hamiltonian_flow(x: torch.Tensor, p: torch.Tensor, steps: int, step_size: float): Tuple[List[torch.Tensor], List[torch.Tensor]]<br ALIGN="LEFT"/>compute_parallel_transport(curve: List[torch.Tensor], initial_vector: torch.Tensor): List[torch.Tensor]<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.core.metrics.evolution.FlowEvolution" [color="black", fontcolor="black", label=<{FlowEvolution|flow : Linear<br ALIGN="LEFT"/>flow_dim : int<br ALIGN="LEFT"/>hidden_dim : int<br ALIGN="LEFT"/>history : List[torch.Tensor]<br ALIGN="LEFT"/>|compute_flow(pattern: torch.Tensor): torch.Tensor<br ALIGN="LEFT"/>get_evolution_stats(window_size: int): Dict[str, torch.Tensor]<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.core.flow.protocol.FlowMetrics" [color="black", fontcolor="black", label=<{FlowMetrics|energy : float<br ALIGN="LEFT"/>flow_magnitude : float<br ALIGN="LEFT"/>metric_determinant : float<br ALIGN="LEFT"/>normalized_flow : float<br ALIGN="LEFT"/>ricci_scalar : float<br ALIGN="LEFT"/>singularity : float<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"src.core.tiling.quantum_geometric_attention.FlowMetrics" [color="black", fontcolor="black", label=<{FlowMetrics|curvature : Tensor<br ALIGN="LEFT"/>energy : Tensor<br ALIGN="LEFT"/>geodesic_distance : Tensor<br ALIGN="LEFT"/>parallel_transport : Tensor<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"src.validation.framework.FrameworkValidationResult" [color="black", fontcolor="black", label=<{FrameworkValidationResult|curvature_bounds : Optional[Tuple[float, float]]<br ALIGN="LEFT"/>flow_result : Optional[TilingFlowValidationResult]<br ALIGN="LEFT"/>geometric_result : Optional[GeometricValidationResult]<br ALIGN="LEFT"/>motivic_result : Optional[MotivicValidation]<br ALIGN="LEFT"/>pattern_result : Optional[ValidationResult]<br ALIGN="LEFT"/>quantum_result : Optional[QuantumStateValidationResult]<br ALIGN="LEFT"/>|from_dict(data: Dict[str, Any]): 'FrameworkValidationResult'<br ALIGN="LEFT"/>merge(other: ValidationResult): 'FrameworkValidationResult'<br ALIGN="LEFT"/>to_dict(): Dict[str, Any]<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.core.performance.gpu.memory_management.GPUMemoryManager" [color="black", fontcolor="black", label=<{GPUMemoryManager|device : device<br ALIGN="LEFT"/>|allocate(size: tuple, dtype: torch.dtype): torch.Tensor<br ALIGN="LEFT"/>clear_cache()<br ALIGN="LEFT"/>free(tensor: torch.Tensor)<br ALIGN="LEFT"/>get_memory_stats(): Dict[str, float]<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.core.tiling.geometric_flow.GeometricFlow" [color="black", fontcolor="black", label=<{GeometricFlow|arithmetic<br ALIGN="LEFT"/>chart_embedding : Parameter<br ALIGN="LEFT"/>hamiltonian : Sequential<br ALIGN="LEFT"/>integration_steps : int<br ALIGN="LEFT"/>motive_rank : int<br ALIGN="LEFT"/>num_charts : int<br ALIGN="LEFT"/>|compute_metric(x: Tensor): Tensor<br ALIGN="LEFT"/>compute_ricci_tensor(metric: Tensor, connection: Optional[Tensor]): Tensor<br ALIGN="LEFT"/>flow_step(metric: Tensor, ricci: Tensor, timestep: float): Tuple[Tensor, Dict[str, Any]]<br ALIGN="LEFT"/>forward(x: Tensor, return_path: bool): Tuple[Tensor, Dict[str, Any]]<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.core.flow.quantum.GeometricFlowAnalyzer" [color="black", fontcolor="black", label=<{GeometricFlowAnalyzer|flow<br ALIGN="LEFT"/>hilbert_space : Optional[HilbertSpace]<br ALIGN="LEFT"/>history : List[QuantumFlowMetrics]<br ALIGN="LEFT"/>preparation_validator<br ALIGN="LEFT"/>state_validator<br ALIGN="LEFT"/>|analyze_evolution(initial_metric: Tensor, num_steps: int, dt: float, points: Optional[Tensor], initial_state: Optional[QuantumState]): Tuple[List[AnalyzerMetrics], Optional[Dict[str, List[float]]]]<br ALIGN="LEFT"/>analyze_step(metric: Tensor, points: Optional[Tensor], timestep: float, quantum_state: Optional[QuantumState]): Tuple[Tensor, AnalyzerMetrics]<br ALIGN="LEFT"/>get_convergence_stats(): Dict[str, float]<br ALIGN="LEFT"/>validate_entanglement(state: QuantumState): EntanglementMetrics<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.core.tiling.config.GeometricFlowConfig" [color="black", fontcolor="black", label=<{GeometricFlowConfig|MAX_DENSITY : float<br ALIGN="LEFT"/>MIN_DENSITY : float<br ALIGN="LEFT"/>MIN_RESOLUTION : float<br ALIGN="LEFT"/>adam_epsilon : float<br ALIGN="LEFT"/>attention_probs_dropout_prob : float<br ALIGN="LEFT"/>curvature_threshold : float<br ALIGN="LEFT"/>dim : int<br ALIGN="LEFT"/>dropout : float<br ALIGN="LEFT"/>entanglement_threshold : float<br ALIGN="LEFT"/>flow_epsilon : float<br ALIGN="LEFT"/>flow_lr : float<br ALIGN="LEFT"/>flow_steps : int<br ALIGN="LEFT"/>hidden_act : str<br ALIGN="LEFT"/>hidden_dropout_prob : float<br ALIGN="LEFT"/>hidden_size : int<br ALIGN="LEFT"/>initializer_range : float<br ALIGN="LEFT"/>intermediate_size : int<br ALIGN="LEFT"/>layer_norm_eps : float<br ALIGN="LEFT"/>layer_norm_eps_geometric : float<br ALIGN="LEFT"/>learning_rate : float<br ALIGN="LEFT"/>max_delta : float<br ALIGN="LEFT"/>max_grad_norm : float<br ALIGN="LEFT"/>max_position_embeddings : int<br ALIGN="LEFT"/>max_position_embeddings_geometric : int<br ALIGN="LEFT"/>measurement_samples : int<br ALIGN="LEFT"/>min_delta : float<br ALIGN="LEFT"/>num_attention_heads : int<br ALIGN="LEFT"/>num_heads : int<br ALIGN="LEFT"/>num_hidden_layers : int<br ALIGN="LEFT"/>quantum_dim : int<br ALIGN="LEFT"/>stability_threshold : float<br ALIGN="LEFT"/>warmup_steps : int<br ALIGN="LEFT"/>weight_decay : float<br ALIGN="LEFT"/>|from_dict(config_dict: Dict[str, Any]): 'GeometricFlowConfig'<br ALIGN="LEFT"/>to_dict(): Dict[str, Any]<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.core.types.GeometricFlowProtocol" [color="black", fontcolor="black", label=<{GeometricFlowProtocol|<br ALIGN="LEFT"/>|compute_metric(x: torch.Tensor): torch.Tensor<br ALIGN="LEFT"/>compute_ricci_tensor(metric: torch.Tensor, connection: Optional[torch.Tensor]): torch.Tensor<br ALIGN="LEFT"/>detect_singularities(flow: torch.Tensor, threshold: float): List[Dict[str, Any]]<br ALIGN="LEFT"/>flow_step(metric: torch.Tensor, ricci: torch.Tensor, timestep: float): Tuple[torch.Tensor, Dict[str, Any]]<br ALIGN="LEFT"/>forward(x: torch.Tensor, return_path: bool): Tuple[torch.Tensor, Dict[str, Any]]<br ALIGN="LEFT"/>normalize_flow(flow: torch.Tensor, normalization: str): torch.Tensor<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.core.flow.protocol.GeometricFlowProtocol" [color="black", fontcolor="black", label=<{GeometricFlowProtocol|<br ALIGN="LEFT"/>|<I>compute_connection</I>(metric: T, points: Optional[T]): T<br ALIGN="LEFT"/><I>compute_curvature</I>(metric: T, connection: Optional[T]): T<br ALIGN="LEFT"/><I>compute_geodesic</I>(start_point: T, end_point: T, num_steps: int): T<br ALIGN="LEFT"/><I>compute_metric</I>(points: T, connection: Optional[T]): T<br ALIGN="LEFT"/><I>compute_ricci_tensor</I>(metric: T, points: Optional[T], connection: Optional[T]): T<br ALIGN="LEFT"/><I>detect_singularities</I>(metric: T, points: Optional[T], threshold: float): List[SingularityInfo[T]]<br ALIGN="LEFT"/><I>flow_step</I>(metric: T, ricci: Optional[T], timestep: float): Tuple[T, FlowMetrics]<br ALIGN="LEFT"/><I>normalize_flow</I>(flow: T, metric: Optional[T], method: str): T<br ALIGN="LEFT"/><I>parallel_transport</I>(vector: T, start_point: T, end_point: T, connection: Optional[T]): T<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.metrics.quantum_geometric_metrics.GeometricMetrics" [color="black", fontcolor="black", label=<{GeometricMetrics|hidden_dim : int<br ALIGN="LEFT"/>manifold_dim : int<br ALIGN="LEFT"/>|compute_curvature(flow_path: torch.Tensor, context: MetricContext): torch.Tensor<br ALIGN="LEFT"/>compute_geodesic_distance(flow_path: torch.Tensor, context: MetricContext): torch.Tensor<br ALIGN="LEFT"/>compute_parallel_transport(vector: torch.Tensor, connection: torch.Tensor, context: MetricContext): torch.Tensor<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.core.attention.geometric.GeometricStructures" [color="black", fontcolor="black", label=<{GeometricStructures|connection : Parameter<br ALIGN="LEFT"/>curvature : float<br ALIGN="LEFT"/>curvature_tensor : Parameter<br ALIGN="LEFT"/>dim : int<br ALIGN="LEFT"/>exp_map : Union[HyperbolicExponential, EuclideanExponential]<br ALIGN="LEFT"/>log_map : Union[HyperbolicLogarithm, EuclideanLogarithm]<br ALIGN="LEFT"/>manifold_type : Literal['hyperbolic', 'euclidean']<br ALIGN="LEFT"/>metric : Parameter<br ALIGN="LEFT"/>num_heads : int<br ALIGN="LEFT"/>parallel_transport_method : Literal['schild', 'pole']<br ALIGN="LEFT"/>transport<br ALIGN="LEFT"/>|compute_exponential_map(x: torch.Tensor, v: torch.Tensor): torch.Tensor<br ALIGN="LEFT"/>compute_geodesic(x: torch.Tensor, v: torch.Tensor, steps: int): torch.Tensor<br ALIGN="LEFT"/>compute_geodesic_distance(x: torch.Tensor, y: torch.Tensor): torch.Tensor<br ALIGN="LEFT"/>compute_logarithmic_map(x: torch.Tensor, y: torch.Tensor): torch.Tensor<br ALIGN="LEFT"/>compute_sectional_curvature(x: torch.Tensor, v1: torch.Tensor, v2: torch.Tensor): torch.Tensor<br ALIGN="LEFT"/>forward(x: torch.Tensor, y: torch.Tensor, v: Optional[torch.Tensor], return_diagnostics: bool): Dict[str, torch.Tensor]<br ALIGN="LEFT"/>parallel_transport_batch(x: torch.Tensor, y: torch.Tensor, v: torch.Tensor): torch.Tensor<br ALIGN="LEFT"/>process_points(x: torch.Tensor, y: torch.Tensor, v: Optional[torch.Tensor], return_diagnostics: bool): Dict[str, torch.Tensor]<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.core.tiling.quantum_geometric_attention.GeometricStructures" [color="black", fontcolor="black", label=<{GeometricStructures|curvature : float<br ALIGN="LEFT"/>dim : int<br ALIGN="LEFT"/>exp_map<br ALIGN="LEFT"/>log_map<br ALIGN="LEFT"/>manifold_type : str<br ALIGN="LEFT"/>parallel_transport_method : str<br ALIGN="LEFT"/>transport<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"src.core.metrics.height_theory.HeightStructure" [color="black", fontcolor="black", label=<{HeightStructure|base_field : str<br ALIGN="LEFT"/>local_heights<br ALIGN="LEFT"/>num_primes : int<br ALIGN="LEFT"/>prime_bases<br ALIGN="LEFT"/>|analyze_growth(points: List[torch.Tensor], window_size: int): Dict[str, torch.Tensor]<br ALIGN="LEFT"/>compute_canonical_height(point: torch.Tensor): torch.Tensor<br ALIGN="LEFT"/>compute_local_height(point: torch.Tensor, prime: int): torch.Tensor<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.core.tiling.patterns.cohomology.HeightStructure" [color="black", fontcolor="black", label=<{HeightStructure|num_primes : int<br ALIGN="LEFT"/>prime_bases<br ALIGN="LEFT"/>|compute_height(coefficients: torch.Tensor): torch.Tensor<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.core.flow.higher_order.HigherOrderFlow" [color="black", fontcolor="black", label=<{HigherOrderFlow|bach_flow_weight : float<br ALIGN="LEFT"/>bach_tensor_net : Sequential<br ALIGN="LEFT"/>calabi_flow_weight : float<br ALIGN="LEFT"/>calabi_net : Sequential<br ALIGN="LEFT"/>cross_curvature_net : Sequential<br ALIGN="LEFT"/>cross_curvature_weight : float<br ALIGN="LEFT"/>fourth_order_net : Sequential<br ALIGN="LEFT"/>fourth_order_weight : float<br ALIGN="LEFT"/>|compute_bach_tensor(metric: Tensor, ricci: Tensor): Tensor<br ALIGN="LEFT"/>compute_calabi_tensor(metric: Tensor, ricci: Tensor): Tensor<br ALIGN="LEFT"/>compute_cross_curvature(metric: Tensor, ricci: Tensor, pattern: Tensor): Tensor<br ALIGN="LEFT"/>compute_fourth_order_term(metric: Tensor, ricci: Tensor): Tensor<br ALIGN="LEFT"/>flow_step(metric: Tensor, ricci: Optional[Tensor], timestep: float): Tuple[Tensor, QuantumFlowMetrics]<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.core.attention.geometric.HyperbolicExponential" [color="black", fontcolor="black", label=<{HyperbolicExponential|curvature : Parameter<br ALIGN="LEFT"/>dim : int<br ALIGN="LEFT"/>eps : float<br ALIGN="LEFT"/>max_norm : float<br ALIGN="LEFT"/>|forward(x: torch.Tensor, v: torch.Tensor): torch.Tensor<br ALIGN="LEFT"/>minkowski_inner(x: torch.Tensor, y: torch.Tensor): torch.Tensor<br ALIGN="LEFT"/>minkowski_norm(v: torch.Tensor): torch.Tensor<br ALIGN="LEFT"/>project_to_hyperboloid(x: torch.Tensor): torch.Tensor<br ALIGN="LEFT"/>project_to_tangent(x: torch.Tensor, v: torch.Tensor): torch.Tensor<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.core.attention.geometric.HyperbolicLogarithm" [color="black", fontcolor="black", label=<{HyperbolicLogarithm|curvature : Parameter<br ALIGN="LEFT"/>dim : int<br ALIGN="LEFT"/>eps : float<br ALIGN="LEFT"/>max_dist : float<br ALIGN="LEFT"/>|forward(x: torch.Tensor, y: torch.Tensor): torch.Tensor<br ALIGN="LEFT"/>minkowski_inner(x: torch.Tensor, y: torch.Tensor): torch.Tensor<br ALIGN="LEFT"/>project_to_hyperboloid(x: torch.Tensor): torch.Tensor<br ALIGN="LEFT"/>project_to_tangent(x: torch.Tensor, v: torch.Tensor): torch.Tensor<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.core.vulkan.resources.ImageResource" [color="black", fontcolor="black", label=<{ImageResource|extent : Any<br ALIGN="LEFT"/>format : int<br ALIGN="LEFT"/>image : int<br ALIGN="LEFT"/>memory<br ALIGN="LEFT"/>view : int<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"src.core.metrics.advanced_metrics.InformationFlowMetrics" [color="black", fontcolor="black", label=<{InformationFlowMetrics|cross_tile_flow : float<br ALIGN="LEFT"/>edge_utilization : float<br ALIGN="LEFT"/>info_density : float<br ALIGN="LEFT"/>pattern_stability : float<br ALIGN="LEFT"/>|compute_ifq(): float<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.core.flow.information_ricci.InformationRicciFlow" [color="black", fontcolor="black", label=<{InformationRicciFlow|potential_net : Sequential<br ALIGN="LEFT"/>stress_energy_net : Sequential<br ALIGN="LEFT"/>stress_energy_weight : float<br ALIGN="LEFT"/>|compute_information_potential(points: Tensor): Tensor<br ALIGN="LEFT"/>compute_potential_hessian(points: Tensor): Tensor<br ALIGN="LEFT"/>compute_stress_energy_tensor(points: Tensor, metric: Tensor): Tensor<br ALIGN="LEFT"/>flow_step(metric: Tensor, ricci: Optional[Tensor], timestep: float): Tuple[Tensor, QuantumFlowMetrics]<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.core.attention.routing.InformationRouter" [color="black", fontcolor="black", label=<{InformationRouter|bottleneck_detector : Sequential<br ALIGN="LEFT"/>bottleneck_threshold : float<br ALIGN="LEFT"/>dim : int<br ALIGN="LEFT"/>exploration_rate : float<br ALIGN="LEFT"/>num_heads : int<br ALIGN="LEFT"/>path_predictor : GRU<br ALIGN="LEFT"/>pattern_dynamics : PatternDynamics<br ALIGN="LEFT"/>route_scorer : Sequential<br ALIGN="LEFT"/>|detect_bottlenecks(states: torch.Tensor, routing_scores: torch.Tensor): tuple[torch.Tensor, torch.Tensor]<br ALIGN="LEFT"/>forward(states: torch.Tensor, return_diagnostics: bool): dict[str, torch.Tensor]<br ALIGN="LEFT"/>optimize_bottlenecks(states: torch.Tensor, bottlenecks: torch.Tensor, impact: torch.Tensor): torch.Tensor<br ALIGN="LEFT"/>predict_optimal_path(states: torch.Tensor, start_idx: torch.Tensor): torch.Tensor<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.infrastructure.base.InfrastructureMetrics" [color="black", fontcolor="black", label=<{InfrastructureMetrics|cpu_metrics : Dict[str, float]<br ALIGN="LEFT"/>memory_metrics : Dict[str, float]<br ALIGN="LEFT"/>parallel_metrics : Dict[str, float]<br ALIGN="LEFT"/>resource_metrics : Dict[str, float]<br ALIGN="LEFT"/>vulkan_metrics : Dict[str, float]<br ALIGN="LEFT"/>|collect(cpu_optimizer: CPUOptimizer, memory_manager: MemoryManager, vulkan_integration: VulkanIntegration, parallel_processor: ParallelProcessor, resource_allocator: ResourceAllocator): Dict[str, Dict[str, float]]<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.infrastructure.metrics.InfrastructureMetrics" [color="black", fontcolor="black", label=<{InfrastructureMetrics|device_info : Dict[str, str]<br ALIGN="LEFT"/>error_log : List[str]<br ALIGN="LEFT"/>performance<br ALIGN="LEFT"/>resources<br ALIGN="LEFT"/>|get_summary(): str<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.core.performance.cpu.algorithms.InstructionCounter" [color="black", fontcolor="black", label=<{InstructionCounter|instruction_counts : Dict[str, int]<br ALIGN="LEFT"/>|get_instruction_count(func: Callable): int<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.core.tiling.patterns.cohomology.Integration" [color="black", fontcolor="black", label=<{Integration|manifold<br ALIGN="LEFT"/>|apply_stokes(form: ArithmeticForm, domain: torch.Tensor): torch.Tensor<br ALIGN="LEFT"/>integrate_form(form: ArithmeticForm, domain: torch.Tensor): torch.Tensor<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.core.metrics.evolution.LFunctionComputation" [color="black", fontcolor="black", label=<{LFunctionComputation|hidden_dim : int<br ALIGN="LEFT"/>network : Sequential<br ALIGN="LEFT"/>num_factors : int<br ALIGN="LEFT"/>rank : int<br ALIGN="LEFT"/>|compute_l_values(pattern: torch.Tensor): torch.Tensor<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.core.models.base.LayerGeometry" [color="black", fontcolor="black", label=<{LayerGeometry|connection_coeffs : Parameter<br ALIGN="LEFT"/>manifold_dim : int<br ALIGN="LEFT"/>metric_tensor : Parameter<br ALIGN="LEFT"/>pattern_dim : NoneType<br ALIGN="LEFT"/>|connection(points: torch.Tensor): torch.Tensor<br ALIGN="LEFT"/>get_riemannian_framework(points: torch.Tensor): PatternRiemannianStructure<br ALIGN="LEFT"/>metric(points: torch.Tensor): torch.Tensor<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.core.models.base.LayerGeometryDict" [color="black", fontcolor="black", label=<{LayerGeometryDict|<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"src.metrics.load_analyzer.LoadBalanceAnalyzer" [color="black", fontcolor="black", label=<{LoadBalanceAnalyzer|history<br ALIGN="LEFT"/>overload_threshold : float<br ALIGN="LEFT"/>underload_threshold : float<br ALIGN="LEFT"/>variance_threshold : float<br ALIGN="LEFT"/>|add_metrics(metrics: dict): None<br ALIGN="LEFT"/>analyze_network(tiles: list[AttentionTile]): dict[str, Any]<br ALIGN="LEFT"/>get_convergence_rate(): float<br ALIGN="LEFT"/>get_load_distribution(): tuple[float, float, float]<br ALIGN="LEFT"/>get_recommendations(tiles: list[AttentionTile]): list[str]<br ALIGN="LEFT"/>get_stability_score(): float<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.core.tiling.quantum_attention_tile.LoadBalancer" [color="black", fontcolor="black", label=<{LoadBalancer|loads<br ALIGN="LEFT"/>num_tiles : int<br ALIGN="LEFT"/>|balance(): List[int]<br ALIGN="LEFT"/>get_load(tile_idx: int): LoadProfile<br ALIGN="LEFT"/>update_load(tile_idx: int, load: LoadProfile)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.core.tiling.quantum_attention_tile.LoadProfile" [color="black", fontcolor="black", label=<{LoadProfile|compute : float<br ALIGN="LEFT"/>io : float<br ALIGN="LEFT"/>memory : float<br ALIGN="LEFT"/>|total(): float<br ALIGN="LEFT"/>weighted(compute_weight: float, memory_weight: float, io_weight: float): float<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.core.patterns.fiber_types.LocalChart" [color="black", fontcolor="black", label=<{LocalChart|coordinates : T<br ALIGN="LEFT"/>dimension : int<br ALIGN="LEFT"/>transition_maps : dict<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"src.core.performance.cpu.algorithms.LoopOptimizer" [color="black", fontcolor="black", label=<{LoopOptimizer|loop_stats : Dict[str, Dict[str, int]]<br ALIGN="LEFT"/>unroll_threshold : int<br ALIGN="LEFT"/>|fuse_loops(operations: List[Callable[[T], T]], data: T): T<br ALIGN="LEFT"/>unroll(loop_id: str, iterations: int, operation: Callable[[int], T]): List[T]<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.core.vulkan.memory.MemoryBlock" [color="black", fontcolor="black", label=<{MemoryBlock|memory : Any<br ALIGN="LEFT"/>offset : int<br ALIGN="LEFT"/>size : int<br ALIGN="LEFT"/>type_index : int<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"src.core.performance.memory_base.MemoryError" [color="black", fontcolor="red", label=<{MemoryError|<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"src.infrastructure.base.MemoryManager" [color="black", fontcolor="black", label=<{MemoryManager|pool_size : int<br ALIGN="LEFT"/>|cleanup()<br ALIGN="LEFT"/>get_memory_stats(): MemoryStats<br ALIGN="LEFT"/>manage_tensor(tensor: torch.Tensor): torch.Tensor<br ALIGN="LEFT"/>optimize()<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.infrastructure.memory_manager.MemoryManager" [color="black", fontcolor="black", label=<{MemoryManager|allocated : int<br ALIGN="LEFT"/>pool_size : int<br ALIGN="LEFT"/>pools : Dict[str, Any]<br ALIGN="LEFT"/>|allocate(size: int, dtype: np.dtype): Optional[np.ndarray]<br ALIGN="LEFT"/>clear_pools(): None<br ALIGN="LEFT"/>deallocate(array: np.ndarray): None<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.core.performance.cpu.memory.MemoryManager" [color="black", fontcolor="black", label=<{MemoryManager|cache_optimizer<br ALIGN="LEFT"/>enable_monitoring : bool<br ALIGN="LEFT"/>pool<br ALIGN="LEFT"/>stats : List[MemoryStats]<br ALIGN="LEFT"/>|allocate(shape: Tuple[int, ...], dtype: torch.dtype): torch.Tensor<br ALIGN="LEFT"/>clear_metrics(): None<br ALIGN="LEFT"/>clear_stats(): None<br ALIGN="LEFT"/>create_pool(size: int): MemoryPool<br ALIGN="LEFT"/>get_memory_stats(): List[MemoryStats]<br ALIGN="LEFT"/>optimize_tensor(tensor: torch.Tensor, access_pattern: str): torch.Tensor<br ALIGN="LEFT"/>release_tensor(tensor: torch.Tensor): None<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.core.performance.cpu.memory_management.MemoryManager" [color="black", fontcolor="black", label=<{MemoryManager|<br ALIGN="LEFT"/>|allocate_tensor(size: Tuple[int, ...]): torch.Tensor<br ALIGN="LEFT"/>get_allocated_memory(): int<br ALIGN="LEFT"/>get_fragmentation_ratio(): float<br ALIGN="LEFT"/>get_peak_memory(): int<br ALIGN="LEFT"/>inplace_operation(tensor: torch.Tensor, operation: Callable[[torch.Tensor], None]): None<br ALIGN="LEFT"/>optimized_matmul(x: torch.Tensor, y: torch.Tensor): torch.Tensor<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.core.performance.memory_base.MemoryManagerBase" [color="black", fontcolor="black", label=<{MemoryManagerBase|<br ALIGN="LEFT"/>|<I>allocate_tensor</I>(size: Union[Tuple[int, ...], torch.Size], dtype: Any): Any<br ALIGN="LEFT"/><I>cleanup</I>(): None<br ALIGN="LEFT"/><I>copy_from_device</I>(src: Any, dst: Any): None<br ALIGN="LEFT"/><I>copy_to_device</I>(src: Any, dst: Any): None<br ALIGN="LEFT"/><I>free_tensor</I>(tensor: Any): None<br ALIGN="LEFT"/>get_allocated_memory(): int<br ALIGN="LEFT"/>get_fragmentation_ratio(): float<br ALIGN="LEFT"/>get_metrics(): List[MemoryMetrics]<br ALIGN="LEFT"/>get_peak_memory(): int<br ALIGN="LEFT"/>record_metric(operation_type: str): None<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.core.performance.memory_base.MemoryMetrics" [color="black", fontcolor="black", label=<{MemoryMetrics|allocated_memory : int<br ALIGN="LEFT"/>fragmentation_ratio : float<br ALIGN="LEFT"/>operation_type : str<br ALIGN="LEFT"/>peak_memory : int<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"src.core.performance.cpu.memory_management.MemoryMetrics" [color="black", fontcolor="black", label=<{MemoryMetrics|allocated_memory : int<br ALIGN="LEFT"/>fragmentation_ratio : float<br ALIGN="LEFT"/>operation_type : str<br ALIGN="LEFT"/>peak_memory : int<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"src.utils.memory_management.MemoryOptimizer" [color="black", fontcolor="black", label=<{MemoryOptimizer|tensor_manager<br ALIGN="LEFT"/>|clear_memory(): None<br ALIGN="LEFT"/>get_memory_stats(): Dict[str, Any]<br ALIGN="LEFT"/>optimize(operation: str)<br ALIGN="LEFT"/>set_max_memory_usage(size_bytes: int): None<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.core.performance.cpu.memory.MemoryPool" [color="black", fontcolor="black", label=<{MemoryPool|current_size : int<br ALIGN="LEFT"/>max_size : int<br ALIGN="LEFT"/>pools : Dict[Tuple[int, ...], List[torch.Tensor]]<br ALIGN="LEFT"/>stats : defaultdict<br ALIGN="LEFT"/>|acquire(shape: Tuple[int, ...], dtype: torch.dtype): torch.Tensor<br ALIGN="LEFT"/>release(tensor: torch.Tensor): None<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.core.vulkan.resources.MemoryRequirements" [color="black", fontcolor="black", label=<{MemoryRequirements|alignment : int<br ALIGN="LEFT"/>memory_type_bits : int<br ALIGN="LEFT"/>size : int<br ALIGN="LEFT"/>|from_vulkan(vulkan_reqs: VkMemoryRequirements): 'MemoryRequirements'<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.infrastructure.base.MemoryStats" [color="black", fontcolor="black", label=<{MemoryStats|active_blocks : int<br ALIGN="LEFT"/>peak_allocated : int<br ALIGN="LEFT"/>total_allocated : int<br ALIGN="LEFT"/>total_cached : int<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"src.core.performance.cpu.memory.MemoryStats" [color="black", fontcolor="black", label=<{MemoryStats|access_pattern : str<br ALIGN="LEFT"/>allocation_size : int<br ALIGN="LEFT"/>cache_hits : int<br ALIGN="LEFT"/>fragmentation : float<br ALIGN="LEFT"/>pool_hits : int<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"src.metrics.quantum_geometric_metrics.MetricContext" [color="black", fontcolor="black", label=<{MetricContext|batch_size : int<br ALIGN="LEFT"/>device : device<br ALIGN="LEFT"/>hidden_dim : int<br ALIGN="LEFT"/>resolution : float<br ALIGN="LEFT"/>sequence_length : int<br ALIGN="LEFT"/>timestamp : float<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"src.metrics.quantum_geometric_metrics.MetricDomain" [color="black", fontcolor="black", label=<{MetricDomain|name<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"src.core.patterns.riemannian_base.MetricTensor" [color="black", fontcolor="black", label=<{MetricTensor|dimension : int<br ALIGN="LEFT"/>is_compatible : bool<br ALIGN="LEFT"/>values : T<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"src.metrics.metrics_tracker.MetricsTracker" [color="black", fontcolor="black", label=<{MetricsTracker|num_runs : int<br ALIGN="LEFT"/>total_flops : int<br ALIGN="LEFT"/>total_memory : int<br ALIGN="LEFT"/>total_time : int<br ALIGN="LEFT"/>|compute_metrics(model: nn.Module, input_tensor: torch.Tensor, output_tensor: torch.Tensor): Dict[str, float]<br ALIGN="LEFT"/>reset()<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.core.models.base.ModelGeometry" [color="black", fontcolor="black", label=<{ModelGeometry|attention_heads : ModuleList<br ALIGN="LEFT"/>key_dim : int<br ALIGN="LEFT"/>layers<br ALIGN="LEFT"/>manifold_dim : int<br ALIGN="LEFT"/>query_dim : int<br ALIGN="LEFT"/>|add_attention_head(head: nn.Module)<br ALIGN="LEFT"/>add_layer(name: str, layer: LayerGeometry)<br ALIGN="LEFT"/>get_attention_head(idx: int): nn.Module<br ALIGN="LEFT"/>get_layer(name: str): LayerGeometry<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.core.tiling.arithmetic_dynamics.ModularFormComputer" [color="black", fontcolor="black", label=<{ModularFormComputer|coeff_net : Sequential<br ALIGN="LEFT"/>hidden_dim : int<br ALIGN="LEFT"/>level : int<br ALIGN="LEFT"/>num_coeffs : int<br ALIGN="LEFT"/>symmetry_net : Sequential<br ALIGN="LEFT"/>weight : int<br ALIGN="LEFT"/>|compute_q_expansion(x: torch.Tensor): torch.Tensor<br ALIGN="LEFT"/>compute_symmetries(x: torch.Tensor): Dict[str, torch.Tensor]<br ALIGN="LEFT"/>forward(x: torch.Tensor): Tuple[torch.Tensor, Dict[str, Any]]<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.core.patterns.motivic_riemannian.MotivicChristoffelSymbols" [color="black", fontcolor="black", label=<{MotivicChristoffelSymbols|dynamics<br ALIGN="LEFT"/>dynamics_state<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"src.core.tiling.patterns.cohomology.MotivicCohomology" [color="black", fontcolor="black", label=<{MotivicCohomology|base_space<br ALIGN="LEFT"/>dynamics<br ALIGN="LEFT"/>height_structure<br ALIGN="LEFT"/>hidden_dim : int<br ALIGN="LEFT"/>metrics<br ALIGN="LEFT"/>motive_rank : int<br ALIGN="LEFT"/>num_primes : int<br ALIGN="LEFT"/>|compute_motive(form: ArithmeticForm): torch.Tensor<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.core.patterns.motivic_riemannian.MotivicCurvatureTensor" [color="black", fontcolor="black", label=<{MotivicCurvatureTensor|cohomology_class<br ALIGN="LEFT"/>motive<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"src.core.patterns.motivic_integration.MotivicIntegrationSystem" [color="black", fontcolor="black", label=<{MotivicIntegrationSystem|cache : Dict[str, Any]<br ALIGN="LEFT"/>cohomology<br ALIGN="LEFT"/>device : device<br ALIGN="LEFT"/>dtype : Ellipsis<br ALIGN="LEFT"/>dynamics<br ALIGN="LEFT"/>geometry<br ALIGN="LEFT"/>hidden_dim : int<br ALIGN="LEFT"/>integrator<br ALIGN="LEFT"/>manifold_dim : int<br ALIGN="LEFT"/>monte_carlo_steps : int<br ALIGN="LEFT"/>motive_rank : int<br ALIGN="LEFT"/>num_primes : int<br ALIGN="LEFT"/>num_samples : int<br ALIGN="LEFT"/>|compute_integral(pattern: Tensor, with_quantum: bool): Tuple[Tensor, Dict[str, Any]]<br ALIGN="LEFT"/>compute_measure(pattern: Tensor, with_quantum: bool): Tuple[Tensor, Dict[str, Any]]<br ALIGN="LEFT"/>compute_stability_metrics(pattern: Tensor, num_perturbations: int, perturbation_scale: float): Dict[str, float]<br ALIGN="LEFT"/>evolve_integral(pattern: Tensor, time_steps: int, with_quantum: bool): Tuple[List[Tensor], Dict[str, Any]]<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.core.tiling.arithmetic_dynamics.MotivicIntegrator" [color="black", fontcolor="black", label=<{MotivicIntegrator|domain_net : Sequential<br ALIGN="LEFT"/>hidden_dim : int<br ALIGN="LEFT"/>measure_net : Sequential<br ALIGN="LEFT"/>monte_carlo_steps : int<br ALIGN="LEFT"/>motive_rank : int<br ALIGN="LEFT"/>num_samples : int<br ALIGN="LEFT"/>|compute_domain(x: torch.Tensor): Tuple[torch.Tensor, torch.Tensor]<br ALIGN="LEFT"/>compute_measure(x: torch.Tensor): torch.Tensor<br ALIGN="LEFT"/>forward(x: torch.Tensor): Tuple[torch.Tensor, Dict[str, Any]]<br ALIGN="LEFT"/>monte_carlo_integrate(measure: torch.Tensor, lower: torch.Tensor, upper: torch.Tensor): torch.Tensor<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.core.patterns.motivic_riemannian.MotivicMetricTensor" [color="black", fontcolor="black", label=<{MotivicMetricTensor|height_data<br ALIGN="LEFT"/>height_structure<br ALIGN="LEFT"/>|with_height(new_values: Tensor): 'MotivicMetricTensor'<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.core.patterns.motivic_riemannian.MotivicRiemannianStructure" [color="black", fontcolor="black", label=<{MotivicRiemannianStructure|cache : Dict[str, Any]<br ALIGN="LEFT"/>connection_coeffs : Parameter<br ALIGN="LEFT"/>connection_map : Linear<br ALIGN="LEFT"/>device : device<br ALIGN="LEFT"/>dtype : Ellipsis<br ALIGN="LEFT"/>dynamics<br ALIGN="LEFT"/>fiber_map : Linear<br ALIGN="LEFT"/>height_structure<br ALIGN="LEFT"/>hidden_dim : int<br ALIGN="LEFT"/>manifold_dim : int<br ALIGN="LEFT"/>metric_factors : Parameter<br ALIGN="LEFT"/>motive<br ALIGN="LEFT"/>motive_rank : int<br ALIGN="LEFT"/>|bundle_projection(total_space: Tensor): Tensor<br ALIGN="LEFT"/>compute_christoffel(points: Tensor): MotivicChristoffelSymbols<br ALIGN="LEFT"/>compute_curvature(points: Tensor, christoffel: Optional[MotivicChristoffelSymbols]): MotivicCurvatureTensor<br ALIGN="LEFT"/>compute_metric(points: Tensor): MotivicMetricTensor<br ALIGN="LEFT"/>connection_form(tangent_vector: Tensor): Tensor<br ALIGN="LEFT"/>get_connection(point: Tensor): Tensor<br ALIGN="LEFT"/>get_fiber(point: Tensor): Tensor<br ALIGN="LEFT"/>local_trivialization(point: Tensor): Tuple[LocalChart[Tensor], FiberChart[Tensor, str]]<br ALIGN="LEFT"/>parallel_transport(section: Tensor, path: Tensor): Tensor<br ALIGN="LEFT"/>transition_functions(chart1: LocalChart[Tensor], chart2: LocalChart[Tensor]): Tensor<br ALIGN="LEFT"/>validate_connection_properties(connection: MotivicChristoffelSymbols): bool<br ALIGN="LEFT"/>validate_metric_properties(metric: MotivicMetricTensor): bool<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.core.patterns.motivic_integration.MotivicRiemannianStructureImpl" [color="black", fontcolor="black", label=<{MotivicRiemannianStructureImpl|hidden_dim : int<br ALIGN="LEFT"/>motive_rank : int<br ALIGN="LEFT"/>num_primes : int<br ALIGN="LEFT"/>structure<br ALIGN="LEFT"/>|compute_riemann(points: Tensor): CurvatureTensor[Tensor]<br ALIGN="LEFT"/>exp_map(point: Tensor, vector: Tensor): Tensor<br ALIGN="LEFT"/>forward(): Any<br ALIGN="LEFT"/>geodesic_flow(initial_point: Tensor, initial_velocity: Tensor, steps: int, step_size: float): Tuple[Tensor, Tensor]<br ALIGN="LEFT"/>get_christoffel_values(points: Tensor): Tensor<br ALIGN="LEFT"/>get_metric_tensor(points: Tensor): Tensor<br ALIGN="LEFT"/>get_riemann_tensor(points: Tensor): Tensor<br ALIGN="LEFT"/>lie_derivative_metric(point: Tensor, vector_field: Callable[[Tensor], Tensor]): MotivicMetricTensor<br ALIGN="LEFT"/>sectional_curvature(point: Tensor, v1: Tensor, v2: Tensor): Union[float, Tensor]<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.core.flow.neural.NeuralGeometricFlow" [color="black", fontcolor="black", label=<{NeuralGeometricFlow|fisher_net : Sequential<br ALIGN="LEFT"/>fisher_rao_weight : float<br ALIGN="LEFT"/>phase_tracking_enabled : bool<br ALIGN="LEFT"/>quantum_bridge : NeuralQuantumBridge<br ALIGN="LEFT"/>quantum_correction_net : Sequential<br ALIGN="LEFT"/>quantum_correction_strength : float<br ALIGN="LEFT"/>quantum_weight : float<br ALIGN="LEFT"/>|compute_fisher_rao_metric(points: Tensor): Tensor<br ALIGN="LEFT"/>compute_metric(points: Tensor, connection: Optional[Tensor]): Tensor<br ALIGN="LEFT"/>compute_quantum_corrections(state: QuantumState, metric: Tensor): Tensor<br ALIGN="LEFT"/>flow_step(metric: Tensor, ricci: Optional[Tensor], timestep: float): Tuple[Tensor, QuantumFlowMetrics]<br ALIGN="LEFT"/>parallel_transport(vector: Tensor, start_point: Tensor, end_point: Tensor, connection: Optional[Tensor]): Tensor<br ALIGN="LEFT"/>prepare_quantum_state(points: Tensor, return_validation: bool): Union[QuantumState, Tuple[QuantumState, QuantumStateValidationResult]]<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.core.performance.cpu.algorithms.NumericalOptimizer" [color="black", fontcolor="black", label=<{NumericalOptimizer|enable_mixed_precision : bool<br ALIGN="LEFT"/>numerical_stats : Dict[str, float]<br ALIGN="LEFT"/>stability_threshold : float<br ALIGN="LEFT"/>|optimize_precision(tensor: torch.Tensor, operation_id: str): torch.Tensor<br ALIGN="LEFT"/>stable_softmax(x: torch.Tensor, dim: int): torch.Tensor<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.core.patterns.operadic_structure.OperadicComposition" [color="black", fontcolor="black", label=<{OperadicComposition|<br ALIGN="LEFT"/>|<I>compose</I>(operations: List[OperadicOperation]): OperadicOperation<br ALIGN="LEFT"/><I>create_operation</I>(source_dim: int, target_dim: int, preserve_structure: Optional[str]): OperadicOperation<br ALIGN="LEFT"/><I>natural_transformation</I>(source_op: OperadicOperation, target_op: OperadicOperation): Tensor<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.core.patterns.operadic_structure.OperadicOperation" [color="black", fontcolor="black", label=<{OperadicOperation|composition_law : Tensor<br ALIGN="LEFT"/>enrichment : Optional[Dict[str, Any]]<br ALIGN="LEFT"/>natural_transformation : Optional[Dict[str, Any]]<br ALIGN="LEFT"/>source_dim : int<br ALIGN="LEFT"/>target_dim : int<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"src.core.patterns.operadic_handler.OperadicStructureHandler" [color="black", fontcolor="black", label=<{OperadicStructureHandler|base_dim : int<br ALIGN="LEFT"/>device : device<br ALIGN="LEFT"/>dtype : Ellipsis<br ALIGN="LEFT"/>hidden_dim : int<br ALIGN="LEFT"/>motive_rank : int<br ALIGN="LEFT"/>motivic<br ALIGN="LEFT"/>operad<br ALIGN="LEFT"/>operation_cache : Dict[Tuple[int, int], OperadicOperation]<br ALIGN="LEFT"/>preserve_metric : bool<br ALIGN="LEFT"/>preserve_symplectic : bool<br ALIGN="LEFT"/>|compose_operations(operations: List[OperadicOperation], with_motivic: bool): Tuple[OperadicOperation, Dict[str, Any]]<br ALIGN="LEFT"/>create_natural_transformation(source_op: OperadicOperation, target_op: OperadicOperation, with_cohomology: bool): Tuple[Tensor, Dict[str, Any]]<br ALIGN="LEFT"/>create_operation(source_dim: int, target_dim: int, preserve_structure: Optional[str], use_cache: bool): OperadicOperation<br ALIGN="LEFT"/>forward(): Any<br ALIGN="LEFT"/>handle_dimension_transition(tensor: Tensor, source_dim: int, target_dim: int, preserve_structure: Optional[str]): Tuple[Tensor, Dict[str, Any]]<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.core.benchmarks.metrics.OperationMetrics" [color="black", fontcolor="black", label=<{OperationMetrics|accuracy : Optional[float]<br ALIGN="LEFT"/>avg_memory : float<br ALIGN="LEFT"/>avg_time : float<br ALIGN="LEFT"/>batch_size : Optional[int]<br ALIGN="LEFT"/>batch_time : Optional[float]<br ALIGN="LEFT"/>convergence_rate : Optional[float]<br ALIGN="LEFT"/>efficiency : Optional[float]<br ALIGN="LEFT"/>name : str<br ALIGN="LEFT"/>sequential_time : Optional[float]<br ALIGN="LEFT"/>size : int<br ALIGN="LEFT"/>stability : Optional[float]<br ALIGN="LEFT"/>throughput : float<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"src.infrastructure.base.MemoryManager.optimize.OptimizeContext" [color="black", fontcolor="black", label=<{OptimizeContext|<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"src.core.metrics.evolution.OrbitAnalysis" [color="black", fontcolor="black", label=<{OrbitAnalysis|hidden_dim : int<br ALIGN="LEFT"/>history : List[torch.Tensor]<br ALIGN="LEFT"/>orbit_dim : int<br ALIGN="LEFT"/>projection : Linear<br ALIGN="LEFT"/>|analyze_orbit(pattern: torch.Tensor): Dict[str, float]<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.infrastructure.base.ParallelProcessor" [color="black", fontcolor="black", label=<{ParallelProcessor|num_threads : int<br ALIGN="LEFT"/>|get_stats(): Dict[str, float]<br ALIGN="LEFT"/>merge_results(results: List[torch.Tensor]): torch.Tensor<br ALIGN="LEFT"/>partition_data(data: torch.Tensor): List[torch.Tensor]<br ALIGN="LEFT"/>process_parallel(func: Callable, chunks: List[torch.Tensor]): List[torch.Tensor]<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.infrastructure.parallel.ParallelProcessor" [color="black", fontcolor="black", label=<{ParallelProcessor|device : str<br ALIGN="LEFT"/>num_processes<br ALIGN="LEFT"/>num_threads<br ALIGN="LEFT"/>process_pool : Pool<br ALIGN="LEFT"/>thread_pool : ThreadPoolExecutor<br ALIGN="LEFT"/>|batch_process(func: Callable, data: torch.Tensor, batch_size: int, use_processes: bool): List[torch.Tensor]<br ALIGN="LEFT"/>cleanup()<br ALIGN="LEFT"/>parallel_execute(funcs: List[Callable], use_processes: bool): List[Any]<br ALIGN="LEFT"/>parallel_map(func: Callable, data: List[Any], use_processes: bool): List[Any]<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.core.attention.geometric.ParallelTransport" [color="black", fontcolor="black", label=<{ParallelTransport|dim : int<br ALIGN="LEFT"/>method : Literal['schild', 'pole']<br ALIGN="LEFT"/>|forward(v: torch.Tensor, x: torch.Tensor, y: torch.Tensor, connection: Optional[torch.Tensor]): torch.Tensor<br ALIGN="LEFT"/>pole_ladder(v: torch.Tensor, x: torch.Tensor, y: torch.Tensor): torch.Tensor<br ALIGN="LEFT"/>schild_ladder(v: torch.Tensor, x: torch.Tensor, y: torch.Tensor, connection: Optional[torch.Tensor]): torch.Tensor<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.core.tiling.optimization.parameter_manager.ParameterMonitor" [color="black", fontcolor="black", label=<{ParameterMonitor|gradient_history : Dict[str, List[torch.Tensor]]<br ALIGN="LEFT"/>parameter_history : Dict[str, List[torch.Tensor]]<br ALIGN="LEFT"/>window_size : int<br ALIGN="LEFT"/>|get_statistics(name: str): Dict[str, torch.Tensor]<br ALIGN="LEFT"/>update(name: str, param: nn.Parameter)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.core.tiling.quantum_geometric_attention.PatternDynamics" [color="black", fontcolor="black", label=<{PatternDynamics|adaptation_rate : float<br ALIGN="LEFT"/>dim : int<br ALIGN="LEFT"/>num_heads : int<br ALIGN="LEFT"/>num_patterns : int<br ALIGN="LEFT"/>pattern_scores : Parameter<br ALIGN="LEFT"/>patterns : Parameter<br ALIGN="LEFT"/>temperature : float<br ALIGN="LEFT"/>|update_patterns(x: torch.Tensor): torch.Tensor<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.core.patterns.dynamics.PatternDynamics" [color="black", fontcolor="black", label=<{PatternDynamics|device : device<br ALIGN="LEFT"/>dt : float<br ALIGN="LEFT"/>|<I>compute_conserved_quantities</I>(state: torch.Tensor): Dict[str, torch.Tensor]<br ALIGN="LEFT"/><I>compute_energy</I>(state: torch.Tensor): Dict[str, torch.Tensor]<br ALIGN="LEFT"/><I>compute_flow</I>(state: torch.Tensor): torch.Tensor<br ALIGN="LEFT"/><I>evolve</I>(state: torch.Tensor, time: float): torch.Tensor<br ALIGN="LEFT"/>evolve_pattern_field(pattern: torch.Tensor, field_operator: Optional[torch.Tensor]): Tuple[torch.Tensor, Dict[str, Any]]<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.core.patterns.evolution.PatternEvolution" [color="black", fontcolor="black", label=<{PatternEvolution|enriched<br ALIGN="LEFT"/>framework<br ALIGN="LEFT"/>learning_rate : float<br ALIGN="LEFT"/>momentum : float<br ALIGN="LEFT"/>operadic<br ALIGN="LEFT"/>preserve_structure : bool<br ALIGN="LEFT"/>symplectic<br ALIGN="LEFT"/>velocity : NoneType<br ALIGN="LEFT"/>wave_enabled : bool<br ALIGN="LEFT"/>|compute_hamiltonian(pattern: torch.Tensor, momentum: torch.Tensor): torch.Tensor<br ALIGN="LEFT"/>reset()<br ALIGN="LEFT"/>step(pattern: torch.Tensor, gradient: torch.Tensor, mask: Optional[torch.Tensor], return_metrics: bool): Tuple[torch.Tensor, torch.Tensor]<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.core.patterns.evolution.PatternEvolutionMetrics" [color="black", fontcolor="black", label=<{PatternEvolutionMetrics|geometric_flow : Tensor<br ALIGN="LEFT"/>momentum_norm : float<br ALIGN="LEFT"/>quantum_metric : Tensor<br ALIGN="LEFT"/>symplectic_invariant : float<br ALIGN="LEFT"/>velocity_norm : float<br ALIGN="LEFT"/>wave_energy : float<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"src.core.tiling.patterns.pattern_fiber_bundle.PatternFiberBundle" [color="black", fontcolor="black", label=<{PatternFiberBundle|basis_matrices<br ALIGN="LEFT"/>device : device<br ALIGN="LEFT"/>fiber_metric<br ALIGN="LEFT"/>fiber_transition<br ALIGN="LEFT"/>fiber_type_manager<br ALIGN="LEFT"/>geometric_flow<br ALIGN="LEFT"/>height_structure<br ALIGN="LEFT"/>operadic<br ALIGN="LEFT"/>pattern_dynamics<br ALIGN="LEFT"/>pattern_evolution<br ALIGN="LEFT"/>pattern_formation<br ALIGN="LEFT"/>riemannian_framework<br ALIGN="LEFT"/>symplectic<br ALIGN="LEFT"/>transition<br ALIGN="LEFT"/>wave<br ALIGN="LEFT"/>|compute_cohomology(point: Tensor): Tensor<br ALIGN="LEFT"/>compute_connection(tangent_vector: Tensor, connection_type: str): Tensor<br ALIGN="LEFT"/>compute_curvature(): CurvatureTensor<br ALIGN="LEFT"/>compute_holonomy_algebra(holonomies: List[Tensor]): Tensor<br ALIGN="LEFT"/>compute_holonomy_group(holonomies: List[Tensor]): Tensor<br ALIGN="LEFT"/>compute_metric(points: torch.Tensor): MotivicMetricTensor<br ALIGN="LEFT"/>compute_stability(point: Tensor): Dict[str, Any]<br ALIGN="LEFT"/>connection_form(tangent_vector: Tensor): Tensor<br ALIGN="LEFT"/>construct_bundle(structure_group: str, fiber_type: str, base_manifold: Optional[str]): None<br ALIGN="LEFT"/>convert_fiber_type(section: Tensor, target_type: str): Tensor<br ALIGN="LEFT"/>local_trivialization(point: Tensor): Tuple[LocalChart[Tensor], FiberChart[Tensor, str]]<br ALIGN="LEFT"/>parallel_transport(section: Tensor, path: Tensor): Tensor<br ALIGN="LEFT"/>set_fiber_type(fiber_type: str): None<br ALIGN="LEFT"/>structure_group_action(point: Tensor, group_element: Tensor): Tensor<br ALIGN="LEFT"/>to(device: torch.device): 'PatternFiberBundle'<br ALIGN="LEFT"/>validate_connection(connection: ChristoffelSymbols): bool<br ALIGN="LEFT"/>validate_fiber_type(section: Tensor): bool<br ALIGN="LEFT"/>validate_metric(metric: MetricTensor): bool<br ALIGN="LEFT"/>with_tensor_state(tensor: Tensor, target: Optional[Tensor]): TensorStateContext<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.core.patterns.formation.PatternFormation" [color="black", fontcolor="black", label=<{PatternFormation|diffusion_coeff : float<br ALIGN="LEFT"/>diffusion_kernel<br ALIGN="LEFT"/>dim : int<br ALIGN="LEFT"/>dt : float<br ALIGN="LEFT"/>enriched<br ALIGN="LEFT"/>operadic<br ALIGN="LEFT"/>preserve_structure : bool<br ALIGN="LEFT"/>reaction_coeff : float<br ALIGN="LEFT"/>symplectic<br ALIGN="LEFT"/>wave_enabled : bool<br ALIGN="LEFT"/>|compute_energy(pattern: torch.Tensor): torch.Tensor<br ALIGN="LEFT"/>compute_stability(pattern: torch.Tensor): Dict[str, Any]<br ALIGN="LEFT"/>evolve(pattern: torch.Tensor, time_steps: int): torch.Tensor<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.core.flow.pattern.PatternFormationFlow" [color="black", fontcolor="black", label=<{PatternFormationFlow|arithmetic<br ALIGN="LEFT"/>control_net : Sequential<br ALIGN="LEFT"/>diffusion_net : Sequential<br ALIGN="LEFT"/>diffusion_strength : float<br ALIGN="LEFT"/>operadic<br ALIGN="LEFT"/>pattern_dynamics<br ALIGN="LEFT"/>pattern_evolution<br ALIGN="LEFT"/>pattern_formation<br ALIGN="LEFT"/>reaction_net : Sequential<br ALIGN="LEFT"/>reaction_strength : float<br ALIGN="LEFT"/>stability_net : Sequential<br ALIGN="LEFT"/>symplectic<br ALIGN="LEFT"/>transition<br ALIGN="LEFT"/>wave<br ALIGN="LEFT"/>|analyze_pattern_stability(points: Tensor, time_window: int): Dict[str, Union[Dict[str, Tensor], Tensor]]<br ALIGN="LEFT"/>apply_control(points: Tensor, target: Tensor, control_strength: float, timestep: float): Tuple[Tensor, Dict[str, Tensor]]<br ALIGN="LEFT"/>compute_connection(metric: Tensor, points: Optional[Tensor]): Tensor<br ALIGN="LEFT"/>compute_control_signal(current_state: Tensor, target_state: Tensor, control_strength: float): Tensor<br ALIGN="LEFT"/>compute_geodesic(start_point: Tensor, end_point: Tensor, num_steps: int): Tensor<br ALIGN="LEFT"/>compute_metric(points: Tensor, connection: Optional[Tensor]): Tensor<br ALIGN="LEFT"/>compute_ricci_tensor(metric: Tensor, points: Optional[Tensor], connection: Optional[Tensor]): Tensor<br ALIGN="LEFT"/>compute_stability_metrics(points: Tensor, metric: Optional[Tensor]): Dict[str, Tensor]<br ALIGN="LEFT"/>detect_bifurcations(points: Tensor, parameter: Tensor, threshold: float): List[float]<br ALIGN="LEFT"/>flow_step(metric: Tensor, ricci: Optional[Tensor], timestep: float): Tuple[Tensor, FlowMetrics]<br ALIGN="LEFT"/>parallel_transport(vector: Tensor, start_point: Tensor, end_point: Tensor, connection: Optional[Tensor]): Tensor<br ALIGN="LEFT"/>predict_stability(points: Tensor, metric: Optional[Tensor], connection: Optional[Tensor], ricci: Optional[Tensor]): Dict[str, Tensor]<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.core.flow.pattern_heat.PatternHeatFlow" [color="black", fontcolor="black", label=<{PatternHeatFlow|heat_diffusion_weight : float<br ALIGN="LEFT"/>pattern_net : Sequential<br ALIGN="LEFT"/>|compute_laplace_beltrami(pattern: Tensor, metric: Tensor): Tensor<br ALIGN="LEFT"/>compute_pattern_gradient(pattern: Tensor, metric: Tensor): Tensor<br ALIGN="LEFT"/>evolve_pattern(pattern: Tensor, metric: Tensor, timestep: float): Tensor<br ALIGN="LEFT"/>flow_step(metric: Tensor, ricci: Optional[Tensor], timestep: float): Tuple[Tensor, QuantumFlowMetrics]<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.metrics.quantum_geometric_metrics.PatternMetrics" [color="black", fontcolor="black", label=<{PatternMetrics|<br ALIGN="LEFT"/>|compute_pattern_complexity(patterns: torch.Tensor, context: MetricContext): torch.Tensor<br ALIGN="LEFT"/>compute_pattern_entropy(patterns: torch.Tensor, context: MetricContext): torch.Tensor<br ALIGN="LEFT"/>compute_pattern_stability(patterns: torch.Tensor, context: MetricContext): torch.Tensor<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.core.patterns.pattern_processor.PatternProcessor" [color="black", fontcolor="black", label=<{PatternProcessor|arithmetic<br ALIGN="LEFT"/>device : NoneType, device<br ALIGN="LEFT"/>dtype : Ellipsis, NoneType<br ALIGN="LEFT"/>flow<br ALIGN="LEFT"/>flow_net : Sequential<br ALIGN="LEFT"/>hidden_dim : int<br ALIGN="LEFT"/>manifold_dim : int<br ALIGN="LEFT"/>motive_rank : int<br ALIGN="LEFT"/>num_primes : int<br ALIGN="LEFT"/>operadic<br ALIGN="LEFT"/>pattern_bundle<br ALIGN="LEFT"/>pattern_dynamics<br ALIGN="LEFT"/>pattern_evolution<br ALIGN="LEFT"/>pattern_formation<br ALIGN="LEFT"/>pattern_net : Sequential<br ALIGN="LEFT"/>quantum_bridge : NeuralQuantumBridge<br ALIGN="LEFT"/>quantum_net : Sequential<br ALIGN="LEFT"/>riemannian<br ALIGN="LEFT"/>symplectic<br ALIGN="LEFT"/>transition<br ALIGN="LEFT"/>wave<br ALIGN="LEFT"/>|forward(x: Tensor, return_intermediates: bool): Union[Tensor, Tuple[Tensor, Dict[str, Any]]]<br ALIGN="LEFT"/>process_pattern(pattern: Tensor, with_quantum: bool, return_intermediates: bool): Union[Tensor, Tuple[Tensor, Dict[str, Any]]]<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.core.patterns.riemannian.PatternRiemannianStructure" [color="black", fontcolor="black", label=<{PatternRiemannianStructure|connection_coeffs : Parameter<br ALIGN="LEFT"/>metric_factors : Parameter<br ALIGN="LEFT"/>pattern_dim : int<br ALIGN="LEFT"/>structure<br ALIGN="LEFT"/>|compute_riemann(points: Tensor): CurvatureTensor[Tensor]<br ALIGN="LEFT"/>forward(): Any<br ALIGN="LEFT"/>get_christoffel_values(points: Tensor): Tensor<br ALIGN="LEFT"/>get_metric_tensor(points: Tensor): Tensor<br ALIGN="LEFT"/>get_riemann_tensor(points: Tensor): Tensor<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.core.types.PatternState" [color="black", fontcolor="black", label=<{PatternState|connection : Optional[torch.Tensor]<br ALIGN="LEFT"/>coordinates : Tensor<br ALIGN="LEFT"/>curvature : Optional[torch.Tensor]<br ALIGN="LEFT"/>metric : Tensor<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"src.core.patterns.enriched_structure.PatternTransition" [color="black", fontcolor="black", label=<{PatternTransition|wave<br ALIGN="LEFT"/>|compose(first: EnrichedMorphism, second: EnrichedMorphism): EnrichedMorphism<br ALIGN="LEFT"/>create_morphism(source: Tensor, target: Tensor): EnrichedMorphism<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.infrastructure.metrics.PerformanceMetrics" [color="black", fontcolor="black", label=<{PerformanceMetrics|compute_time : float<br ALIGN="LEFT"/>memory_time : float<br ALIGN="LEFT"/>sync_time : float<br ALIGN="LEFT"/>total_time : float<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"src.core.performance.cpu_optimizer.PerformanceMetrics" [color="black", fontcolor="black", label=<{PerformanceMetrics|cache_hits : float<br ALIGN="LEFT"/>cpu_utilization : float<br ALIGN="LEFT"/>execution_time : float<br ALIGN="LEFT"/>memory_usage : float<br ALIGN="LEFT"/>vectorization_efficiency : float<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"src.infrastructure.base.CPUOptimizer.profile.ProfileContext" [color="black", fontcolor="black", label=<{ProfileContext|<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"src.validation.quantum.evolution.QuantumEvolutionValidator" [color="black", fontcolor="black", label=<{QuantumEvolutionValidator|adiabatic_validator<br ALIGN="LEFT"/>decoherence_validator<br ALIGN="LEFT"/>unitary_validator<br ALIGN="LEFT"/>|validate(initial: QuantumState, evolved: QuantumState, evolution_operator: torch.Tensor, trajectory: List[QuantumState], hamiltonians: List[torch.Tensor]): Tuple[UnitaryValidation, DecoherenceValidation, AdiabaticValidation]<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.core.flow.protocol.QuantumFlowMetrics" [color="black", fontcolor="black", label=<{QuantumFlowMetrics|berry_phase : Optional[Tensor]<br ALIGN="LEFT"/>mean_curvature : Optional[Tensor]<br ALIGN="LEFT"/>quantum_corrections : Optional[Tensor]<br ALIGN="LEFT"/>quantum_entropy : Tensor<br ALIGN="LEFT"/>|to_device(device: torch.device): 'QuantumFlowMetrics'<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.core.tiling.quantum_geometric_attention.QuantumGeometricAttention" [color="black", fontcolor="black", label=<{QuantumGeometricAttention|arithmetic<br ALIGN="LEFT"/>attention<br ALIGN="LEFT"/>curvature : float<br ALIGN="LEFT"/>dropout : Dropout<br ALIGN="LEFT"/>exp_map<br ALIGN="LEFT"/>flow<br ALIGN="LEFT"/>head_dim<br ALIGN="LEFT"/>hidden_dim : int<br ALIGN="LEFT"/>log_map<br ALIGN="LEFT"/>manifold_dim : int<br ALIGN="LEFT"/>manifold_type : str<br ALIGN="LEFT"/>metric : Parameter<br ALIGN="LEFT"/>motive_rank : int<br ALIGN="LEFT"/>num_heads : int<br ALIGN="LEFT"/>num_layers : int<br ALIGN="LEFT"/>pattern_proj : Linear<br ALIGN="LEFT"/>scale<br ALIGN="LEFT"/>tile_size : int<br ALIGN="LEFT"/>tiles : ModuleList<br ALIGN="LEFT"/>to_out : Sequential<br ALIGN="LEFT"/>to_qkv : Linear<br ALIGN="LEFT"/>transport<br ALIGN="LEFT"/>|build_attention_complex(query: torch.Tensor, key: torch.Tensor, value: torch.Tensor, mask: Optional[torch.Tensor]): Tuple[torch.Tensor, AttentionMetrics]<br ALIGN="LEFT"/>classical_to_quantum(x: torch.Tensor): torch.Tensor<br ALIGN="LEFT"/>compute_attention_patterns(x: torch.Tensor, mask: Optional[torch.Tensor], return_metrics: bool): Union[torch.Tensor, Tuple[torch.Tensor, AttentionMetrics]]<br ALIGN="LEFT"/>compute_complexity(features: torch.Tensor): torch.Tensor<br ALIGN="LEFT"/>compute_entropy(features: torch.Tensor): torch.Tensor<br ALIGN="LEFT"/>compute_fisher_information(states: torch.Tensor): torch.Tensor<br ALIGN="LEFT"/>compute_metric_tensor(state: AttentionState): torch.Tensor<br ALIGN="LEFT"/>compute_sparsity(features: torch.Tensor): torch.Tensor<br ALIGN="LEFT"/>compute_stability(features: torch.Tensor): torch.Tensor<br ALIGN="LEFT"/>create_attention_parameters(batch_size: int, seq_len: int): Dict[str, torch.Tensor]<br ALIGN="LEFT"/>detect_patterns(x: torch.Tensor): Tuple[torch.Tensor, Dict[str, Any]]<br ALIGN="LEFT"/>forward(x: torch.Tensor, mask: Optional[torch.Tensor], return_metrics: bool): Tuple[torch.Tensor, Optional[Dict[str, Any]]]<br ALIGN="LEFT"/>prepare_attention_state(x: torch.Tensor, mask: Optional[torch.Tensor]): AttentionState<br ALIGN="LEFT"/>prepare_code_state(x: torch.Tensor): torch.Tensor<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.core.flow.quantum.QuantumGeometricFlow" [color="black", fontcolor="black", label=<{QuantumGeometricFlow|berry_connection : Parameter<br ALIGN="LEFT"/>decoherence_rates : dict<br ALIGN="LEFT"/>entanglement_net : Sequential<br ALIGN="LEFT"/>fubini_study_net : Sequential<br ALIGN="LEFT"/>hbar : float<br ALIGN="LEFT"/>hilbert_space : Optional[HilbertSpace]<br ALIGN="LEFT"/>mean_curvature_net : Sequential<br ALIGN="LEFT"/>quantum_transport_net : Sequential<br ALIGN="LEFT"/>state_reconstruction_net : Sequential<br ALIGN="LEFT"/>state_validator<br ALIGN="LEFT"/>tomography_validator<br ALIGN="LEFT"/>uncertainty_net : Sequential<br ALIGN="LEFT"/>|compute_berry_phase(path: List[Tensor]): Tensor<br ALIGN="LEFT"/>compute_connection(metric: Tensor, points: Optional[Tensor]): Tensor<br ALIGN="LEFT"/>compute_decoherence_correction(metric: Tensor, quantum_state: Optional[QuantumState]): Tensor<br ALIGN="LEFT"/>compute_geodesic(start_point: Tensor, end_point: Tensor, num_steps: int): Tensor<br ALIGN="LEFT"/>compute_mean_curvature(points: Tensor): Tensor<br ALIGN="LEFT"/>compute_metric(points: Tensor, connection: Optional[Tensor]): Tensor<br ALIGN="LEFT"/>compute_quantum_metric_tensor(state: QuantumState, metric: Optional[Tensor]): Tensor<br ALIGN="LEFT"/>compute_quantum_metrics(quantum_state: Optional[QuantumState]): Dict[str, Optional[Tensor]]<br ALIGN="LEFT"/>compute_ricci_tensor(metric: Tensor, points: Optional[Tensor], connection: Optional[Tensor]): Tensor<br ALIGN="LEFT"/>flow_step(metric: Tensor, ricci: Optional[Tensor], timestep: float, quantum_state: Optional[QuantumState]): Tuple[Tensor, QuantumFlowMetrics]<br ALIGN="LEFT"/>parallel_transport(vector: Tensor, start_point: Tensor, end_point: Tensor, connection: Optional[Tensor]): Tensor<br ALIGN="LEFT"/>parallel_transport_state(state: QuantumState, vector: Tensor, connection: Optional[Tensor]): QuantumState<br ALIGN="LEFT"/>reconstruct_state(measurements: Dict[str, Tensor], bases: Optional[List[Tensor]]): Optional[QuantumState]<br ALIGN="LEFT"/>set_points(points: Tensor): None<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.core.tiling.quantum_geometric_attention.QuantumGeometricTransformer" [color="black", fontcolor="black", label=<{QuantumGeometricTransformer|layers : ModuleList<br ALIGN="LEFT"/>norm : LayerNorm<br ALIGN="LEFT"/>|forward(x: torch.Tensor, return_patterns: bool): Tuple[torch.Tensor, Optional[List[Dict[str, Any]]]]<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.metrics.quantum_geometric_metrics.QuantumMetrics" [color="black", fontcolor="black", label=<{QuantumMetrics|hidden_dim : int<br ALIGN="LEFT"/>motive_rank : int<br ALIGN="LEFT"/>|compute_cohomology_class(attention_patterns: torch.Tensor, context: MetricContext): torch.Tensor<br ALIGN="LEFT"/>compute_motive_height(cohomology: torch.Tensor, context: MetricContext): torch.Tensor<br ALIGN="LEFT"/>compute_quantum_entropy(patterns: torch.Tensor, context: MetricContext): torch.Tensor<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.core.tiling.patterns.cohomology.QuantumMotivicCohomology" [color="black", fontcolor="black", label=<{QuantumMotivicCohomology|metric<br ALIGN="LEFT"/>motivic<br ALIGN="LEFT"/>quantum_structure<br ALIGN="LEFT"/>|compute_quantum_motive(form: ArithmeticForm): torch.Tensor<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.core.tiling.quantum_attention_tile.QuantumMotivicTile" [color="black", fontcolor="black", label=<{QuantumMotivicTile|cohomology_dim : int<br ALIGN="LEFT"/>cohomology_proj : Linear<br ALIGN="LEFT"/>dropout : float<br ALIGN="LEFT"/>dropout_layer : Dropout<br ALIGN="LEFT"/>field_proj : Linear<br ALIGN="LEFT"/>height_proj : Linear<br ALIGN="LEFT"/>hidden_dim : int<br ALIGN="LEFT"/>key : Linear<br ALIGN="LEFT"/>motive_rank : int<br ALIGN="LEFT"/>neighbors<br ALIGN="LEFT"/>num_heads : int<br ALIGN="LEFT"/>output : Linear<br ALIGN="LEFT"/>query : Linear<br ALIGN="LEFT"/>resolution : float<br ALIGN="LEFT"/>size : int<br ALIGN="LEFT"/>value : Linear<br ALIGN="LEFT"/>|adapt_resolution(density_metric: float, strategy: str): None<br ALIGN="LEFT"/>add_neighbor(neighbor: 'QuantumMotivicTile'): None<br ALIGN="LEFT"/>balance_load(neighbors: List['QuantumMotivicTile']): None<br ALIGN="LEFT"/>compute_ae(resolution_history: List[float], load_variance_history: List[float], window_size: int): float<br ALIGN="LEFT"/>compute_cer(information_transferred: float, compute_cost: float, memory_usage: float, resolution: float, beta: float): float<br ALIGN="LEFT"/>compute_ifq(pattern_stability: float, cross_tile_flow: float, edge_utilization: float, info_density: float, alpha: float): float<br ALIGN="LEFT"/>forward(q: Tensor, k: Tensor, v: Tensor, return_metrics: bool): Union[Tensor, Tuple[Tensor, Dict[str, Any]]]<br ALIGN="LEFT"/>get_memory_stats(): Dict[str, float]<br ALIGN="LEFT"/>get_metrics(): Dict[str, Any]<br ALIGN="LEFT"/>get_visualization_data(): Dict[str, Any]<br ALIGN="LEFT"/>optimize_resources(profile: LoadProfile): None<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.validation.quantum.state.QuantumStateValidationResult" [color="black", fontcolor="black", label=<{QuantumStateValidationResult|error_type : Optional[StateValidationErrorType]<br ALIGN="LEFT"/>|from_dict(data: Dict[str, Any]): 'QuantumStateValidationResult'<br ALIGN="LEFT"/>merge(other: ValidationResult): 'QuantumStateValidationResult'<br ALIGN="LEFT"/>to_dict(): Dict[str, Any]<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.validation.quantum.state.QuantumStateValidator" [color="black", fontcolor="black", label=<{QuantumStateValidator|density_validator<br ALIGN="LEFT"/>preparation_validator<br ALIGN="LEFT"/>tomography_validator<br ALIGN="LEFT"/>|validate(target: QuantumState, prepared: QuantumState, measurements: torch.Tensor, bases: List[torch.Tensor]): QuantumStateValidationResult<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.infrastructure.base.ResourceAllocationError" [color="black", fontcolor="red", label=<{ResourceAllocationError|<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"src.infrastructure.base.ResourceAllocator" [color="black", fontcolor="black", label=<{ResourceAllocator|compute_limit : float<br ALIGN="LEFT"/>memory_limit : int<br ALIGN="LEFT"/>|cleanup()<br ALIGN="LEFT"/>get_status(): Dict[str, Any]<br ALIGN="LEFT"/>plan_allocation(memory_size: int, compute_intensity: float): Dict[str, Any]<br ALIGN="LEFT"/>run_with_limits(func: Callable, memory_limit: Optional[int], cpu_limit: Optional[float]): Any<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.infrastructure.resource.ResourceAllocator" [color="black", fontcolor="black", label=<{ResourceAllocator|allocations : Dict[str, Dict]<br ALIGN="LEFT"/>compute_allocated : int<br ALIGN="LEFT"/>compute_limit : Optional[int]<br ALIGN="LEFT"/>device : str<br ALIGN="LEFT"/>memory_allocated : int<br ALIGN="LEFT"/>memory_limit : Optional[int]<br ALIGN="LEFT"/>|allocate_compute(units: int, name: str, priority: int): bool<br ALIGN="LEFT"/>allocate_memory(size: int, name: str, priority: int): bool<br ALIGN="LEFT"/>cleanup()<br ALIGN="LEFT"/>free(name: str)<br ALIGN="LEFT"/>get_available_compute(): float<br ALIGN="LEFT"/>get_available_memory(): float<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.infrastructure.metrics.ResourceMetrics" [color="black", fontcolor="black", label=<{ResourceMetrics|cpu_utilization : Optional[float]<br ALIGN="LEFT"/>gpu_utilization : Optional[float]<br ALIGN="LEFT"/>memory_available : float<br ALIGN="LEFT"/>memory_used : float<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"src.core.flow.protocol.RicciTensorNetwork" [color="black", fontcolor="black", label=<{RicciTensorNetwork|hidden : Sequential<br ALIGN="LEFT"/>hidden_dim<br ALIGN="LEFT"/>manifold_dim : int<br ALIGN="LEFT"/>output : Linear<br ALIGN="LEFT"/>projection : Linear<br ALIGN="LEFT"/>|forward(x: Tensor): Tensor<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.core.tiling.patterns.cohomology.RiemannianFiberBundle" [color="black", fontcolor="black", label=<{RiemannianFiberBundle|connection_map : Linear<br ALIGN="LEFT"/>dimension : int<br ALIGN="LEFT"/>fiber_map : Linear<br ALIGN="LEFT"/>|get_connection(point: torch.Tensor): torch.Tensor<br ALIGN="LEFT"/>get_fiber(point: torch.Tensor): torch.Tensor<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.core.patterns.riemannian_flow.RiemannianFlow" [color="black", fontcolor="black", label=<{RiemannianFlow|christoffel_net : Sequential<br ALIGN="LEFT"/>use_parallel_transport : bool<br ALIGN="LEFT"/>|compute_christoffel(metric: torch.Tensor, points: Optional[torch.Tensor]): torch.Tensor<br ALIGN="LEFT"/>compute_ricci_tensor(metric: torch.Tensor, connection: Optional[torch.Tensor]): torch.Tensor<br ALIGN="LEFT"/>flow_step(metric: torch.Tensor, ricci: torch.Tensor, timestep: float): Tuple[torch.Tensor, Dict[str, Any]]<br ALIGN="LEFT"/>parallel_transport(vector: torch.Tensor, path: torch.Tensor, metric: Optional[torch.Tensor]): torch.Tensor<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.core.patterns.riemannian.RiemannianFramework" [color="black", fontcolor="black", label=<{RiemannianFramework|structure<br ALIGN="LEFT"/>|compute_christoffel(points: Tensor): ChristoffelSymbols[Tensor]<br ALIGN="LEFT"/>compute_metric(points: Tensor): MetricTensor[Tensor]<br ALIGN="LEFT"/>compute_riemann(points: Tensor): CurvatureTensor[Tensor]<br ALIGN="LEFT"/>exp_map(point: Tensor, vector: Tensor): Tensor<br ALIGN="LEFT"/>forward(): Any<br ALIGN="LEFT"/>get_christoffel_values(points: Tensor): Tensor<br ALIGN="LEFT"/>get_metric_tensor(points: Tensor): Tensor<br ALIGN="LEFT"/>get_riemann_tensor(points: Tensor): Tensor<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.core.types.RiemannianMetric" [color="black", fontcolor="black", label=<{RiemannianMetric|christoffel_symbols : Optional[torch.Tensor]<br ALIGN="LEFT"/>curvature : Optional[torch.Tensor]<br ALIGN="LEFT"/>tensor : Tensor<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"src.core.patterns.riemannian_base.RiemannianStructure" [color="black", fontcolor="black", label=<{RiemannianStructure|<br ALIGN="LEFT"/>|compute_christoffel(points: T): ChristoffelSymbols[T]<br ALIGN="LEFT"/>compute_curvature(points: T, christoffel: Optional[ChristoffelSymbols[T]]): CurvatureTensor[T]<br ALIGN="LEFT"/>compute_metric(points: T): MetricTensor[T]<br ALIGN="LEFT"/>geodesic_flow(initial_point: T, initial_velocity: T, steps: int, step_size: float): Tuple[T, T]<br ALIGN="LEFT"/>lie_derivative_metric(point: T, vector_field: VectorField): MetricTensor[T]<br ALIGN="LEFT"/>parallel_transport(vector: T, path: T, connection: Optional[ChristoffelSymbols[T]]): T<br ALIGN="LEFT"/>sectional_curvature(point: T, v1: T, v2: T): Scalar<br ALIGN="LEFT"/>validate_connection_properties(connection: ChristoffelSymbols[T]): bool<br ALIGN="LEFT"/>validate_metric_properties(metric: MetricTensor[T]): bool<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.core.patterns.riemannian_base.RiemannianValidator" [color="black", fontcolor="black", label=<{RiemannianValidator|<br ALIGN="LEFT"/>|validate_connection_properties(connection: ChristoffelSymbols[T]): bool<br ALIGN="LEFT"/>validate_metric_properties(metric: MetricTensor[T]): bool<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.core.scale_transition.ScaleFlowIntegrator" [color="black", fontcolor="black", label=<{ScaleFlowIntegrator|config<br ALIGN="LEFT"/>entanglement_tracker : Parameter<br ALIGN="LEFT"/>scale_classical_proj : Linear<br ALIGN="LEFT"/>scale_dependent_ops : ModuleList<br ALIGN="LEFT"/>scale_quantum_proj : Linear<br ALIGN="LEFT"/>|compute_scale_quantum_state(state: torch.Tensor, scale_idx: int): torch.Tensor<br ALIGN="LEFT"/>get_entanglement_metrics(): Dict[str, torch.Tensor]<br ALIGN="LEFT"/>integrate_flow(state: torch.Tensor, source_scale: float, target_scale: float, quantum_bridge: Optional[NeuralQuantumBridge]): torch.Tensor<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.core.scale_transition.ScaleTransitionConfig" [color="black", fontcolor="black", label=<{ScaleTransitionConfig|dim : int<br ALIGN="LEFT"/>hidden_dim : int<br ALIGN="LEFT"/>max_scale : float<br ALIGN="LEFT"/>min_scale : float<br ALIGN="LEFT"/>num_scales : int<br ALIGN="LEFT"/>use_quantum_bridge : bool<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"src.core.scale_transition.ScaleTransitionLayer" [color="black", fontcolor="black", label=<{ScaleTransitionLayer|config<br ALIGN="LEFT"/>quantum_bridge : NeuralQuantumBridge, NoneType<br ALIGN="LEFT"/>scale_down : ModuleList<br ALIGN="LEFT"/>scale_norm : LayerNorm<br ALIGN="LEFT"/>scale_system : ScaleSystem<br ALIGN="LEFT"/>scale_up : ModuleList<br ALIGN="LEFT"/>|forward(state: torch.Tensor, source_scale: float, target_scale: float): torch.Tensor<br ALIGN="LEFT"/>transition_down(state: torch.Tensor, source_scale: float, target_scale: float): torch.Tensor<br ALIGN="LEFT"/>transition_up(state: torch.Tensor, source_scale: float, target_scale: float): torch.Tensor<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.core.scale_transition.ScaleTransitionSystem" [color="black", fontcolor="black", label=<{ScaleTransitionSystem|config<br ALIGN="LEFT"/>transition_layer<br ALIGN="LEFT"/>|connect_pattern_scales(patterns: List[torch.Tensor], scales: List[float], preserve_symmetry: bool): List[torch.Tensor]<br ALIGN="LEFT"/>connect_scales(states: List[torch.Tensor], scales: List[float]): List[torch.Tensor]<br ALIGN="LEFT"/>validate_pattern_transitions(patterns: List[torch.Tensor], scales: List[float]): Mapping[str, torch.Tensor]<br ALIGN="LEFT"/>validate_transitions(states: List[torch.Tensor], scales: List[float]): Mapping[str, torch.Tensor]<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.core.performance.vulkan.shaders.ShaderCompiler" [color="black", fontcolor="black", label=<{ShaderCompiler|shader_dir : Path<br ALIGN="LEFT"/>|compile_all_shaders(): None<br ALIGN="LEFT"/>compile_shader(shader_name: str): None<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.core.performance.vulkan.shaders.ShaderManager" [color="black", fontcolor="black", label=<{ShaderManager|device : c_void_p<br ALIGN="LEFT"/>pipeline_layouts : Dict[str, VkPipelineLayout]<br ALIGN="LEFT"/>pipelines : Dict[str, VkPipeline]<br ALIGN="LEFT"/>shader_dir : Path<br ALIGN="LEFT"/>shader_modules : Dict[str, VkShaderModule]<br ALIGN="LEFT"/>|cleanup(): None<br ALIGN="LEFT"/>create_compute_pipeline(shader_name: str, push_constant_size: int): Tuple[VkPipeline, VkPipelineLayout]<br ALIGN="LEFT"/>create_shader_module(shader_name: str): VkShaderModule<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.core.flow.protocol.SingularityInfo" [color="black", fontcolor="black", label=<{SingularityInfo|condition_number : float<br ALIGN="LEFT"/>curvature : Optional[T]<br ALIGN="LEFT"/>determinant : float<br ALIGN="LEFT"/>index : int<br ALIGN="LEFT"/>location : Optional[T]<br ALIGN="LEFT"/>min_eigenvalue : float<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"src.core.tiling.state_manager.StateConfig" [color="black", fontcolor="black", label=<{StateConfig|dim : int<br ALIGN="LEFT"/>epsilon : float<br ALIGN="LEFT"/>max_entanglement : float<br ALIGN="LEFT"/>type<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"src.core.tiling.state_manager.StateManager" [color="black", fontcolor="black", label=<{StateManager|config<br ALIGN="LEFT"/>device : NoneType, device<br ALIGN="LEFT"/>history : list<br ALIGN="LEFT"/>states : dict<br ALIGN="LEFT"/>|calculate_fidelity(state1: torch.Tensor, state2: torch.Tensor): float<br ALIGN="LEFT"/>get_entanglement_history(source_scale: Optional[float], target_scale: Optional[float]): Dict[str, List[float]]<br ALIGN="LEFT"/>get_state_history(key: str): List[torch.Tensor]<br ALIGN="LEFT"/>initialize_state(key: str, dim: Optional[int]): torch.Tensor<br ALIGN="LEFT"/>update_entanglement(source_scale: float, target_scale: float, entropy: torch.Tensor): None<br ALIGN="LEFT"/>update_state(key: str, update: torch.Tensor, learning_rate: float): torch.Tensor<br ALIGN="LEFT"/>validate_state(state: torch.Tensor): bool<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.validation.quantum.state.StatePreparationValidation" [color="black", fontcolor="black", label=<{StatePreparationValidation|concurrence : float<br ALIGN="LEFT"/>fidelity : float<br ALIGN="LEFT"/>purity : float<br ALIGN="LEFT"/>trace_distance : float<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"src.validation.quantum.state.StatePreparationValidator" [color="black", fontcolor="black", label=<{StatePreparationValidator|density_validator<br ALIGN="LEFT"/>tolerance : float<br ALIGN="LEFT"/>tomography_validator<br ALIGN="LEFT"/>|correct_state(state: QuantumState, error_type: StateValidationErrorType): QuantumState<br ALIGN="LEFT"/>validate_preparation(target: QuantumState, prepared: QuantumState): QuantumStateValidationResult<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.validation.quantum.state.StateProperties" [color="black", fontcolor="black", label=<{StateProperties|eigenvalues : Tensor<br ALIGN="LEFT"/>is_normalized : bool<br ALIGN="LEFT"/>is_pure : bool<br ALIGN="LEFT"/>purity : float<br ALIGN="LEFT"/>rank : int<br ALIGN="LEFT"/>trace : complex<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"src.core.tiling.state_manager.StateType" [color="black", fontcolor="black", label=<{StateType|name<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"src.validation.quantum.state.StateValidationErrorType" [color="black", fontcolor="black", label=<{StateValidationErrorType|name<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"src.validation.quantum.state.StateValidator" [color="black", fontcolor="black", label=<{StateValidator|density_validator<br ALIGN="LEFT"/>preparation_validator<br ALIGN="LEFT"/>tolerance : float<br ALIGN="LEFT"/>tomography_validator<br ALIGN="LEFT"/>|validate_state(state: QuantumState): StateProperties<br ALIGN="LEFT"/>validate_uncertainty(state: QuantumState): UncertaintyMetrics<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.core.patterns.symplectic.SymplecticForm" [color="black", fontcolor="black", label=<{SymplecticForm|enrichment : Optional[Dict[str, Any]]<br ALIGN="LEFT"/>matrix : Tensor<br ALIGN="LEFT"/>|evaluate(v1: Tensor, v2: Tensor): Tensor<br ALIGN="LEFT"/>transpose(): 'SymplecticForm'<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.core.patterns.symplectic.SymplecticStructure" [color="black", fontcolor="black", label=<{SymplecticStructure|dim : int<br ALIGN="LEFT"/>enriched<br ALIGN="LEFT"/>operadic<br ALIGN="LEFT"/>preserve_structure : bool<br ALIGN="LEFT"/>target_dim<br ALIGN="LEFT"/>wave_enabled : bool<br ALIGN="LEFT"/>|compute_form(fiber_coords: Tensor): SymplecticForm<br ALIGN="LEFT"/>compute_metric(fiber_coords: Tensor): Tensor<br ALIGN="LEFT"/>compute_quantum_geometric_tensor(point: Tensor): Tensor<br ALIGN="LEFT"/>compute_ricci_tensor(point: Tensor): Tensor<br ALIGN="LEFT"/>compute_volume(point: Tensor): Tensor<br ALIGN="LEFT"/>hamiltonian_vector_field(hamiltonian: Tensor, point: Tensor): Tensor<br ALIGN="LEFT"/>poisson_bracket(f: Tensor, g: Tensor, point: Tensor): Tensor<br ALIGN="LEFT"/>quantum_ricci_flow(point: Tensor, time: float, dt: float, steps: int): Tensor<br ALIGN="LEFT"/>standard_form(device: Optional[torch.device]): SymplecticForm<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.metrics.synthetic_data.SyntheticDataGenerator" [color="black", fontcolor="black", label=<{SyntheticDataGenerator|num_values : int<br ALIGN="LEFT"/>vocab_size : int<br ALIGN="LEFT"/>|generate_constant_sequence(length: int, batch_size: int): torch.Tensor<br ALIGN="LEFT"/>generate_density_pattern(sequence_length: int): torch.Tensor<br ALIGN="LEFT"/>generate_edge_cases(): Sequence[tuple[torch.Tensor, torch.Tensor]]<br ALIGN="LEFT"/>generate_mixed_sequence(sequence_length: int): torch.Tensor<br ALIGN="LEFT"/>generate_pattern_sequence(length: int, pattern_length: int, batch_size: int): torch.Tensor<br ALIGN="LEFT"/>generate_random_sequence(length: int, batch_size: int): torch.Tensor<br ALIGN="LEFT"/>generate_test_batch(num_sequences: int, min_length: int, max_length: int): Sequence[torch.Tensor]<br ALIGN="LEFT"/>generate_test_sequence(sequence_length: int, batch_size: int): tuple[torch.Tensor, torch.Tensor]<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.utils.memory_management.TensorManager" [color="black", fontcolor="black", label=<{TensorManager|<br ALIGN="LEFT"/>|cleanup_operation(operation: str): None<br ALIGN="LEFT"/>clear_all(): None<br ALIGN="LEFT"/>disable()<br ALIGN="LEFT"/>operation_scope(operation: str)<br ALIGN="LEFT"/>register_tensor(tensor: torch.Tensor, operation: Optional[str]): torch.Tensor<br ALIGN="LEFT"/>set_max_tensor_size(size_bytes: int): None<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.core.tiling.patterns.pattern_fiber_bundle.TensorStateContext" [color="black", fontcolor="black", label=<{TensorStateContext|bundle : str<br ALIGN="LEFT"/>modified_tensor : NoneType, Optional[Tensor]<br ALIGN="LEFT"/>original_device<br ALIGN="LEFT"/>original_dtype<br ALIGN="LEFT"/>original_tensor : Tensor<br ALIGN="LEFT"/>target : Optional[Tensor]<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"src.core.tiling.patterns.pattern_fiber_bundle.TensorStateManager" [color="black", fontcolor="black", label=<{TensorStateManager|<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"src.core.tiling.components.config.TilingConfig" [color="black", fontcolor="black", label=<{TilingConfig|dilation : int<br ALIGN="LEFT"/>groups : int<br ALIGN="LEFT"/>max_memory_gb : float<br ALIGN="LEFT"/>num_stages : int<br ALIGN="LEFT"/>num_warps : int<br ALIGN="LEFT"/>optimize_layout : bool<br ALIGN="LEFT"/>overlap : int<br ALIGN="LEFT"/>padding : str<br ALIGN="LEFT"/>stride : Optional[Tuple[int, ...]]<br ALIGN="LEFT"/>tile_size : Tuple[int, ...]<br ALIGN="LEFT"/>vectorize : bool<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"src.validation.quantum.state.TomographyValidation" [color="black", fontcolor="black", label=<{TomographyValidation|completeness : float<br ALIGN="LEFT"/>confidence : float<br ALIGN="LEFT"/>estimated_state : Tensor<br ALIGN="LEFT"/>reconstruction_error : float<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"src.validation.quantum.state.TomographyValidator" [color="black", fontcolor="black", label=<{TomographyValidator|confidence_level : float<br ALIGN="LEFT"/>max_iterations : int<br ALIGN="LEFT"/>|validate_tomography(true_state: QuantumState, measurements: torch.Tensor, bases: List[torch.Tensor]): QuantumStateValidationResult<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.validation.quantum.state.UncertaintyMetrics" [color="black", fontcolor="black", label=<{UncertaintyMetrics|energy_uncertainty : float<br ALIGN="LEFT"/>heisenberg_product : float<br ALIGN="LEFT"/>momentum_uncertainty : float<br ALIGN="LEFT"/>position_uncertainty : float<br ALIGN="LEFT"/>robertson_product : float<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"src.metrics.quantum_geometric_metrics.UnifiedMetrics" [color="black", fontcolor="black", label=<{UnifiedMetrics|arithmetic<br ALIGN="LEFT"/>geometric<br ALIGN="LEFT"/>hidden_dim : int<br ALIGN="LEFT"/>manifold_dim : int<br ALIGN="LEFT"/>motive_rank : int<br ALIGN="LEFT"/>num_bins : int<br ALIGN="LEFT"/>num_heads : int<br ALIGN="LEFT"/>num_primes : int<br ALIGN="LEFT"/>pattern<br ALIGN="LEFT"/>quantum<br ALIGN="LEFT"/>|compute_all_metrics(data: Dict[str, torch.Tensor], context: MetricContext): Dict[str, torch.Tensor]<br ALIGN="LEFT"/>compute_pattern_evolution(pattern_history: List[torch.Tensor], context: MetricContext): torch.Tensor<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.validation.quantum.evolution.UnitaryValidation" [color="black", fontcolor="black", label=<{UnitaryValidation|coherence : float<br ALIGN="LEFT"/>norm_preservation : float<br ALIGN="LEFT"/>phase_error : float<br ALIGN="LEFT"/>unitary : bool<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"src.validation.quantum.evolution.UnitaryValidator" [color="black", fontcolor="black", label=<{UnitaryValidator|tolerance : float<br ALIGN="LEFT"/>|validate_unitary(initial: QuantumState, evolved: QuantumState, evolution_operator: torch.Tensor): UnitaryValidation<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.validation.framework.ValidationFramework" [color="black", fontcolor="black", label=<{ValidationFramework|geometric_validator : ModelGeometricValidator<br ALIGN="LEFT"/>pattern_validator : PatternValidator<br ALIGN="LEFT"/>quantum_validator<br ALIGN="LEFT"/>symplectic_validator : SymplecticStructureValidator<br ALIGN="LEFT"/>tolerance : float<br ALIGN="LEFT"/>|load_results(path: str): FrameworkValidationResult<br ALIGN="LEFT"/>safe_int_cast(value: Union[int, float, torch.Tensor, nn.Module]): int<br ALIGN="LEFT"/>save_results(results: FrameworkValidationResult, path: str)<br ALIGN="LEFT"/>validate_all(model: Any, data: Dict[str, Any], include_symplectic: bool): FrameworkValidationResult<br ALIGN="LEFT"/>validate_geometric(model: Any, data: Dict[str, Any]): GeometricValidationResult<br ALIGN="LEFT"/>validate_pattern_formation(pattern: torch.Tensor, dynamics: Optional[AttentionPatternDynamics], time_steps: int): ValidationResult<br ALIGN="LEFT"/>validate_patterns(patterns: Optional[Any]): ValidationResult<br ALIGN="LEFT"/>validate_quantum(quantum_state: Optional[Any]): QuantumStateValidationResult<br ALIGN="LEFT"/>validate_quantum_state(state: Union[torch.Tensor, QuantumState], prepared: Optional[Union[torch.Tensor, QuantumState]], measurements: Optional[List[Union[torch.Tensor, QuantumState]]], bases: Optional[List[str]]): QuantumStateValidationResult<br ALIGN="LEFT"/>validate_symplectic(structure: SymplecticStructure, point: Tensor, wave_packet: Optional[Tensor], target_point: Optional[Tensor]): FrameworkValidationResult<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.core.patterns.riemannian_base.ValidationMixin" [color="black", fontcolor="black", label=<{ValidationMixin|<br ALIGN="LEFT"/>|validate_connection_properties(connection: ChristoffelSymbols[Tensor]): bool<br ALIGN="LEFT"/>validate_metric_properties(metric: MetricTensor[Tensor]): bool<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.validation.framework.ValidationProtocol" [color="black", fontcolor="black", label=<{ValidationProtocol|data : Optional[Dict[str, Any]]<br ALIGN="LEFT"/>is_valid : bool<br ALIGN="LEFT"/>message : str<br ALIGN="LEFT"/>|from_dict(data: Dict[str, Any]): 'ValidationProtocol'<br ALIGN="LEFT"/>merge(other: 'ValidationProtocol'): 'ValidationProtocol'<br ALIGN="LEFT"/>to_dict(): Dict[str, Any]<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.validation.base.ValidationResult" [color="black", fontcolor="black", label=<{ValidationResult|data : Optional[T \| Dict[str, Any]]<br ALIGN="LEFT"/>is_valid : bool<br ALIGN="LEFT"/>message : str<br ALIGN="LEFT"/>|<I>from_dict</I>(data: Dict[str, Any]): 'ValidationResult'<br ALIGN="LEFT"/><I>merge</I>(other: 'ValidationResult'): 'ValidationResult'<br ALIGN="LEFT"/><I>to_dict</I>(): Dict[str, Any]<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.core.performance.cpu.vectorization.VectorizationMetrics" [color="black", fontcolor="black", label=<{VectorizationMetrics|execution_time : float<br ALIGN="LEFT"/>memory_usage : float<br ALIGN="LEFT"/>operation_type : str<br ALIGN="LEFT"/>vectorization_efficiency : float<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"src.core.performance.cpu.vectorization.VectorizationOptimizer" [color="black", fontcolor="black", label=<{VectorizationOptimizer|chunk_size : int<br ALIGN="LEFT"/>enable_profiling : bool<br ALIGN="LEFT"/>metrics : List[VectorizationMetrics]<br ALIGN="LEFT"/>use_mixed_precision : bool<br ALIGN="LEFT"/>|clear_metrics(): None<br ALIGN="LEFT"/>get_metrics(): List[VectorizationMetrics]<br ALIGN="LEFT"/>profile_vectorization(func: Callable): Callable<br ALIGN="LEFT"/>vectorize_attention(query: torch.Tensor, key: torch.Tensor, value: torch.Tensor): torch.Tensor<br ALIGN="LEFT"/>vectorize_geometric_flow(metric: torch.Tensor, connection: torch.Tensor): torch.Tensor<br ALIGN="LEFT"/>vectorize_pattern_dynamics(pattern: torch.Tensor, flow: torch.Tensor): torch.Tensor<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.core.performance.vulkan.shaders.VkCommandBufferAllocateInfo" [color="black", fontcolor="black", label=<{VkCommandBufferAllocateInfo|<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"src.core.performance.vulkan.shaders.VkCommandBufferBeginInfo" [color="black", fontcolor="black", label=<{VkCommandBufferBeginInfo|<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"src.core.performance.vulkan.shaders.VkComputePipelineCreateInfo" [color="black", fontcolor="black", label=<{VkComputePipelineCreateInfo|<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"src.core.performance.vulkan.shaders.VkDescriptorSetLayoutBinding" [color="black", fontcolor="black", label=<{VkDescriptorSetLayoutBinding|<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"src.core.performance.vulkan.shaders.VkDescriptorSetLayoutCreateInfo" [color="black", fontcolor="black", label=<{VkDescriptorSetLayoutCreateInfo|<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"src.core.vulkan.resources.VkMemoryRequirements" [color="black", fontcolor="black", label=<{VkMemoryRequirements|<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"src.core.performance.vulkan.shaders.VkPipelineLayoutCreateInfo" [color="black", fontcolor="black", label=<{VkPipelineLayoutCreateInfo|<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"src.core.performance.vulkan.shaders.VkPipelineShaderStageCreateInfo" [color="black", fontcolor="black", label=<{VkPipelineShaderStageCreateInfo|<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"src.core.performance.vulkan.shaders.VkPushConstantRange" [color="black", fontcolor="black", label=<{VkPushConstantRange|<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"src.core.performance.vulkan.shaders.VkShaderModuleCreateInfo" [color="black", fontcolor="black", label=<{VkShaderModuleCreateInfo|<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"src.core.performance.vulkan.shaders.VkSubmitInfo" [color="black", fontcolor="black", label=<{VkSubmitInfo|<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"src.core.performance.vulkan_memory.VulkanBuffer" [color="black", fontcolor="black", label=<{VulkanBuffer|buffer : c_void_p<br ALIGN="LEFT"/>dtype : Optional[Any]<br ALIGN="LEFT"/>memory : c_void_p<br ALIGN="LEFT"/>offset : int<br ALIGN="LEFT"/>shape : Optional[Tuple[int, ...]]<br ALIGN="LEFT"/>size : int<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"src.infrastructure.base.VulkanIntegration" [color="black", fontcolor="black", label=<{VulkanIntegration|<br ALIGN="LEFT"/>|compute(shader_code: str, buffer: Any, workgroup_size: int): Any<br ALIGN="LEFT"/>create_buffer(data: torch.Tensor): Any<br ALIGN="LEFT"/>download_buffer(buffer: Any): torch.Tensor<br ALIGN="LEFT"/>get_device_info(): DeviceInfo<br ALIGN="LEFT"/>get_queue_status(): str<br ALIGN="LEFT"/>wait_idle()<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.infrastructure.vulkan_integration.VulkanIntegration" [color="black", fontcolor="black", label=<{VulkanIntegration|command_pool : NoneType<br ALIGN="LEFT"/>compute_queue : NoneType<br ALIGN="LEFT"/>device : NoneType<br ALIGN="LEFT"/>pipeline_cache : Dict[str, Any]<br ALIGN="LEFT"/>|cleanup(): None<br ALIGN="LEFT"/>create_compute_pipeline(shader_path: str): Optional[Any]<br ALIGN="LEFT"/>execute_compute(pipeline: Any, data: np.ndarray): Optional[np.ndarray]<br ALIGN="LEFT"/>initialize(): bool<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.core.vulkan.memory.VulkanMemory" [color="black", fontcolor="black", label=<{VulkanMemory|allocations : Dict[int, MemoryBlock]<br ALIGN="LEFT"/>device : Union[int, c_void_p]<br ALIGN="LEFT"/>memory_properties<br ALIGN="LEFT"/>peak_allocated : int<br ALIGN="LEFT"/>physical_device : Union[int, c_void_p]<br ALIGN="LEFT"/>total_allocated : int<br ALIGN="LEFT"/>|allocate(size: int, memory_type_bits: int, properties: int): MemoryBlock<br ALIGN="LEFT"/>cleanup()<br ALIGN="LEFT"/>free(block: MemoryBlock)<br ALIGN="LEFT"/>get_stats(): Dict[str, float]<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.core.performance.vulkan_memory.VulkanMemoryManager" [color="black", fontcolor="black", label=<{VulkanMemoryManager|device : c_void_p<br ALIGN="LEFT"/>physical_device : c_void_p<br ALIGN="LEFT"/>|allocate_tensor(size: Union[Tuple[int, ...], torch.Size], dtype: Any): VulkanBuffer<br ALIGN="LEFT"/>cleanup(): None<br ALIGN="LEFT"/>copy_from_device(src: VulkanBuffer, dst: np.ndarray): None<br ALIGN="LEFT"/>copy_to_device(src: np.ndarray, dst: VulkanBuffer): None<br ALIGN="LEFT"/>free_tensor(buffer: VulkanBuffer): None<br ALIGN="LEFT"/>get_fragmentation_ratio(): float<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.core.vulkan.resources.VulkanResources" [color="black", fontcolor="black", label=<{VulkanResources|buffers : Dict[int, BufferResource]<br ALIGN="LEFT"/>device : int<br ALIGN="LEFT"/>images : Dict[int, ImageResource]<br ALIGN="LEFT"/>memory<br ALIGN="LEFT"/>|cleanup()<br ALIGN="LEFT"/>create_buffer(size: int, usage: int, sharing_mode: int, memory_properties: int): BufferResource<br ALIGN="LEFT"/>create_image(format: int, width: int, height: int, depth: int, usage: int, sharing_mode: int, memory_properties: int): ImageResource<br ALIGN="LEFT"/>destroy_buffer(resource: BufferResource)<br ALIGN="LEFT"/>destroy_image(resource: ImageResource)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.core.patterns.enriched_structure.WaveEmergence" [color="black", fontcolor="black", label=<{WaveEmergence|dt : float<br ALIGN="LEFT"/>num_steps : int<br ALIGN="LEFT"/>|evolve_structure(pattern: Tensor, direction: Tensor): Tensor<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.core.patterns.symplectic.WaveOperator" [color="black", fontcolor="black", label=<{WaveOperator|<br ALIGN="LEFT"/>|create_morphism(pattern: Tensor, operation: OperadicOperation, include_wave: bool): Tensor<br ALIGN="LEFT"/>create_wave_packet(position: Tensor, momentum: Tensor): Tensor<br ALIGN="LEFT"/>get_momentum(wave: Tensor): Tensor<br ALIGN="LEFT"/>get_position(wave: Tensor): Tensor<br ALIGN="LEFT"/>wave_operator(tensor: Tensor): Tensor<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.core.flow.higher_order.HigherOrderFlow" -> "src.core.flow.pattern_heat.PatternHeatFlow" [arrowhead="empty", arrowtail="none"];
"src.core.flow.information_ricci.InformationRicciFlow" -> "src.core.flow.neural.NeuralGeometricFlow" [arrowhead="empty", arrowtail="none"];
"src.core.flow.neural.NeuralGeometricFlow" -> "src.core.flow.pattern.PatternFormationFlow" [arrowhead="empty", arrowtail="none"];
"src.core.flow.pattern.PatternFormationFlow" -> "src.core.flow.base.BaseGeometricFlow" [arrowhead="empty", arrowtail="none"];
"src.core.flow.pattern_heat.PatternHeatFlow" -> "src.core.flow.information_ricci.InformationRicciFlow" [arrowhead="empty", arrowtail="none"];
"src.core.flow.protocol.QuantumFlowMetrics" -> "src.core.flow.protocol.FlowMetrics" [arrowhead="empty", arrowtail="none"];
"src.core.flow.quantum.QuantumGeometricFlow" -> "src.core.flow.base.BaseGeometricFlow" [arrowhead="empty", arrowtail="none"];
"src.core.patterns.base_flow.BaseGeometricFlow" -> "src.core.types.GeometricFlowProtocol" [arrowhead="empty", arrowtail="none"];
"src.core.patterns.enriched_structure.PatternTransition" -> "src.core.patterns.enriched_structure.EnrichedTransition" [arrowhead="empty", arrowtail="none"];
"src.core.patterns.motivic_integration.MotivicRiemannianStructureImpl" -> "src.core.patterns.riemannian.PatternRiemannianStructure" [arrowhead="empty", arrowtail="none"];
"src.core.patterns.motivic_riemannian.MotivicRiemannianStructure" -> "src.core.patterns.fiber_bundle.BaseFiberBundle" [arrowhead="empty", arrowtail="none"];
"src.core.patterns.motivic_riemannian.MotivicRiemannianStructure" -> "src.core.patterns.riemannian_base.ValidationMixin" [arrowhead="empty", arrowtail="none"];
"src.core.patterns.motivic_riemannian.MotivicRiemannianStructure" -> "src.core.tiling.patterns.cohomology.RiemannianFiberBundle" [arrowhead="empty", arrowtail="none"];
"src.core.patterns.operadic_structure.AttentionOperad" -> "src.core.patterns.operadic_structure.OperadicComposition" [arrowhead="empty", arrowtail="none"];
"src.core.patterns.riemannian.BaseRiemannianStructure" -> "src.core.patterns.riemannian_base.ValidationMixin" [arrowhead="empty", arrowtail="none"];
"src.core.patterns.riemannian.PatternRiemannianStructure" -> "src.core.patterns.riemannian.BaseRiemannianStructure" [arrowhead="empty", arrowtail="none"];
"src.core.patterns.riemannian_flow.RiemannianFlow" -> "src.core.patterns.base_flow.BaseGeometricFlow" [arrowhead="empty", arrowtail="none"];
"src.core.patterns.symplectic.EnrichedOperator" -> "src.core.patterns.symplectic.WaveOperator" [arrowhead="empty", arrowtail="none"];
"src.core.performance.cpu_memory.CPUMemoryManager" -> "src.core.performance.memory_base.MemoryManagerBase" [arrowhead="empty", arrowtail="none"];
"src.core.performance.vulkan_memory.VulkanMemoryManager" -> "src.core.performance.memory_base.MemoryManagerBase" [arrowhead="empty", arrowtail="none"];
"src.core.tiling.geometric_flow.GeometricFlow" -> "src.core.patterns.riemannian_flow.RiemannianFlow" [arrowhead="empty", arrowtail="none"];
"src.core.tiling.patterns.pattern_fiber_bundle.PatternFiberBundle" -> "src.core.patterns.fiber_bundle.BaseFiberBundle" [arrowhead="empty", arrowtail="none"];
"src.validation.base.BasicValidationResult" -> "src.validation.base.ValidationResult" [arrowhead="empty", arrowtail="none"];
"src.validation.framework.ConcreteValidationResult" -> "src.validation.base.ValidationResult" [arrowhead="empty", arrowtail="none"];
"src.validation.framework.FrameworkValidationResult" -> "src.validation.base.ValidationResult" [arrowhead="empty", arrowtail="none"];
"src.validation.quantum.state.QuantumStateValidationResult" -> "src.validation.base.ValidationResult" [arrowhead="empty", arrowtail="none"];
"src.core.attention.geometric.EuclideanExponential" -> "src.core.tiling.quantum_geometric_attention.GeometricStructures" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="exp_map", style="solid"];
"src.core.attention.geometric.EuclideanExponential" -> "src.core.tiling.quantum_geometric_attention.QuantumGeometricAttention" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="exp_map", style="solid"];
"src.core.attention.geometric.EuclideanLogarithm" -> "src.core.tiling.quantum_geometric_attention.GeometricStructures" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="log_map", style="solid"];
"src.core.attention.geometric.EuclideanLogarithm" -> "src.core.tiling.quantum_geometric_attention.QuantumGeometricAttention" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="log_map", style="solid"];
"src.core.attention.geometric.HyperbolicExponential" -> "src.core.tiling.quantum_geometric_attention.GeometricStructures" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="exp_map", style="solid"];
"src.core.attention.geometric.HyperbolicExponential" -> "src.core.tiling.quantum_geometric_attention.QuantumGeometricAttention" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="exp_map", style="solid"];
"src.core.attention.geometric.HyperbolicLogarithm" -> "src.core.tiling.quantum_geometric_attention.GeometricStructures" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="log_map", style="solid"];
"src.core.attention.geometric.HyperbolicLogarithm" -> "src.core.tiling.quantum_geometric_attention.QuantumGeometricAttention" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="log_map", style="solid"];
"src.core.attention.geometric.ParallelTransport" -> "src.core.attention.geometric.GeometricStructures" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="transport", style="solid"];
"src.core.attention.geometric.ParallelTransport" -> "src.core.tiling.quantum_geometric_attention.GeometricStructures" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="transport", style="solid"];
"src.core.attention.geometric.ParallelTransport" -> "src.core.tiling.quantum_geometric_attention.QuantumGeometricAttention" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="transport", style="solid"];
"src.core.flow.pattern_heat.PatternHeatFlow" -> "src.core.patterns.pattern_processor.PatternProcessor" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="flow", style="solid"];
"src.core.metrics.evolution.ErgodicAnalysis" -> "src.core.metrics.evolution.EvolutionAnalyzer" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="ergodic", style="solid"];
"src.core.metrics.evolution.FlowEvolution" -> "src.core.metrics.evolution.EvolutionAnalyzer" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="flow", style="solid"];
"src.core.metrics.evolution.LFunctionComputation" -> "src.core.metrics.evolution.EvolutionAnalyzer" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="l_function", style="solid"];
"src.core.metrics.evolution.OrbitAnalysis" -> "src.core.metrics.evolution.EvolutionAnalyzer" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="orbit", style="solid"];
"src.core.metrics.height_theory.HeightStructure" -> "src.core.metrics.height_theory.AdaptiveHeightTheory" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="height_structure", style="solid"];
"src.core.models.base.LayerGeometryDict" -> "src.core.models.base.ModelGeometry" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="layers", style="solid"];
"src.core.patterns.dynamics.PatternDynamics" -> "src.core.flow.pattern.PatternFormationFlow" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="pattern_dynamics", style="solid"];
"src.core.patterns.dynamics.PatternDynamics" -> "src.core.patterns.pattern_processor.PatternProcessor" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="pattern_dynamics", style="solid"];
"src.core.patterns.dynamics.PatternDynamics" -> "src.core.tiling.patterns.pattern_fiber_bundle.PatternFiberBundle" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="pattern_dynamics", style="solid"];
"src.core.patterns.enriched_structure.PatternTransition" -> "src.core.flow.pattern.PatternFormationFlow" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="transition", style="solid"];
"src.core.patterns.enriched_structure.PatternTransition" -> "src.core.patterns.pattern_processor.PatternProcessor" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="transition", style="solid"];
"src.core.patterns.enriched_structure.PatternTransition" -> "src.core.tiling.patterns.pattern_fiber_bundle.PatternFiberBundle" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="transition", style="solid"];
"src.core.patterns.enriched_structure.WaveEmergence" -> "src.core.flow.pattern.PatternFormationFlow" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="wave", style="solid"];
"src.core.patterns.enriched_structure.WaveEmergence" -> "src.core.patterns.enriched_structure.PatternTransition" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="wave", style="solid"];
"src.core.patterns.enriched_structure.WaveEmergence" -> "src.core.patterns.pattern_processor.PatternProcessor" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="wave", style="solid"];
"src.core.patterns.enriched_structure.WaveEmergence" -> "src.core.tiling.patterns.pattern_fiber_bundle.PatternFiberBundle" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="wave", style="solid"];
"src.core.patterns.evolution.PatternEvolution" -> "src.core.flow.pattern.PatternFormationFlow" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="pattern_evolution", style="solid"];
"src.core.patterns.evolution.PatternEvolution" -> "src.core.patterns.pattern_processor.PatternProcessor" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="pattern_evolution", style="solid"];
"src.core.patterns.evolution.PatternEvolution" -> "src.core.tiling.patterns.pattern_fiber_bundle.PatternFiberBundle" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="pattern_evolution", style="solid"];
"src.core.patterns.fiber_types.FiberTypeManager" -> "src.core.tiling.patterns.pattern_fiber_bundle.PatternFiberBundle" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="fiber_type_manager", style="solid"];
"src.core.patterns.formation.PatternFormation" -> "src.core.flow.pattern.PatternFormationFlow" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="pattern_formation", style="solid"];
"src.core.patterns.formation.PatternFormation" -> "src.core.patterns.pattern_processor.PatternProcessor" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="pattern_formation", style="solid"];
"src.core.patterns.formation.PatternFormation" -> "src.core.tiling.patterns.pattern_fiber_bundle.PatternFiberBundle" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="pattern_formation", style="solid"];
"src.core.patterns.motivic_integration.MotivicIntegrationSystem" -> "src.core.patterns.operadic_handler.OperadicStructureHandler" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="motivic", style="solid"];
"src.core.patterns.motivic_integration.MotivicRiemannianStructureImpl" -> "src.core.patterns.motivic_integration.MotivicIntegrationSystem" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="geometry", style="solid"];
"src.core.patterns.motivic_integration.MotivicRiemannianStructureImpl" -> "src.core.patterns.pattern_processor.PatternProcessor" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="riemannian", style="solid"];
"src.core.patterns.operadic_structure.AttentionOperad" -> "src.core.flow.pattern.PatternFormationFlow" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="operadic", style="solid"];
"src.core.patterns.operadic_structure.AttentionOperad" -> "src.core.patterns.evolution.PatternEvolution" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="operadic", style="solid"];
"src.core.patterns.operadic_structure.AttentionOperad" -> "src.core.patterns.evolution.PatternEvolution" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="operadic", style="solid"];
"src.core.patterns.operadic_structure.AttentionOperad" -> "src.core.patterns.formation.BifurcationAnalyzer" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="operadic", style="solid"];
"src.core.patterns.operadic_structure.AttentionOperad" -> "src.core.patterns.formation.PatternFormation" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="operadic", style="solid"];
"src.core.patterns.operadic_structure.AttentionOperad" -> "src.core.patterns.operadic_handler.OperadicStructureHandler" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="operad", style="solid"];
"src.core.patterns.operadic_structure.AttentionOperad" -> "src.core.patterns.pattern_processor.PatternProcessor" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="operadic", style="solid"];
"src.core.patterns.operadic_structure.AttentionOperad" -> "src.core.patterns.symplectic.SymplecticStructure" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="operadic", style="solid"];
"src.core.patterns.operadic_structure.AttentionOperad" -> "src.core.tiling.patterns.pattern_fiber_bundle.PatternFiberBundle" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="operadic", style="solid"];
"src.core.patterns.operadic_structure.EnrichedAttention" -> "src.core.patterns.evolution.PatternEvolution" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="enriched", style="solid"];
"src.core.patterns.operadic_structure.EnrichedAttention" -> "src.core.patterns.formation.BifurcationAnalyzer" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="enriched", style="solid"];
"src.core.patterns.operadic_structure.EnrichedAttention" -> "src.core.patterns.formation.PatternFormation" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="enriched", style="solid"];
"src.core.patterns.operadic_structure.EnrichedAttention" -> "src.core.patterns.symplectic.SymplecticStructure" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="enriched", style="solid"];
"src.core.patterns.riemannian.PatternRiemannianStructure" -> "src.core.tiling.patterns.pattern_fiber_bundle.PatternFiberBundle" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="riemannian_framework", style="solid"];
"src.core.patterns.riemannian_flow.RiemannianFlow" -> "src.core.tiling.patterns.pattern_fiber_bundle.PatternFiberBundle" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="geometric_flow", style="solid"];
"src.core.patterns.symplectic.SymplecticStructure" -> "src.core.flow.pattern.PatternFormationFlow" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="symplectic", style="solid"];
"src.core.patterns.symplectic.SymplecticStructure" -> "src.core.patterns.evolution.PatternEvolution" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="symplectic", style="solid"];
"src.core.patterns.symplectic.SymplecticStructure" -> "src.core.patterns.evolution.PatternEvolution" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="symplectic", style="solid"];
"src.core.patterns.symplectic.SymplecticStructure" -> "src.core.patterns.formation.BifurcationAnalyzer" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="symplectic", style="solid"];
"src.core.patterns.symplectic.SymplecticStructure" -> "src.core.patterns.formation.PatternFormation" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="symplectic", style="solid"];
"src.core.patterns.symplectic.SymplecticStructure" -> "src.core.patterns.pattern_processor.PatternProcessor" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="symplectic", style="solid"];
"src.core.patterns.symplectic.SymplecticStructure" -> "src.core.tiling.patterns.pattern_fiber_bundle.PatternFiberBundle" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="symplectic", style="solid"];
"src.core.performance.cpu.algorithms.BranchOptimizer" -> "src.core.performance.cpu.algorithms.AlgorithmOptimizer" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="branch_opt", style="solid"];
"src.core.performance.cpu.algorithms.BranchOptimizer" -> "src.core.performance.cpu.algorithms.AlgorithmOptimizer" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="branch_opt", style="solid"];
"src.core.performance.cpu.algorithms.BranchOptimizer" -> "src.core.performance.cpu.algorithms.AlgorithmOptimizer" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="branch_opt", style="solid"];
"src.core.performance.cpu.algorithms.FastPathOptimizer" -> "src.core.performance.cpu.algorithms.AlgorithmOptimizer" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="fast_path", style="solid"];
"src.core.performance.cpu.algorithms.FastPathOptimizer" -> "src.core.performance.cpu.algorithms.AlgorithmOptimizer" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="fast_path", style="solid"];
"src.core.performance.cpu.algorithms.FastPathOptimizer" -> "src.core.performance.cpu.algorithms.AlgorithmOptimizer" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="fast_path", style="solid"];
"src.core.performance.cpu.algorithms.FastPathOptimizer" -> "src.core.performance.cpu.algorithms.AlgorithmOptimizer" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="fast_path", style="solid"];
"src.core.performance.cpu.algorithms.InstructionCounter" -> "src.core.performance.cpu.algorithms.AlgorithmOptimizer" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="instruction_counter", style="solid"];
"src.core.performance.cpu.algorithms.LoopOptimizer" -> "src.core.performance.cpu.algorithms.AlgorithmOptimizer" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="loop_opt", style="solid"];
"src.core.performance.cpu.algorithms.LoopOptimizer" -> "src.core.performance.cpu.algorithms.AlgorithmOptimizer" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="loop_opt", style="solid"];
"src.core.performance.cpu.algorithms.LoopOptimizer" -> "src.core.performance.cpu.algorithms.AlgorithmOptimizer" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="loop_opt", style="solid"];
"src.core.performance.cpu.algorithms.NumericalOptimizer" -> "src.core.performance.cpu.algorithms.AlgorithmOptimizer" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="numerical_opt", style="solid"];
"src.core.performance.cpu.algorithms.NumericalOptimizer" -> "src.core.performance.cpu.algorithms.AlgorithmOptimizer" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="numerical_opt", style="solid"];
"src.core.performance.cpu.memory.CacheOptimizer" -> "src.core.performance.cpu.memory.MemoryManager" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="cache_optimizer", style="solid"];
"src.core.performance.cpu.memory.MemoryPool" -> "src.core.performance.cpu.memory.MemoryManager" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="pool", style="solid"];
"src.core.performance.cpu.memory.MemoryPool" -> "src.core.performance.cpu.memory.MemoryManager" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="pool", style="solid"];
"src.core.scale_transition.ScaleTransitionLayer" -> "src.core.scale_transition.ScaleTransitionSystem" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="transition_layer", style="solid"];
"src.core.tiling.arithmetic_dynamics.ArithmeticDynamics" -> "src.core.flow.pattern.PatternFormationFlow" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="arithmetic", style="solid"];
"src.core.tiling.arithmetic_dynamics.ArithmeticDynamics" -> "src.core.patterns.motivic_integration.MotivicIntegrationSystem" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="dynamics", style="solid"];
"src.core.tiling.arithmetic_dynamics.ArithmeticDynamics" -> "src.core.patterns.pattern_processor.PatternProcessor" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="arithmetic", style="solid"];
"src.core.tiling.arithmetic_dynamics.ArithmeticDynamics" -> "src.core.tiling.geometric_flow.GeometricFlow" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="arithmetic", style="solid"];
"src.core.tiling.arithmetic_dynamics.ArithmeticPattern" -> "src.core.tiling.quantum_geometric_attention.QuantumGeometricAttention" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="arithmetic", style="solid"];
"src.core.tiling.arithmetic_dynamics.MotivicIntegrator" -> "src.core.patterns.motivic_integration.MotivicIntegrationSystem" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="integrator", style="solid"];
"src.core.tiling.geometric_flow.GeometricFlow" -> "src.core.tiling.quantum_geometric_attention.QuantumGeometricAttention" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="flow", style="solid"];
"src.core.tiling.optimization.parameter_manager.ParameterMonitor" -> "src.core.tiling.optimization.parameter_manager.AdaptiveParameterManager" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="monitor", style="solid"];
"src.core.tiling.patterns.cohomology.AdvancedMetricsAnalyzer" -> "src.core.tiling.patterns.cohomology.MotivicCohomology" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="metrics", style="solid"];
"src.core.tiling.patterns.cohomology.ArithmeticDynamics" -> "src.core.patterns.motivic_riemannian.MotivicRiemannianStructure" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="dynamics", style="solid"];
"src.core.tiling.patterns.cohomology.ArithmeticDynamics" -> "src.core.tiling.patterns.cohomology.MotivicCohomology" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="dynamics", style="solid"];
"src.core.tiling.patterns.cohomology.HeightStructure" -> "src.core.patterns.motivic_riemannian.MotivicRiemannianStructure" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="height_structure", style="solid"];
"src.core.tiling.patterns.cohomology.HeightStructure" -> "src.core.tiling.patterns.cohomology.MotivicCohomology" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="height_structure", style="solid"];
"src.core.tiling.patterns.cohomology.HeightStructure" -> "src.core.tiling.patterns.pattern_fiber_bundle.PatternFiberBundle" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="height_structure", style="solid"];
"src.core.tiling.patterns.cohomology.MotivicCohomology" -> "src.core.patterns.motivic_riemannian.MotivicRiemannianStructure" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="motive", style="solid"];
"src.core.tiling.patterns.cohomology.MotivicCohomology" -> "src.core.tiling.patterns.cohomology.QuantumMotivicCohomology" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="motivic", style="solid"];
"src.core.tiling.patterns.cohomology.QuantumMotivicCohomology" -> "src.core.patterns.motivic_integration.MotivicIntegrationSystem" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="cohomology", style="solid"];
"src.core.tiling.patterns.pattern_fiber_bundle.BundleConfig" -> "src.core.tiling.patterns.pattern_fiber_bundle.PatternFiberBundle" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="_config", style="solid"];
"src.core.tiling.patterns.pattern_fiber_bundle.PatternFiberBundle" -> "src.core.patterns.pattern_processor.PatternProcessor" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="pattern_bundle", style="solid"];
"src.core.tiling.quantum_attention_tile.QuantumMotivicTile" -> "src.core.tiling.quantum_geometric_attention.QuantumGeometricAttention" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="attention", style="solid"];
"src.core.tiling.state_manager.StateType" -> "src.core.tiling.state_manager.StateConfig" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="type", style="solid"];
"src.core.vulkan.memory.MemoryBlock" -> "src.core.vulkan.resources.BufferResource" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="memory", style="solid"];
"src.core.vulkan.memory.MemoryBlock" -> "src.core.vulkan.resources.ImageResource" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="memory", style="solid"];
"src.infrastructure.base.DeviceInfo" -> "src.infrastructure.base.VulkanIntegration" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="_device_info", style="solid"];
"src.infrastructure.metrics.PerformanceMetrics" -> "src.infrastructure.metrics.InfrastructureMetrics" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="performance", style="solid"];
"src.infrastructure.metrics.ResourceMetrics" -> "src.infrastructure.metrics.InfrastructureMetrics" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="resources", style="solid"];
"src.metrics.quantum_geometric_metrics.ArithmeticMetrics" -> "src.metrics.quantum_geometric_metrics.UnifiedMetrics" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="arithmetic", style="solid"];
"src.metrics.quantum_geometric_metrics.GeometricMetrics" -> "src.metrics.quantum_geometric_metrics.UnifiedMetrics" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="geometric", style="solid"];
"src.metrics.quantum_geometric_metrics.PatternMetrics" -> "src.metrics.quantum_geometric_metrics.UnifiedMetrics" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="pattern", style="solid"];
"src.metrics.quantum_geometric_metrics.QuantumMetrics" -> "src.metrics.quantum_geometric_metrics.UnifiedMetrics" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="quantum", style="solid"];
"src.utils.memory_management.TensorManager" -> "src.utils.memory_management.MemoryOptimizer" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="tensor_manager", style="solid"];
"src.validation.quantum.evolution.AdiabaticValidator" -> "src.validation.quantum.evolution.QuantumEvolutionValidator" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="adiabatic_validator", style="solid"];
"src.validation.quantum.evolution.DecoherenceValidator" -> "src.validation.quantum.evolution.QuantumEvolutionValidator" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="decoherence_validator", style="solid"];
"src.validation.quantum.evolution.UnitaryValidator" -> "src.validation.quantum.evolution.QuantumEvolutionValidator" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="unitary_validator", style="solid"];
"src.validation.quantum.state.DensityMatrixValidator" -> "src.validation.quantum.state.QuantumStateValidator" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="density_validator", style="solid"];
"src.validation.quantum.state.DensityMatrixValidator" -> "src.validation.quantum.state.StatePreparationValidator" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="density_validator", style="solid"];
"src.validation.quantum.state.DensityMatrixValidator" -> "src.validation.quantum.state.StateValidator" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="density_validator", style="solid"];
"src.validation.quantum.state.StatePreparationValidator" -> "src.core.flow.quantum.GeometricFlowAnalyzer" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="preparation_validator", style="solid"];
"src.validation.quantum.state.StatePreparationValidator" -> "src.validation.quantum.state.QuantumStateValidator" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="preparation_validator", style="solid"];
"src.validation.quantum.state.StatePreparationValidator" -> "src.validation.quantum.state.StateValidator" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="preparation_validator", style="solid"];
"src.validation.quantum.state.StateValidator" -> "src.core.flow.quantum.GeometricFlowAnalyzer" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="state_validator", style="solid"];
"src.validation.quantum.state.StateValidator" -> "src.core.flow.quantum.QuantumGeometricFlow" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="state_validator", style="solid"];
"src.validation.quantum.state.StateValidator" -> "src.validation.quantum.evolution.DecoherenceValidator" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="state_validator", style="solid"];
"src.validation.quantum.state.TomographyValidator" -> "src.core.flow.quantum.QuantumGeometricFlow" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="tomography_validator", style="solid"];
"src.validation.quantum.state.TomographyValidator" -> "src.validation.quantum.state.QuantumStateValidator" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="tomography_validator", style="solid"];
"src.validation.quantum.state.TomographyValidator" -> "src.validation.quantum.state.StatePreparationValidator" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="tomography_validator", style="solid"];
"src.validation.quantum.state.TomographyValidator" -> "src.validation.quantum.state.StateValidator" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="tomography_validator", style="solid"];
"src.core.flow.quantum.QuantumGeometricFlow" -> "src.core.flow.quantum.GeometricFlowAnalyzer" [arrowhead="odiamond", arrowtail="none", fontcolor="green", label="flow", style="solid"];
"src.core.patterns.riemannian.PatternRiemannianStructure" -> "src.core.tiling.patterns.cohomology.DeRhamCohomology" [arrowhead="odiamond", arrowtail="none", fontcolor="green", label="manifold", style="solid"];
"src.core.patterns.riemannian.PatternRiemannianStructure" -> "src.core.tiling.patterns.cohomology.Integration" [arrowhead="odiamond", arrowtail="none", fontcolor="green", label="manifold", style="solid"];
"src.core.patterns.riemannian.PatternRiemannianStructure" -> "src.core.tiling.patterns.cohomology.QuantumMotivicCohomology" [arrowhead="odiamond", arrowtail="none", fontcolor="green", label="metric", style="solid"];
"src.core.patterns.riemannian.RiemannianFramework" -> "src.core.patterns.evolution.PatternEvolution" [arrowhead="odiamond", arrowtail="none", fontcolor="green", label="framework", style="solid"];
"src.core.scale_transition.ScaleTransitionConfig" -> "src.core.scale_transition.ScaleFlowIntegrator" [arrowhead="odiamond", arrowtail="none", fontcolor="green", label="config", style="solid"];
"src.core.scale_transition.ScaleTransitionConfig" -> "src.core.scale_transition.ScaleTransitionLayer" [arrowhead="odiamond", arrowtail="none", fontcolor="green", label="config", style="solid"];
"src.core.scale_transition.ScaleTransitionConfig" -> "src.core.scale_transition.ScaleTransitionSystem" [arrowhead="odiamond", arrowtail="none", fontcolor="green", label="config", style="solid"];
"src.core.tiling.patterns.cohomology.ArithmeticDynamics" -> "src.core.patterns.motivic_riemannian.MotivicChristoffelSymbols" [arrowhead="odiamond", arrowtail="none", fontcolor="green", label="dynamics", style="solid"];
"src.core.tiling.patterns.cohomology.FiberBundle" -> "src.core.tiling.patterns.cohomology.CohomologyGroup" [arrowhead="odiamond", arrowtail="none", fontcolor="green", label="base_space", style="solid"];
"src.core.tiling.patterns.cohomology.HeightStructure" -> "src.core.patterns.motivic_riemannian.MotivicMetricTensor" [arrowhead="odiamond", arrowtail="none", fontcolor="green", label="height_structure", style="solid"];
"src.core.tiling.patterns.cohomology.MotivicCohomology" -> "src.core.patterns.motivic_riemannian.MotivicCurvatureTensor" [arrowhead="odiamond", arrowtail="none", fontcolor="green", label="motive", style="solid"];
"src.core.tiling.patterns.cohomology.RiemannianFiberBundle" -> "src.core.tiling.patterns.cohomology.MotivicCohomology" [arrowhead="odiamond", arrowtail="none", fontcolor="green", label="base_space", style="solid"];
"src.core.tiling.state_manager.StateConfig" -> "src.core.tiling.state_manager.StateManager" [arrowhead="odiamond", arrowtail="none", fontcolor="green", label="config", style="solid"];
"src.core.vulkan.memory.VulkanMemory" -> "src.core.vulkan.resources.VulkanResources" [arrowhead="odiamond", arrowtail="none", fontcolor="green", label="memory", style="solid"];
"src.metrics.quantum_geometric_metrics.MetricDomain" -> "src.metrics.quantum_geometric_metrics.BaseMetric" [arrowhead="odiamond", arrowtail="none", fontcolor="green", label="domain", style="solid"];
"src.validation.quantum.state.QuantumStateValidator" -> "src.validation.framework.ValidationFramework" [arrowhead="odiamond", arrowtail="none", fontcolor="green", label="quantum_validator", style="solid"];
}

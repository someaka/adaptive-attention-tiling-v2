digraph "classes_quantum_patterns" {
rankdir=BT
charset="utf-8"
"src.core.metrics.height_theory.AdaptiveHeightTheory" [color="black", fontcolor="black", label=<{AdaptiveHeightTheory|height_projection : Linear<br ALIGN="LEFT"/>height_structure<br ALIGN="LEFT"/>hidden_dim : int<br ALIGN="LEFT"/>history<br ALIGN="LEFT"/>optimizer : Adam<br ALIGN="LEFT"/>|adapt(loss: torch.Tensor): None<br ALIGN="LEFT"/>forward(x: torch.Tensor): Tuple[torch.Tensor, Dict[str, torch.Tensor]]<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.core.tiling.optimization.parameter_manager.AdaptiveParameterManager" [color="black", fontcolor="black", label=<{AdaptiveParameterManager|adapt_factor : float<br ALIGN="LEFT"/>base_lr : float<br ALIGN="LEFT"/>learning_rates : Dict[str, float]<br ALIGN="LEFT"/>max_lr : float<br ALIGN="LEFT"/>min_lr : float<br ALIGN="LEFT"/>momentum : float<br ALIGN="LEFT"/>monitor<br ALIGN="LEFT"/>velocities : Dict[str, torch.Tensor]<br ALIGN="LEFT"/>|get_lr(name: str): float<br ALIGN="LEFT"/>get_state_dict(): Dict<br ALIGN="LEFT"/>load_state_dict(state_dict: Dict)<br ALIGN="LEFT"/>step(name: str, param: nn.Parameter, grad: Optional[torch.Tensor])<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.core.metrics.advanced_metrics.AdvancedMetricsAnalyzer" [color="black", fontcolor="black", label=<{AdvancedMetricsAnalyzer|history : Dict[str, List[float]]<br ALIGN="LEFT"/>|compute_cross_tile_flow(pattern: torch.Tensor, tile_size: int): float<br ALIGN="LEFT"/>compute_edge_utilization(pattern: torch.Tensor, edge_threshold: float): float<br ALIGN="LEFT"/>compute_ifq(pattern: torch.Tensor, tile_size: int, window_size: int, edge_threshold: float): InformationFlowMetrics<br ALIGN="LEFT"/>compute_info_density(pattern: torch.Tensor): float<br ALIGN="LEFT"/>compute_pattern_stability(pattern: torch.Tensor, window_size: int): float<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.core.tiling.patterns.cohomology.AdvancedMetricsAnalyzer" [color="black", fontcolor="black", label=<{AdvancedMetricsAnalyzer|<br ALIGN="LEFT"/>|compute_ifq(pattern_stability: float, cross_tile_flow: float, edge_utilization: float, info_density: float): float<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.core.performance.cpu.algorithms.AlgorithmMetrics" [color="black", fontcolor="black", label=<{AlgorithmMetrics|branch_misses : int<br ALIGN="LEFT"/>execution_time : float<br ALIGN="LEFT"/>instruction_count : int<br ALIGN="LEFT"/>numerical_error : float<br ALIGN="LEFT"/>optimization_type : str<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"src.core.performance.cpu.algorithms.AlgorithmOptimizer" [color="black", fontcolor="black", label=<{AlgorithmOptimizer|branch_opt : NoneType<br ALIGN="LEFT"/>enable_profiling : bool<br ALIGN="LEFT"/>fast_path : NoneType<br ALIGN="LEFT"/>instruction_counter<br ALIGN="LEFT"/>loop_opt : NoneType<br ALIGN="LEFT"/>metrics : List[AlgorithmMetrics]<br ALIGN="LEFT"/>numerical_opt : NoneType<br ALIGN="LEFT"/>operations : Dict[str, Callable]<br ALIGN="LEFT"/>optimization_level : str<br ALIGN="LEFT"/>|clear_metrics(): None<br ALIGN="LEFT"/>get_metrics(): List[AlgorithmMetrics]<br ALIGN="LEFT"/>optimize_algorithm(func: Callable): Callable<br ALIGN="LEFT"/>optimize_operation(operation_name: str): Any<br ALIGN="LEFT"/>register_fast_path(name: str, implementation: Callable, condition: Callable[..., bool]): None<br ALIGN="LEFT"/>register_operation(name: str, operation: Callable): None<br ALIGN="LEFT"/>set_optimization_level(level: str): None<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.core.tiling.arithmetic_dynamics.ArithmeticDynamics" [color="black", fontcolor="black", label=<{ArithmeticDynamics|adelic_proj : Linear<br ALIGN="LEFT"/>coupling : Parameter<br ALIGN="LEFT"/>flow : Linear<br ALIGN="LEFT"/>height_dim : int<br ALIGN="LEFT"/>height_map : Linear<br ALIGN="LEFT"/>hidden_dim : int<br ALIGN="LEFT"/>l_function : Sequential<br ALIGN="LEFT"/>motive_rank : int<br ALIGN="LEFT"/>num_primes : int<br ALIGN="LEFT"/>output_proj : Linear<br ALIGN="LEFT"/>|compute_dynamics(x: torch.Tensor): torch.Tensor<br ALIGN="LEFT"/>compute_height(x: torch.Tensor): torch.Tensor<br ALIGN="LEFT"/>compute_modular_form(x: torch.Tensor): torch.Tensor<br ALIGN="LEFT"/>compute_motivic_integral(x: torch.Tensor, num_samples: int): torch.Tensor<br ALIGN="LEFT"/>forward(x: torch.Tensor, steps: int, return_trajectory: bool): Tuple[torch.Tensor, Dict]<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.core.tiling.patterns.cohomology.ArithmeticDynamics" [color="black", fontcolor="black", label=<{ArithmeticDynamics|flow : Linear<br ALIGN="LEFT"/>hidden_dim : int<br ALIGN="LEFT"/>hidden_proj : Sequential<br ALIGN="LEFT"/>l_function : Sequential<br ALIGN="LEFT"/>motive_rank : int<br ALIGN="LEFT"/>num_primes : int<br ALIGN="LEFT"/>|compute_dynamics(state: torch.Tensor): torch.Tensor<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.core.tiling.patterns.cohomology.ArithmeticForm" [color="black", fontcolor="black", label=<{ArithmeticForm|coefficients : Tensor<br ALIGN="LEFT"/>degree : int<br ALIGN="LEFT"/>dynamics_state : Optional[torch.Tensor]<br ALIGN="LEFT"/>height_data : Optional[torch.Tensor]<br ALIGN="LEFT"/>prime_bases : Optional[torch.Tensor]<br ALIGN="LEFT"/>|exterior_derivative(): 'ArithmeticForm'<br ALIGN="LEFT"/>wedge(other: 'ArithmeticForm'): 'ArithmeticForm'<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.core.tiling.arithmetic_dynamics.ArithmeticPattern" [color="black", fontcolor="black", label=<{ArithmeticPattern|hidden_dim : int<br ALIGN="LEFT"/>input_dim : int<br ALIGN="LEFT"/>layers : ModuleList<br ALIGN="LEFT"/>motive_rank : int<br ALIGN="LEFT"/>num_layers : int<br ALIGN="LEFT"/>pattern_proj : Linear<br ALIGN="LEFT"/>|forward(x: torch.Tensor): Tuple[torch.Tensor, List[Dict]]<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.core.attention.compute.AttentionCompute" [color="black", fontcolor="black", label=<{AttentionCompute|dropout : float<br ALIGN="LEFT"/>|compute_output(scores: torch.Tensor, value: torch.Tensor): torch.Tensor<br ALIGN="LEFT"/>compute_scores(query: torch.Tensor, key: torch.Tensor, mask: Optional[torch.Tensor], scale: Optional[float]): torch.Tensor<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.core.tiling.quantum_geometric_attention.AttentionMetrics" [color="black", fontcolor="black", label=<{AttentionMetrics|complexity : Tensor<br ALIGN="LEFT"/>entropy : Tensor<br ALIGN="LEFT"/>sparsity : Optional[torch.Tensor]<br ALIGN="LEFT"/>stability : Optional[torch.Tensor]<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"src.core.tiling.quantum_geometric_attention.AttentionState" [color="black", fontcolor="black", label=<{AttentionState|attention_scores : Optional[torch.Tensor]<br ALIGN="LEFT"/>geometric_state : Tensor<br ALIGN="LEFT"/>quantum_state : Tensor<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"src.core.attention.base.BaseAttention" [color="black", fontcolor="black", label=<{BaseAttention|backend : AttentionBackend<br ALIGN="LEFT"/>|forward(query: torch.Tensor, key: torch.Tensor, value: torch.Tensor, mask: Optional[torch.Tensor]): torch.Tensor<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.core.patterns.fiber_bundle.BaseFiberBundle" [color="black", fontcolor="black", label=<{BaseFiberBundle|base_dim : int<br ALIGN="LEFT"/>connection<br ALIGN="LEFT"/>fiber_dim : int<br ALIGN="LEFT"/>metric<br ALIGN="LEFT"/>structure_group : Optional[str]<br ALIGN="LEFT"/>total_dim<br ALIGN="LEFT"/>|bundle_projection(total_space: Tensor): Tensor<br ALIGN="LEFT"/>compute_holonomy_algebra(holonomies: List[Tensor]): Tensor<br ALIGN="LEFT"/>compute_holonomy_group(holonomies: List[Tensor]): Tensor<br ALIGN="LEFT"/>connection_form(tangent_vector: Tensor): Tensor<br ALIGN="LEFT"/>local_trivialization(point: Tensor): Tuple[LocalChart[Tensor], FiberChart[Tensor, str]]<br ALIGN="LEFT"/>parallel_transport(section: Tensor, path: Tensor): Tensor<br ALIGN="LEFT"/>transition_functions(chart1: LocalChart[Tensor], chart2: LocalChart[Tensor]): Tensor<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.core.patterns.riemannian.BaseRiemannianStructure" [color="black", fontcolor="black", label=<{BaseRiemannianStructure|cache : Dict[str, Any]<br ALIGN="LEFT"/>connection_coeffs : Parameter<br ALIGN="LEFT"/>device : device<br ALIGN="LEFT"/>dtype : Ellipsis<br ALIGN="LEFT"/>manifold_dim : int<br ALIGN="LEFT"/>metric_factors : Parameter<br ALIGN="LEFT"/>|compute_christoffel(points: Tensor): ChristoffelSymbols[Tensor]<br ALIGN="LEFT"/>compute_curvature(points: Tensor, christoffel: Optional[ChristoffelSymbols[Tensor]]): CurvatureTensor[Tensor]<br ALIGN="LEFT"/>compute_metric(points: Tensor): MetricTensor[Tensor]<br ALIGN="LEFT"/>exp_map(point: Tensor, vector: Tensor): Tensor<br ALIGN="LEFT"/>geodesic_flow(initial_point: Tensor, initial_velocity: Tensor, steps: int, step_size: float): Tuple[Tensor, Tensor]<br ALIGN="LEFT"/>lie_derivative_metric(point: Tensor, vector_field: Callable[[Tensor], Tensor]): MetricTensor[Tensor]<br ALIGN="LEFT"/>parallel_transport(vector: Tensor, path: Tensor, connection: Optional[ChristoffelSymbols[Tensor]]): Tensor<br ALIGN="LEFT"/>sectional_curvature(point: Tensor, v1: Tensor, v2: Tensor): Tensor<br ALIGN="LEFT"/>validate_connection_properties(connection: ChristoffelSymbols[Tensor]): bool<br ALIGN="LEFT"/>validate_metric_properties(metric: MetricTensor[Tensor]): bool<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.core.benchmarks.metrics.BenchmarkMetrics" [color="black", fontcolor="black", label=<{BenchmarkMetrics|backward_time : float<br ALIGN="LEFT"/>batch_size : int<br ALIGN="LEFT"/>device : str<br ALIGN="LEFT"/>efficiency : float<br ALIGN="LEFT"/>flops : float<br ALIGN="LEFT"/>forward_time : float<br ALIGN="LEFT"/>memory_allocated_mb : float<br ALIGN="LEFT"/>memory_pool : Optional[MemoryPoolManager]<br ALIGN="LEFT"/>num_parameters : int<br ALIGN="LEFT"/>operations : List[OperationMetrics]<br ALIGN="LEFT"/>peak_memory_mb : float<br ALIGN="LEFT"/>throughput : float<br ALIGN="LEFT"/>total_time : float<br ALIGN="LEFT"/>|compute_throughput()<br ALIGN="LEFT"/>from_model(model: torch.nn.Module, input_size: tuple): 'BenchmarkMetrics'<br ALIGN="LEFT"/>record_operation(name: str)<br ALIGN="LEFT"/>to_dict(): Dict[str, Union[float, int, Dict[str, Any]]]<br ALIGN="LEFT"/>update_memory()<br ALIGN="LEFT"/>update_timing(forward_time: float, backward_time: float)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.core.patterns.formation.BifurcationAnalyzer" [color="black", fontcolor="black", label=<{BifurcationAnalyzer|threshold : float<br ALIGN="LEFT"/>window_size : int<br ALIGN="LEFT"/>|analyze_stability(pattern: torch.Tensor, parameter_range: Tuple[float, float], num_points: int): Dict[str, Any]<br ALIGN="LEFT"/>detect_bifurcations(pattern: torch.Tensor, parameter: torch.Tensor): List[float]<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.core.performance.cpu.algorithms.BranchOptimizer" [color="black", fontcolor="black", label=<{BranchOptimizer|branch_stats : Dict[str, Dict[bool, int]]<br ALIGN="LEFT"/>|likely(condition: bool, branch_id: str): bool<br ALIGN="LEFT"/>optimize_branches(func: Callable): Callable<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.core.vulkan.resources.BufferResource" [color="black", fontcolor="black", label=<{BufferResource|buffer : int<br ALIGN="LEFT"/>memory<br ALIGN="LEFT"/>size : int<br ALIGN="LEFT"/>usage : int<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"src.core.performance.cpu_memory.CPUMemoryManager" [color="black", fontcolor="black", label=<{CPUMemoryManager|<br ALIGN="LEFT"/>|allocate_tensor(size: Union[Tuple[int, ...], torch.Size], dtype: Any): torch.Tensor<br ALIGN="LEFT"/>cleanup(): None<br ALIGN="LEFT"/>copy_from_device(src: torch.Tensor, dst: Union[torch.Tensor, np.ndarray]): None<br ALIGN="LEFT"/>copy_to_device(src: Union[torch.Tensor, np.ndarray], dst: torch.Tensor): None<br ALIGN="LEFT"/>free_tensor(tensor: torch.Tensor): None<br ALIGN="LEFT"/>get_fragmentation_ratio(): float<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.core.performance.cpu_optimizer.CPUOptimizer" [color="black", fontcolor="black", label=<{CPUOptimizer|cpu_profiler : Profile<br ALIGN="LEFT"/>enable_memory_tracking : bool<br ALIGN="LEFT"/>enable_profiling : bool<br ALIGN="LEFT"/>line_profiler : LineProfiler<br ALIGN="LEFT"/>memory_profiler<br ALIGN="LEFT"/>|get_performance_metrics(): PerformanceMetrics<br ALIGN="LEFT"/>optimize_computation(computation_graph: torch.nn.Module, sample_input: torch.Tensor): torch.nn.Module<br ALIGN="LEFT"/>optimize_memory_access(tensor: torch.Tensor): torch.Tensor<br ALIGN="LEFT"/>profile_execution(func: Callable): Callable<br ALIGN="LEFT"/>vectorize_operation(func: Callable[..., torch.Tensor], inputs: List[torch.Tensor], chunk_size: Optional[int]): torch.Tensor<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.core.performance.cpu.memory.CacheOptimizer" [color="black", fontcolor="black", label=<{CacheOptimizer|cache_line_size : int<br ALIGN="LEFT"/>stats : dict<br ALIGN="LEFT"/>|optimize_layout(tensor: torch.Tensor): torch.Tensor<br ALIGN="LEFT"/>prefetch(tensor: torch.Tensor, indices: torch.Tensor): None<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.core.patterns.riemannian_base copy.ChristoffelSymbols" [color="black", fontcolor="black", label=<{ChristoffelSymbols|is_symmetric : bool<br ALIGN="LEFT"/>metric : MetricTensor[T]<br ALIGN="LEFT"/>values : T<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"src.core.patterns.riemannian_base.ChristoffelSymbols" [color="black", fontcolor="black", label=<{ChristoffelSymbols|is_symmetric : bool<br ALIGN="LEFT"/>metric : MetricTensor[T]<br ALIGN="LEFT"/>values : T<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"src.core.tiling.patterns.cohomology.CohomologyGroup" [color="black", fontcolor="black", label=<{CohomologyGroup|base_space<br ALIGN="LEFT"/>boundaries : List[ArithmeticForm]<br ALIGN="LEFT"/>degree : int<br ALIGN="LEFT"/>representatives : List[ArithmeticForm]<br ALIGN="LEFT"/>|add_cocycle(form: ArithmeticForm): None<br ALIGN="LEFT"/>cup_product(other: 'CohomologyGroup'): 'CohomologyGroup'<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.core.performance.vulkan.shaders.ComputeShaderDispatcher" [color="black", fontcolor="black", label=<{ComputeShaderDispatcher|command_pool : c_void_p<br ALIGN="LEFT"/>device : c_void_p<br ALIGN="LEFT"/>queue : c_void_p<br ALIGN="LEFT"/>|dispatch(pipeline: VkPipeline, pipeline_layout: VkPipelineLayout, descriptor_set: VkDescriptorSet, push_constants: Optional[bytes], group_count: Tuple[int, int, int]): None<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.core.vulkan.resources.ConvertibleToInt" [color="black", fontcolor="black", label=<{ConvertibleToInt|<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"src.core.patterns.riemannian_base copy.CurvatureTensor" [color="black", fontcolor="black", label=<{CurvatureTensor|ricci : T<br ALIGN="LEFT"/>riemann : T<br ALIGN="LEFT"/>scalar : Union<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"src.core.patterns.riemannian_base.CurvatureTensor" [color="black", fontcolor="black", label=<{CurvatureTensor|ricci : T<br ALIGN="LEFT"/>riemann : T<br ALIGN="LEFT"/>scalar_curvatures : T<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"src.core.tiling.patterns.cohomology.DeRhamCohomology" [color="black", fontcolor="black", label=<{DeRhamCohomology|cohomology_groups : List[CohomologyGroup]<br ALIGN="LEFT"/>manifold<br ALIGN="LEFT"/>|betti_numbers(): List[int]<br ALIGN="LEFT"/>compute_cohomology(max_degree: int): None<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.core.metrics.evolution.ErgodicAnalysis" [color="black", fontcolor="black", label=<{ErgodicAnalysis|hidden_dim : int<br ALIGN="LEFT"/>history : List[torch.Tensor]<br ALIGN="LEFT"/>num_observables : int<br ALIGN="LEFT"/>observables : ModuleList<br ALIGN="LEFT"/>|compute_ergodic_average(pattern: torch.Tensor): torch.Tensor<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.core.attention.geometric.EuclideanExponential" [color="black", fontcolor="black", label=<{EuclideanExponential|dim : int<br ALIGN="LEFT"/>|forward(x: torch.Tensor, v: torch.Tensor): torch.Tensor<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.core.attention.geometric.EuclideanLogarithm" [color="black", fontcolor="black", label=<{EuclideanLogarithm|dim : int<br ALIGN="LEFT"/>|forward(x: torch.Tensor, y: torch.Tensor): torch.Tensor<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.core.metrics.evolution.EvolutionAnalyzer" [color="black", fontcolor="black", label=<{EvolutionAnalyzer|ergodic<br ALIGN="LEFT"/>flow<br ALIGN="LEFT"/>l_function<br ALIGN="LEFT"/>orbit<br ALIGN="LEFT"/>|analyze_evolution(pattern: torch.Tensor): EvolutionMetrics<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.core.metrics.evolution.EvolutionMetrics" [color="black", fontcolor="black", label=<{EvolutionMetrics|ergodic_avg : Tensor<br ALIGN="LEFT"/>flow_metrics : Tensor<br ALIGN="LEFT"/>l_values : Tensor<br ALIGN="LEFT"/>orbit_stats : Dict[str, float]<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"src.core.performance.cpu.algorithms.FastPathDict" [color="black", fontcolor="black", label=<{FastPathDict|condition : Callable[..., bool]<br ALIGN="LEFT"/>implementation : Callable[..., Any]<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"src.core.performance.cpu.algorithms.FastPathOptimizer" [color="black", fontcolor="black", label=<{FastPathOptimizer|fast_paths : Dict[str, FastPathDict]<br ALIGN="LEFT"/>path_stats : Dict[str, int]<br ALIGN="LEFT"/>|optimize(func: Callable[..., T]): Callable[..., T]<br ALIGN="LEFT"/>register_fast_path(name: str, condition: Callable[..., bool], implementation: Callable[..., Any]): None<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.core.tiling.patterns.fiber_bundle.FiberBundle" [color="black", fontcolor="black", label=<{FiberBundle|<br ALIGN="LEFT"/>|bundle_projection(total_space: T): T<br ALIGN="LEFT"/>connection_form(tangent_vector: T): T<br ALIGN="LEFT"/>local_trivialization(point: T): Tuple[LocalChart[T], FiberChart[T, str]]<br ALIGN="LEFT"/>parallel_transport(section: T, path: T): T<br ALIGN="LEFT"/>transition_functions(chart1: T, chart2: T): T<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.core.tiling.patterns.cohomology.FiberBundle" [color="black", fontcolor="black", label=<{FiberBundle|<br ALIGN="LEFT"/>|get_connection(point: torch.Tensor): torch.Tensor<br ALIGN="LEFT"/>get_fiber(point: torch.Tensor): torch.Tensor<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.core.tiling.patterns.fiber_bundle.FiberChart" [color="black", fontcolor="black", label=<{FiberChart|fiber_coordinates : T<br ALIGN="LEFT"/>structure_group : StructureGroup<br ALIGN="LEFT"/>transition_functions : dict<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"src.core.flow.computation.FlowComputation" [color="black", fontcolor="black", label=<{FlowComputation|dim : int<br ALIGN="LEFT"/>potential : Sequential<br ALIGN="LEFT"/>vector_field : Sequential<br ALIGN="LEFT"/>|compute_gradient_flow(x: torch.Tensor, steps: int, step_size: float): List[torch.Tensor]<br ALIGN="LEFT"/>compute_hamiltonian_flow(x: torch.Tensor, p: torch.Tensor, steps: int, step_size: float): Tuple[List[torch.Tensor], List[torch.Tensor]]<br ALIGN="LEFT"/>compute_parallel_transport(curve: List[torch.Tensor], initial_vector: torch.Tensor): List[torch.Tensor]<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.core.metrics.evolution.FlowEvolution" [color="black", fontcolor="black", label=<{FlowEvolution|flow : Linear<br ALIGN="LEFT"/>flow_dim : int<br ALIGN="LEFT"/>hidden_dim : int<br ALIGN="LEFT"/>history : List[torch.Tensor]<br ALIGN="LEFT"/>|compute_flow(pattern: torch.Tensor): torch.Tensor<br ALIGN="LEFT"/>get_evolution_stats(window_size: int): Dict[str, torch.Tensor]<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.core.tiling.quantum_geometric_attention.FlowMetrics" [color="black", fontcolor="black", label=<{FlowMetrics|curvature : Tensor<br ALIGN="LEFT"/>energy : Tensor<br ALIGN="LEFT"/>geodesic_distance : Tensor<br ALIGN="LEFT"/>parallel_transport : Tensor<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"src.core.performance.gpu.memory_management.GPUMemoryManager" [color="black", fontcolor="black", label=<{GPUMemoryManager|device : device<br ALIGN="LEFT"/>|allocate(size: tuple, dtype: torch.dtype): torch.Tensor<br ALIGN="LEFT"/>clear_cache()<br ALIGN="LEFT"/>free(tensor: torch.Tensor)<br ALIGN="LEFT"/>get_memory_stats(): Dict[str, float]<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.core.tiling.geometric_flow.GeometricFlow" [color="black", fontcolor="black", label=<{GeometricFlow|arithmetic<br ALIGN="LEFT"/>chart_embedding : Parameter<br ALIGN="LEFT"/>dt : float<br ALIGN="LEFT"/>flow_field : ModuleList<br ALIGN="LEFT"/>hamiltonian : Sequential<br ALIGN="LEFT"/>hidden_dim : int<br ALIGN="LEFT"/>integration_steps : int<br ALIGN="LEFT"/>manifold_dim : int<br ALIGN="LEFT"/>metric<br ALIGN="LEFT"/>motive_rank : int<br ALIGN="LEFT"/>num_charts : int<br ALIGN="LEFT"/>stability_threshold : float<br ALIGN="LEFT"/>|adapt_timestep(stability: float): float<br ALIGN="LEFT"/>check_stability(metrics_history: List[float]): float<br ALIGN="LEFT"/>compute_metric(x: torch.Tensor): torch.Tensor<br ALIGN="LEFT"/>compute_metric_component(x: torch.Tensor, tangent: torch.Tensor, i: int, j: int): torch.Tensor<br ALIGN="LEFT"/>compute_ricci_curvature(x: torch.Tensor, metric: torch.Tensor): torch.Tensor<br ALIGN="LEFT"/>compute_scalar_curvature(riemann: torch.Tensor, metric: torch.Tensor): torch.Tensor<br ALIGN="LEFT"/>evolve_metric(x: torch.Tensor, metric: torch.Tensor, dt: float): torch.Tensor<br ALIGN="LEFT"/>flow_proj(x: torch.Tensor): torch.Tensor<br ALIGN="LEFT"/>forward(x: torch.Tensor, return_path: bool): Tuple[torch.Tensor, Dict]<br ALIGN="LEFT"/>tangent_proj(x: torch.Tensor): torch.Tensor<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.core.tiling.config.GeometricFlowConfig" [color="black", fontcolor="black", label=<{GeometricFlowConfig|MAX_DENSITY : float<br ALIGN="LEFT"/>MIN_DENSITY : float<br ALIGN="LEFT"/>MIN_RESOLUTION : float<br ALIGN="LEFT"/>adam_epsilon : float<br ALIGN="LEFT"/>attention_probs_dropout_prob : float<br ALIGN="LEFT"/>curvature_threshold : float<br ALIGN="LEFT"/>dim : int<br ALIGN="LEFT"/>dropout : float<br ALIGN="LEFT"/>entanglement_threshold : float<br ALIGN="LEFT"/>flow_epsilon : float<br ALIGN="LEFT"/>flow_lr : float<br ALIGN="LEFT"/>flow_steps : int<br ALIGN="LEFT"/>hidden_act : str<br ALIGN="LEFT"/>hidden_dropout_prob : float<br ALIGN="LEFT"/>hidden_size : int<br ALIGN="LEFT"/>initializer_range : float<br ALIGN="LEFT"/>intermediate_size : int<br ALIGN="LEFT"/>layer_norm_eps : float<br ALIGN="LEFT"/>layer_norm_eps_geometric : float<br ALIGN="LEFT"/>learning_rate : float<br ALIGN="LEFT"/>max_delta : float<br ALIGN="LEFT"/>max_grad_norm : float<br ALIGN="LEFT"/>max_position_embeddings : int<br ALIGN="LEFT"/>max_position_embeddings_geometric : int<br ALIGN="LEFT"/>measurement_samples : int<br ALIGN="LEFT"/>min_delta : float<br ALIGN="LEFT"/>num_attention_heads : int<br ALIGN="LEFT"/>num_heads : int<br ALIGN="LEFT"/>num_hidden_layers : int<br ALIGN="LEFT"/>quantum_dim : int<br ALIGN="LEFT"/>stability_threshold : float<br ALIGN="LEFT"/>warmup_steps : int<br ALIGN="LEFT"/>weight_decay : float<br ALIGN="LEFT"/>|from_dict(config_dict: Dict[str, Any]): 'GeometricFlowConfig'<br ALIGN="LEFT"/>to_dict(): Dict[str, Any]<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.core.attention.geometric.GeometricStructures" [color="black", fontcolor="black", label=<{GeometricStructures|connection : Parameter<br ALIGN="LEFT"/>curvature : float<br ALIGN="LEFT"/>curvature_tensor : Parameter<br ALIGN="LEFT"/>dim : int<br ALIGN="LEFT"/>exp_map : Union[HyperbolicExponential, EuclideanExponential]<br ALIGN="LEFT"/>log_map : Union[HyperbolicLogarithm, EuclideanLogarithm]<br ALIGN="LEFT"/>manifold_type : Literal['hyperbolic', 'euclidean']<br ALIGN="LEFT"/>metric : Parameter<br ALIGN="LEFT"/>num_heads : int<br ALIGN="LEFT"/>parallel_transport_method : Literal['schild', 'pole']<br ALIGN="LEFT"/>transport<br ALIGN="LEFT"/>|compute_exponential_map(x: torch.Tensor, v: torch.Tensor): torch.Tensor<br ALIGN="LEFT"/>compute_geodesic(x: torch.Tensor, v: torch.Tensor, steps: int): torch.Tensor<br ALIGN="LEFT"/>compute_geodesic_distance(x: torch.Tensor, y: torch.Tensor): torch.Tensor<br ALIGN="LEFT"/>compute_logarithmic_map(x: torch.Tensor, y: torch.Tensor): torch.Tensor<br ALIGN="LEFT"/>compute_sectional_curvature(x: torch.Tensor, v1: torch.Tensor, v2: torch.Tensor): torch.Tensor<br ALIGN="LEFT"/>forward(x: torch.Tensor, y: torch.Tensor, v: Optional[torch.Tensor], return_diagnostics: bool): Dict[str, torch.Tensor]<br ALIGN="LEFT"/>parallel_transport_batch(x: torch.Tensor, y: torch.Tensor, v: torch.Tensor): torch.Tensor<br ALIGN="LEFT"/>process_points(x: torch.Tensor, y: torch.Tensor, v: Optional[torch.Tensor], return_diagnostics: bool): Dict[str, torch.Tensor]<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.core.tiling.quantum_geometric_attention.GeometricStructures" [color="black", fontcolor="black", label=<{GeometricStructures|curvature : float<br ALIGN="LEFT"/>dim : int<br ALIGN="LEFT"/>exp_map<br ALIGN="LEFT"/>log_map<br ALIGN="LEFT"/>manifold_type : str<br ALIGN="LEFT"/>parallel_transport_method : str<br ALIGN="LEFT"/>transport<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"src.core.metrics.height_theory.HeightStructure" [color="black", fontcolor="black", label=<{HeightStructure|base_field : str<br ALIGN="LEFT"/>local_heights<br ALIGN="LEFT"/>num_primes : int<br ALIGN="LEFT"/>prime_bases<br ALIGN="LEFT"/>|analyze_growth(points: List[torch.Tensor], window_size: int): Dict[str, torch.Tensor]<br ALIGN="LEFT"/>compute_canonical_height(point: torch.Tensor): torch.Tensor<br ALIGN="LEFT"/>compute_local_height(point: torch.Tensor, prime: int): torch.Tensor<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.core.tiling.patterns.cohomology.HeightStructure" [color="black", fontcolor="black", label=<{HeightStructure|num_primes : int<br ALIGN="LEFT"/>prime_bases<br ALIGN="LEFT"/>|compute_height(coefficients: torch.Tensor): torch.Tensor<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.core.attention.geometric.HyperbolicExponential" [color="black", fontcolor="black", label=<{HyperbolicExponential|curvature : Parameter<br ALIGN="LEFT"/>dim : int<br ALIGN="LEFT"/>eps : float<br ALIGN="LEFT"/>max_norm : float<br ALIGN="LEFT"/>|forward(x: torch.Tensor, v: torch.Tensor): torch.Tensor<br ALIGN="LEFT"/>minkowski_inner(x: torch.Tensor, y: torch.Tensor): torch.Tensor<br ALIGN="LEFT"/>minkowski_norm(v: torch.Tensor): torch.Tensor<br ALIGN="LEFT"/>project_to_hyperboloid(x: torch.Tensor): torch.Tensor<br ALIGN="LEFT"/>project_to_tangent(x: torch.Tensor, v: torch.Tensor): torch.Tensor<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.core.attention.geometric.HyperbolicLogarithm" [color="black", fontcolor="black", label=<{HyperbolicLogarithm|curvature : Parameter<br ALIGN="LEFT"/>dim : int<br ALIGN="LEFT"/>eps : float<br ALIGN="LEFT"/>max_dist : float<br ALIGN="LEFT"/>|forward(x: torch.Tensor, y: torch.Tensor): torch.Tensor<br ALIGN="LEFT"/>minkowski_inner(x: torch.Tensor, y: torch.Tensor): torch.Tensor<br ALIGN="LEFT"/>project_to_hyperboloid(x: torch.Tensor): torch.Tensor<br ALIGN="LEFT"/>project_to_tangent(x: torch.Tensor, v: torch.Tensor): torch.Tensor<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.core.vulkan.resources.ImageResource" [color="black", fontcolor="black", label=<{ImageResource|extent : Any<br ALIGN="LEFT"/>format : int<br ALIGN="LEFT"/>image : int<br ALIGN="LEFT"/>memory<br ALIGN="LEFT"/>view : int<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"src.core.metrics.advanced_metrics.InformationFlowMetrics" [color="black", fontcolor="black", label=<{InformationFlowMetrics|cross_tile_flow : float<br ALIGN="LEFT"/>edge_utilization : float<br ALIGN="LEFT"/>info_density : float<br ALIGN="LEFT"/>pattern_stability : float<br ALIGN="LEFT"/>|compute_ifq(): float<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.core.attention.routing.InformationRouter" [color="black", fontcolor="black", label=<{InformationRouter|bottleneck_detector : Sequential<br ALIGN="LEFT"/>bottleneck_threshold : float<br ALIGN="LEFT"/>dim : int<br ALIGN="LEFT"/>exploration_rate : float<br ALIGN="LEFT"/>num_heads : int<br ALIGN="LEFT"/>path_predictor : GRU<br ALIGN="LEFT"/>pattern_dynamics : PatternDynamics<br ALIGN="LEFT"/>route_scorer : Sequential<br ALIGN="LEFT"/>|detect_bottlenecks(states: torch.Tensor, routing_scores: torch.Tensor): tuple[torch.Tensor, torch.Tensor]<br ALIGN="LEFT"/>forward(states: torch.Tensor, return_diagnostics: bool): dict[str, torch.Tensor]<br ALIGN="LEFT"/>optimize_bottlenecks(states: torch.Tensor, bottlenecks: torch.Tensor, impact: torch.Tensor): torch.Tensor<br ALIGN="LEFT"/>predict_optimal_path(states: torch.Tensor, start_idx: torch.Tensor): torch.Tensor<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.core.performance.cpu.algorithms.InstructionCounter" [color="black", fontcolor="black", label=<{InstructionCounter|instruction_counts : Dict[str, int]<br ALIGN="LEFT"/>|get_instruction_count(func: Callable): int<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.core.tiling.patterns.cohomology.Integration" [color="black", fontcolor="black", label=<{Integration|manifold<br ALIGN="LEFT"/>|apply_stokes(form: ArithmeticForm, domain: torch.Tensor): torch.Tensor<br ALIGN="LEFT"/>integrate_form(form: ArithmeticForm, domain: torch.Tensor): torch.Tensor<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.core.metrics.evolution.LFunctionComputation" [color="black", fontcolor="black", label=<{LFunctionComputation|hidden_dim : int<br ALIGN="LEFT"/>network : Sequential<br ALIGN="LEFT"/>num_factors : int<br ALIGN="LEFT"/>rank : int<br ALIGN="LEFT"/>|compute_l_values(pattern: torch.Tensor): torch.Tensor<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.core.models.base.LayerGeometry" [color="black", fontcolor="black", label=<{LayerGeometry|connection_coeffs : Parameter<br ALIGN="LEFT"/>manifold_dim : int<br ALIGN="LEFT"/>metric_tensor : Parameter<br ALIGN="LEFT"/>pattern_dim : NoneType<br ALIGN="LEFT"/>|connection(points: torch.Tensor): torch.Tensor<br ALIGN="LEFT"/>get_riemannian_framework(points: torch.Tensor): PatternRiemannianStructure<br ALIGN="LEFT"/>metric(points: torch.Tensor): torch.Tensor<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.core.models.base.LayerGeometryDict" [color="black", fontcolor="black", label=<{LayerGeometryDict|<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"src.core.tiling.quantum_attention_tile.LoadBalancer" [color="black", fontcolor="black", label=<{LoadBalancer|loads<br ALIGN="LEFT"/>num_tiles : int<br ALIGN="LEFT"/>|balance(): List[int]<br ALIGN="LEFT"/>get_load(tile_idx: int): LoadProfile<br ALIGN="LEFT"/>update_load(tile_idx: int, load: LoadProfile)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.core.tiling.quantum_attention_tile.LoadProfile" [color="black", fontcolor="black", label=<{LoadProfile|compute : float<br ALIGN="LEFT"/>io : float<br ALIGN="LEFT"/>memory : float<br ALIGN="LEFT"/>|total(): float<br ALIGN="LEFT"/>weighted(compute_weight: float, memory_weight: float, io_weight: float): float<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.core.tiling.patterns.fiber_bundle.LocalChart" [color="black", fontcolor="black", label=<{LocalChart|coordinates : T<br ALIGN="LEFT"/>dimension : int<br ALIGN="LEFT"/>transition_maps : dict<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"src.core.performance.cpu.algorithms.LoopOptimizer" [color="black", fontcolor="black", label=<{LoopOptimizer|loop_stats : Dict[str, Dict[str, int]]<br ALIGN="LEFT"/>unroll_threshold : int<br ALIGN="LEFT"/>|fuse_loops(operations: List[Callable[[T], T]], data: T): T<br ALIGN="LEFT"/>unroll(loop_id: str, iterations: int, operation: Callable[[int], T]): List[T]<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.core.vulkan.memory.MemoryBlock" [color="black", fontcolor="black", label=<{MemoryBlock|memory : Any<br ALIGN="LEFT"/>offset : int<br ALIGN="LEFT"/>size : int<br ALIGN="LEFT"/>type_index : int<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"src.core.performance.memory_base.MemoryError" [color="black", fontcolor="red", label=<{MemoryError|<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"src.core.performance.cpu.memory.MemoryManager" [color="black", fontcolor="black", label=<{MemoryManager|cache_optimizer<br ALIGN="LEFT"/>enable_monitoring : bool<br ALIGN="LEFT"/>pool<br ALIGN="LEFT"/>stats : List[MemoryStats]<br ALIGN="LEFT"/>|allocate(shape: Tuple[int, ...], dtype: torch.dtype): torch.Tensor<br ALIGN="LEFT"/>clear_metrics(): None<br ALIGN="LEFT"/>clear_stats(): None<br ALIGN="LEFT"/>create_pool(size: int): MemoryPool<br ALIGN="LEFT"/>get_memory_stats(): List[MemoryStats]<br ALIGN="LEFT"/>optimize_tensor(tensor: torch.Tensor, access_pattern: str): torch.Tensor<br ALIGN="LEFT"/>release_tensor(tensor: torch.Tensor): None<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.core.performance.cpu.memory_management.MemoryManager" [color="black", fontcolor="black", label=<{MemoryManager|<br ALIGN="LEFT"/>|allocate_tensor(size: Tuple[int, ...]): torch.Tensor<br ALIGN="LEFT"/>get_allocated_memory(): int<br ALIGN="LEFT"/>get_fragmentation_ratio(): float<br ALIGN="LEFT"/>get_peak_memory(): int<br ALIGN="LEFT"/>inplace_operation(tensor: torch.Tensor, operation: Callable[[torch.Tensor], None]): None<br ALIGN="LEFT"/>optimized_matmul(x: torch.Tensor, y: torch.Tensor): torch.Tensor<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.core.performance.memory_base.MemoryManagerBase" [color="black", fontcolor="black", label=<{MemoryManagerBase|<br ALIGN="LEFT"/>|<I>allocate_tensor</I>(size: Union[Tuple[int, ...], torch.Size], dtype: Any): Any<br ALIGN="LEFT"/><I>cleanup</I>(): None<br ALIGN="LEFT"/><I>copy_from_device</I>(src: Any, dst: Any): None<br ALIGN="LEFT"/><I>copy_to_device</I>(src: Any, dst: Any): None<br ALIGN="LEFT"/><I>free_tensor</I>(tensor: Any): None<br ALIGN="LEFT"/>get_allocated_memory(): int<br ALIGN="LEFT"/>get_fragmentation_ratio(): float<br ALIGN="LEFT"/>get_metrics(): List[MemoryMetrics]<br ALIGN="LEFT"/>get_peak_memory(): int<br ALIGN="LEFT"/>record_metric(operation_type: str): None<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.core.performance.memory_base.MemoryMetrics" [color="black", fontcolor="black", label=<{MemoryMetrics|allocated_memory : int<br ALIGN="LEFT"/>fragmentation_ratio : float<br ALIGN="LEFT"/>operation_type : str<br ALIGN="LEFT"/>peak_memory : int<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"src.core.performance.cpu.memory_management.MemoryMetrics" [color="black", fontcolor="black", label=<{MemoryMetrics|allocated_memory : int<br ALIGN="LEFT"/>fragmentation_ratio : float<br ALIGN="LEFT"/>operation_type : str<br ALIGN="LEFT"/>peak_memory : int<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"src.core.performance.cpu.memory.MemoryPool" [color="black", fontcolor="black", label=<{MemoryPool|current_size : int<br ALIGN="LEFT"/>max_size : int<br ALIGN="LEFT"/>pools : Dict[Tuple[int, ...], List[torch.Tensor]]<br ALIGN="LEFT"/>stats : defaultdict<br ALIGN="LEFT"/>|acquire(shape: Tuple[int, ...], dtype: torch.dtype): torch.Tensor<br ALIGN="LEFT"/>release(tensor: torch.Tensor): None<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.core.vulkan.resources.MemoryRequirements" [color="black", fontcolor="black", label=<{MemoryRequirements|alignment : int<br ALIGN="LEFT"/>memory_type_bits : int<br ALIGN="LEFT"/>size : int<br ALIGN="LEFT"/>|from_vulkan(vulkan_reqs: VkMemoryRequirements): 'MemoryRequirements'<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.core.performance.cpu.memory.MemoryStats" [color="black", fontcolor="black", label=<{MemoryStats|access_pattern : str<br ALIGN="LEFT"/>allocation_size : int<br ALIGN="LEFT"/>cache_hits : int<br ALIGN="LEFT"/>fragmentation : float<br ALIGN="LEFT"/>pool_hits : int<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"src.core.patterns.riemannian_base copy.MetricTensor" [color="black", fontcolor="black", label=<{MetricTensor|dimension : int<br ALIGN="LEFT"/>is_compatible : bool<br ALIGN="LEFT"/>values : T<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"src.core.patterns.riemannian_base.MetricTensor" [color="black", fontcolor="black", label=<{MetricTensor|dimension : int<br ALIGN="LEFT"/>is_compatible : bool<br ALIGN="LEFT"/>values : T<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"src.core.models.base.ModelGeometry" [color="black", fontcolor="black", label=<{ModelGeometry|attention_heads : ModuleList<br ALIGN="LEFT"/>key_dim : int<br ALIGN="LEFT"/>layers<br ALIGN="LEFT"/>manifold_dim : int<br ALIGN="LEFT"/>query_dim : int<br ALIGN="LEFT"/>|add_attention_head(head: nn.Module)<br ALIGN="LEFT"/>add_layer(name: str, layer: LayerGeometry)<br ALIGN="LEFT"/>get_attention_head(idx: int): nn.Module<br ALIGN="LEFT"/>get_layer(name: str): LayerGeometry<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.core.patterns.motivic_riemannian.MotivicChristoffelSymbols" [color="black", fontcolor="black", label=<{MotivicChristoffelSymbols|dynamics<br ALIGN="LEFT"/>dynamics_state<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"src.core.tiling.patterns.cohomology.MotivicCohomology" [color="black", fontcolor="black", label=<{MotivicCohomology|base_space<br ALIGN="LEFT"/>dynamics<br ALIGN="LEFT"/>height_structure<br ALIGN="LEFT"/>hidden_dim : int<br ALIGN="LEFT"/>metrics<br ALIGN="LEFT"/>motive_rank : int<br ALIGN="LEFT"/>num_primes : int<br ALIGN="LEFT"/>|compute_motive(form: ArithmeticForm): torch.Tensor<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.core.patterns.motivic_riemannian.MotivicCurvatureTensor" [color="black", fontcolor="black", label=<{MotivicCurvatureTensor|cohomology_class<br ALIGN="LEFT"/>motive<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"src.core.patterns.motivic_riemannian.MotivicMetricTensor" [color="black", fontcolor="black", label=<{MotivicMetricTensor|height_data<br ALIGN="LEFT"/>height_structure<br ALIGN="LEFT"/>|with_height(new_values: Tensor): 'MotivicMetricTensor'<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.core.patterns.motivic_riemannian.MotivicRiemannianStructure" [color="black", fontcolor="black", label=<{MotivicRiemannianStructure|cache : Dict[str, Any]<br ALIGN="LEFT"/>connection_coeffs : Parameter<br ALIGN="LEFT"/>connection_map : Linear<br ALIGN="LEFT"/>device : device<br ALIGN="LEFT"/>dtype : Ellipsis<br ALIGN="LEFT"/>dynamics<br ALIGN="LEFT"/>fiber_map : Linear<br ALIGN="LEFT"/>height_structure<br ALIGN="LEFT"/>hidden_dim : int<br ALIGN="LEFT"/>manifold_dim : int<br ALIGN="LEFT"/>metric_factors : Parameter<br ALIGN="LEFT"/>motive<br ALIGN="LEFT"/>motive_rank : int<br ALIGN="LEFT"/>|bundle_projection(total_space: Tensor): Tensor<br ALIGN="LEFT"/>compute_christoffel(points: Tensor): MotivicChristoffelSymbols<br ALIGN="LEFT"/>compute_curvature(points: Tensor, christoffel: Optional[MotivicChristoffelSymbols]): MotivicCurvatureTensor<br ALIGN="LEFT"/>compute_metric(points: Tensor): MotivicMetricTensor<br ALIGN="LEFT"/>connection_form(tangent_vector: Tensor): Tensor<br ALIGN="LEFT"/>get_connection(point: Tensor): Tensor<br ALIGN="LEFT"/>get_fiber(point: Tensor): Tensor<br ALIGN="LEFT"/>local_trivialization(point: Tensor): Tuple[LocalChart[Tensor], FiberChart[Tensor, str]]<br ALIGN="LEFT"/>parallel_transport(section: Tensor, path: Tensor): Tensor<br ALIGN="LEFT"/>transition_functions(chart1: LocalChart[Tensor], chart2: LocalChart[Tensor]): Tensor<br ALIGN="LEFT"/>validate_connection_properties(connection: MotivicChristoffelSymbols): bool<br ALIGN="LEFT"/>validate_metric_properties(metric: MotivicMetricTensor): bool<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.core.performance.cpu.algorithms.NumericalOptimizer" [color="black", fontcolor="black", label=<{NumericalOptimizer|enable_mixed_precision : bool<br ALIGN="LEFT"/>numerical_stats : Dict[str, float]<br ALIGN="LEFT"/>stability_threshold : float<br ALIGN="LEFT"/>|optimize_precision(tensor: torch.Tensor, operation_id: str): torch.Tensor<br ALIGN="LEFT"/>stable_softmax(x: torch.Tensor, dim: int): torch.Tensor<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.core.benchmarks.metrics.OperationMetrics" [color="black", fontcolor="black", label=<{OperationMetrics|accuracy : Optional[float]<br ALIGN="LEFT"/>avg_memory : float<br ALIGN="LEFT"/>avg_time : float<br ALIGN="LEFT"/>batch_size : Optional[int]<br ALIGN="LEFT"/>batch_time : Optional[float]<br ALIGN="LEFT"/>convergence_rate : Optional[float]<br ALIGN="LEFT"/>efficiency : Optional[float]<br ALIGN="LEFT"/>name : str<br ALIGN="LEFT"/>sequential_time : Optional[float]<br ALIGN="LEFT"/>size : int<br ALIGN="LEFT"/>stability : Optional[float]<br ALIGN="LEFT"/>throughput : float<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"src.core.metrics.evolution.OrbitAnalysis" [color="black", fontcolor="black", label=<{OrbitAnalysis|hidden_dim : int<br ALIGN="LEFT"/>history : List[torch.Tensor]<br ALIGN="LEFT"/>orbit_dim : int<br ALIGN="LEFT"/>projection : Linear<br ALIGN="LEFT"/>|analyze_orbit(pattern: torch.Tensor): Dict[str, float]<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.core.attention.geometric.ParallelTransport" [color="black", fontcolor="black", label=<{ParallelTransport|dim : int<br ALIGN="LEFT"/>method : Literal['schild', 'pole']<br ALIGN="LEFT"/>|forward(v: torch.Tensor, x: torch.Tensor, y: torch.Tensor, connection: Optional[torch.Tensor]): torch.Tensor<br ALIGN="LEFT"/>pole_ladder(v: torch.Tensor, x: torch.Tensor, y: torch.Tensor): torch.Tensor<br ALIGN="LEFT"/>schild_ladder(v: torch.Tensor, x: torch.Tensor, y: torch.Tensor, connection: Optional[torch.Tensor]): torch.Tensor<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.core.tiling.optimization.parameter_manager.ParameterMonitor" [color="black", fontcolor="black", label=<{ParameterMonitor|gradient_history : Dict[str, List[torch.Tensor]]<br ALIGN="LEFT"/>parameter_history : Dict[str, List[torch.Tensor]]<br ALIGN="LEFT"/>window_size : int<br ALIGN="LEFT"/>|get_statistics(name: str): Dict[str, torch.Tensor]<br ALIGN="LEFT"/>update(name: str, param: nn.Parameter)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.core.tiling.quantum_geometric_attention.PatternDynamics" [color="black", fontcolor="black", label=<{PatternDynamics|adaptation_rate : float<br ALIGN="LEFT"/>dim : int<br ALIGN="LEFT"/>num_heads : int<br ALIGN="LEFT"/>num_patterns : int<br ALIGN="LEFT"/>pattern_scores : Parameter<br ALIGN="LEFT"/>patterns : Parameter<br ALIGN="LEFT"/>temperature : float<br ALIGN="LEFT"/>|update_patterns(x: torch.Tensor): torch.Tensor<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.core.patterns.dynamics.PatternDynamics" [color="black", fontcolor="black", label=<{PatternDynamics|device : device<br ALIGN="LEFT"/>dt : float<br ALIGN="LEFT"/>|<I>compute_conserved_quantities</I>(state: torch.Tensor): Dict[str, torch.Tensor]<br ALIGN="LEFT"/><I>compute_energy</I>(state: torch.Tensor): Dict[str, torch.Tensor]<br ALIGN="LEFT"/><I>compute_flow</I>(state: torch.Tensor): torch.Tensor<br ALIGN="LEFT"/><I>evolve</I>(state: torch.Tensor, time: float): torch.Tensor<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.core.patterns.evolution.PatternEvolution" [color="black", fontcolor="black", label=<{PatternEvolution|framework<br ALIGN="LEFT"/>learning_rate : float<br ALIGN="LEFT"/>momentum : float<br ALIGN="LEFT"/>velocity : NoneType<br ALIGN="LEFT"/>|reset()<br ALIGN="LEFT"/>step(pattern: torch.Tensor, gradient: torch.Tensor, mask: Optional[torch.Tensor]): Tuple[torch.Tensor, torch.Tensor]<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.core.tiling.patterns.fiber_bundle.PatternFiberBundle" [color="black", fontcolor="black", label=<{PatternFiberBundle|base_dim : int<br ALIGN="LEFT"/>basis_matrices<br ALIGN="LEFT"/>connection : Parameter<br ALIGN="LEFT"/>connection_coeffs<br ALIGN="LEFT"/>device : NoneType, device<br ALIGN="LEFT"/>fiber_dim : int<br ALIGN="LEFT"/>metric : Parameter<br ALIGN="LEFT"/>structure_group : str<br ALIGN="LEFT"/>total_dim : int<br ALIGN="LEFT"/>|bundle_projection(total_space: torch.Tensor): torch.Tensor<br ALIGN="LEFT"/>compute_metric(points: torch.Tensor): MetricTensor[torch.Tensor]<br ALIGN="LEFT"/>connection_form(tangent_vector: torch.Tensor): torch.Tensor<br ALIGN="LEFT"/>local_trivialization(point: torch.Tensor): Tuple[LocalChart[torch.Tensor], FiberChart[torch.Tensor, str]]<br ALIGN="LEFT"/>parallel_transport(section: torch.Tensor, path: torch.Tensor): torch.Tensor<br ALIGN="LEFT"/>to(device: torch.device): 'PatternFiberBundle'<br ALIGN="LEFT"/>transition_functions(chart1: LocalChart[torch.Tensor], chart2: LocalChart[torch.Tensor]): torch.Tensor<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.core.tiling.geometric_flow.PatternFlow" [color="black", fontcolor="black", label=<{PatternFlow|energy_net : Sequential<br ALIGN="LEFT"/>flow_net : Sequential<br ALIGN="LEFT"/>input_dim : int<br ALIGN="LEFT"/>manifold_proj : Sequential<br ALIGN="LEFT"/>metric_net : Sequential<br ALIGN="LEFT"/>output_proj : Sequential<br ALIGN="LEFT"/>ricci_net : Sequential<br ALIGN="LEFT"/>|compute_metric(flow: torch.Tensor): torch.Tensor<br ALIGN="LEFT"/>compute_ricci_tensor(metric: torch.Tensor, connection: torch.Tensor): torch.Tensor<br ALIGN="LEFT"/>detect_singularities(flow: torch.Tensor, threshold: float): Dict[str, Any]<br ALIGN="LEFT"/>flow_step(metric: torch.Tensor, ricci: torch.Tensor, timestep: float): Tuple[torch.Tensor, Dict[str, torch.Tensor]]<br ALIGN="LEFT"/>forward(x: torch.Tensor, return_paths: bool): Tuple[torch.Tensor, List[Dict]]<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.core.patterns.formation.PatternFormation" [color="black", fontcolor="black", label=<{PatternFormation|diffusion_coeff : float<br ALIGN="LEFT"/>diffusion_kernel<br ALIGN="LEFT"/>dim : int<br ALIGN="LEFT"/>dt : float<br ALIGN="LEFT"/>reaction_coeff : float<br ALIGN="LEFT"/>|compute_energy(pattern: torch.Tensor): torch.Tensor<br ALIGN="LEFT"/>compute_stability(pattern: torch.Tensor): Dict[str, Any]<br ALIGN="LEFT"/>evolve(pattern: torch.Tensor, time_steps: int): torch.Tensor<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.core.patterns.riemannian.PatternRiemannianStructure" [color="black", fontcolor="black", label=<{PatternRiemannianStructure|connection_coeffs : Parameter<br ALIGN="LEFT"/>metric_factors : Parameter<br ALIGN="LEFT"/>pattern_dim : int<br ALIGN="LEFT"/>structure<br ALIGN="LEFT"/>|compute_riemann(points: Tensor): CurvatureTensor[Tensor]<br ALIGN="LEFT"/>forward(): Any<br ALIGN="LEFT"/>get_christoffel_values(points: Tensor): Tensor<br ALIGN="LEFT"/>get_metric_tensor(points: Tensor): Tensor<br ALIGN="LEFT"/>get_riemann_tensor(points: Tensor): Tensor<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.core.performance.cpu_optimizer.PerformanceMetrics" [color="black", fontcolor="black", label=<{PerformanceMetrics|cache_hits : float<br ALIGN="LEFT"/>cpu_utilization : float<br ALIGN="LEFT"/>execution_time : float<br ALIGN="LEFT"/>memory_usage : float<br ALIGN="LEFT"/>vectorization_efficiency : float<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"src.core.tiling.quantum_geometric_attention.QuantumGeometricAttention" [color="black", fontcolor="black", label=<{QuantumGeometricAttention|arithmetic<br ALIGN="LEFT"/>attention<br ALIGN="LEFT"/>curvature : float<br ALIGN="LEFT"/>dropout : float<br ALIGN="LEFT"/>exp_map<br ALIGN="LEFT"/>flow<br ALIGN="LEFT"/>hidden_dim : int<br ALIGN="LEFT"/>log_map<br ALIGN="LEFT"/>manifold_dim : int<br ALIGN="LEFT"/>manifold_type : str<br ALIGN="LEFT"/>metric : Parameter<br ALIGN="LEFT"/>motive_rank : int<br ALIGN="LEFT"/>num_heads : int<br ALIGN="LEFT"/>num_layers : int<br ALIGN="LEFT"/>pattern_proj : Linear<br ALIGN="LEFT"/>tile_size : int<br ALIGN="LEFT"/>transport<br ALIGN="LEFT"/>|build_attention_complex(query: torch.Tensor, key: torch.Tensor, value: torch.Tensor, mask: Optional[torch.Tensor]): Tuple[torch.Tensor, AttentionMetrics]<br ALIGN="LEFT"/>classical_to_quantum(x: torch.Tensor): torch.Tensor<br ALIGN="LEFT"/>compute_attention_patterns(x: torch.Tensor, mask: Optional[torch.Tensor], return_metrics: bool): Union[torch.Tensor, Tuple[torch.Tensor, AttentionMetrics]]<br ALIGN="LEFT"/>compute_complexity(features: torch.Tensor): torch.Tensor<br ALIGN="LEFT"/>compute_entropy(features: torch.Tensor): torch.Tensor<br ALIGN="LEFT"/>compute_fisher_information(states: torch.Tensor): torch.Tensor<br ALIGN="LEFT"/>compute_metric_tensor(state: AttentionState): torch.Tensor<br ALIGN="LEFT"/>compute_sparsity(features: torch.Tensor): torch.Tensor<br ALIGN="LEFT"/>compute_stability(features: torch.Tensor): torch.Tensor<br ALIGN="LEFT"/>create_attention_parameters(batch_size: int, seq_len: int): Dict[str, torch.Tensor]<br ALIGN="LEFT"/>detect_patterns(x: torch.Tensor): Tuple[torch.Tensor, Dict[str, Any]]<br ALIGN="LEFT"/>forward(x: torch.Tensor, return_patterns: bool): Union[torch.Tensor, Tuple[torch.Tensor, Dict[str, Any]]]<br ALIGN="LEFT"/>prepare_attention_state(x: torch.Tensor, mask: Optional[torch.Tensor]): AttentionState<br ALIGN="LEFT"/>prepare_code_state(x: torch.Tensor): torch.Tensor<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.core.tiling.quantum_geometric_attention.QuantumGeometricTransformer" [color="black", fontcolor="black", label=<{QuantumGeometricTransformer|layers : ModuleList<br ALIGN="LEFT"/>norm : LayerNorm<br ALIGN="LEFT"/>|forward(x: torch.Tensor, return_patterns: bool): Tuple[torch.Tensor, Optional[List[Dict[str, Any]]]]<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.core.tiling.patterns.cohomology.QuantumMotivicCohomology" [color="black", fontcolor="black", label=<{QuantumMotivicCohomology|metric<br ALIGN="LEFT"/>motivic<br ALIGN="LEFT"/>quantum_structure<br ALIGN="LEFT"/>|compute_quantum_motive(form: ArithmeticForm): torch.Tensor<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.core.tiling.quantum_attention_tile.QuantumMotivicTile" [color="black", fontcolor="black", label=<{QuantumMotivicTile|cohomology_dim : int<br ALIGN="LEFT"/>cohomology_proj : Linear<br ALIGN="LEFT"/>dropout : float<br ALIGN="LEFT"/>dropout_layer : Dropout<br ALIGN="LEFT"/>field_proj : Linear<br ALIGN="LEFT"/>height_proj : Linear<br ALIGN="LEFT"/>hidden_dim : int<br ALIGN="LEFT"/>key : Linear<br ALIGN="LEFT"/>motive_rank : int<br ALIGN="LEFT"/>neighbors<br ALIGN="LEFT"/>num_heads : int<br ALIGN="LEFT"/>output : Linear<br ALIGN="LEFT"/>query : Linear<br ALIGN="LEFT"/>resolution : float<br ALIGN="LEFT"/>size : int<br ALIGN="LEFT"/>value : Linear<br ALIGN="LEFT"/>|adapt_resolution(density_metric: float, strategy: str): None<br ALIGN="LEFT"/>add_neighbor(neighbor: 'QuantumMotivicTile'): None<br ALIGN="LEFT"/>balance_load(neighbors: List['QuantumMotivicTile']): None<br ALIGN="LEFT"/>compute_ae(resolution_history: List[float], load_variance_history: List[float], window_size: int): float<br ALIGN="LEFT"/>compute_cer(information_transferred: float, compute_cost: float, memory_usage: float, resolution: float, beta: float): float<br ALIGN="LEFT"/>compute_ifq(pattern_stability: float, cross_tile_flow: float, edge_utilization: float, info_density: float, alpha: float): float<br ALIGN="LEFT"/>forward(x: torch.Tensor): torch.Tensor<br ALIGN="LEFT"/>get_memory_stats(): Dict[str, float]<br ALIGN="LEFT"/>get_metrics(): Dict[str, Any]<br ALIGN="LEFT"/>get_visualization_data(): Dict[str, Any]<br ALIGN="LEFT"/>optimize_resources(profile: LoadProfile): None<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.core.tiling.patterns.cohomology.RiemannianFiberBundle" [color="black", fontcolor="black", label=<{RiemannianFiberBundle|connection_map : Linear<br ALIGN="LEFT"/>dimension : int<br ALIGN="LEFT"/>fiber_map : Linear<br ALIGN="LEFT"/>|get_connection(point: torch.Tensor): torch.Tensor<br ALIGN="LEFT"/>get_fiber(point: torch.Tensor): torch.Tensor<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.core.patterns.riemannian.RiemannianFramework" [color="black", fontcolor="black", label=<{RiemannianFramework|structure<br ALIGN="LEFT"/>|compute_christoffel(points: Tensor): ChristoffelSymbols[Tensor]<br ALIGN="LEFT"/>compute_metric(points: Tensor): MetricTensor[Tensor]<br ALIGN="LEFT"/>compute_riemann(points: Tensor): CurvatureTensor[Tensor]<br ALIGN="LEFT"/>exp_map(point: Tensor, vector: Tensor): Tensor<br ALIGN="LEFT"/>forward(): Any<br ALIGN="LEFT"/>get_christoffel_values(points: Tensor): Tensor<br ALIGN="LEFT"/>get_metric_tensor(points: Tensor): Tensor<br ALIGN="LEFT"/>get_riemann_tensor(points: Tensor): Tensor<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.core.tiling.geometric_flow.RiemannianMetric" [color="black", fontcolor="black", label=<{RiemannianMetric|manifold_dim : int<br ALIGN="LEFT"/>metric_factors : Parameter<br ALIGN="LEFT"/>num_charts : int<br ALIGN="LEFT"/>rank : int<br ALIGN="LEFT"/>transitions : Parameter<br ALIGN="LEFT"/>|compute_christoffel(x: torch.Tensor, metric: torch.Tensor): torch.Tensor<br ALIGN="LEFT"/>compute_fisher_metric(x: torch.Tensor): torch.Tensor<br ALIGN="LEFT"/>forward(x: torch.Tensor, chart: int): torch.Tensor<br ALIGN="LEFT"/>parallel_transport(x: torch.Tensor, v: torch.Tensor, chart: int): torch.Tensor<br ALIGN="LEFT"/>transition(x: torch.Tensor, chart_from: int, chart_to: int): torch.Tensor<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.core.patterns.riemannian_base copy.RiemannianStructure" [color="black", fontcolor="black", label=<{RiemannianStructure|<br ALIGN="LEFT"/>|compute_christoffel(points: T): ChristoffelSymbols[T]<br ALIGN="LEFT"/>compute_curvature(points: T, christoffel: Optional[ChristoffelSymbols[T]]): CurvatureTensor[T]<br ALIGN="LEFT"/>compute_metric(points: T): MetricTensor[T]<br ALIGN="LEFT"/>geodesic_flow(initial_point: T, initial_velocity: T, steps: int, step_size: float): Tuple[T, T]<br ALIGN="LEFT"/>lie_derivative_metric(point: T, vector_field: VectorField): MetricTensor[T]<br ALIGN="LEFT"/>parallel_transport(vector: T, path: T, connection: Optional[ChristoffelSymbols[T]]): T<br ALIGN="LEFT"/>sectional_curvature(point: T, v1: T, v2: T): Scalar<br ALIGN="LEFT"/>validate_connection_properties(connection: ChristoffelSymbols[T]): bool<br ALIGN="LEFT"/>validate_metric_properties(metric: MetricTensor[T]): bool<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.core.patterns.riemannian_base.RiemannianStructure" [color="black", fontcolor="black", label=<{RiemannianStructure|<br ALIGN="LEFT"/>|compute_christoffel(points: T): ChristoffelSymbols[T]<br ALIGN="LEFT"/>compute_curvature(points: T, christoffel: Optional[ChristoffelSymbols[T]]): CurvatureTensor[T]<br ALIGN="LEFT"/>compute_metric(points: T): MetricTensor[T]<br ALIGN="LEFT"/>geodesic_flow(initial_point: T, initial_velocity: T, steps: int, step_size: float): Tuple[T, T]<br ALIGN="LEFT"/>lie_derivative_metric(point: T, vector_field: VectorField): MetricTensor[T]<br ALIGN="LEFT"/>parallel_transport(vector: T, path: T, connection: Optional[ChristoffelSymbols[T]]): T<br ALIGN="LEFT"/>sectional_curvature(point: T, v1: T, v2: T): Scalar<br ALIGN="LEFT"/>validate_connection_properties(connection: ChristoffelSymbols[T]): bool<br ALIGN="LEFT"/>validate_metric_properties(metric: MetricTensor[T]): bool<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.core.patterns.riemannian_base copy.RiemannianValidator" [color="black", fontcolor="black", label=<{RiemannianValidator|<br ALIGN="LEFT"/>|validate_connection_properties(connection: ChristoffelSymbols[T]): bool<br ALIGN="LEFT"/>validate_metric_properties(metric: MetricTensor[T]): bool<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.core.patterns.riemannian_base.RiemannianValidator" [color="black", fontcolor="black", label=<{RiemannianValidator|<br ALIGN="LEFT"/>|validate_connection_properties(connection: ChristoffelSymbols[T]): bool<br ALIGN="LEFT"/>validate_metric_properties(metric: MetricTensor[T]): bool<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.core.performance.vulkan.shaders.ShaderCompiler" [color="black", fontcolor="black", label=<{ShaderCompiler|shader_dir : Path<br ALIGN="LEFT"/>|compile_all_shaders(): None<br ALIGN="LEFT"/>compile_shader(shader_name: str): None<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.core.performance.vulkan.shaders.ShaderManager" [color="black", fontcolor="black", label=<{ShaderManager|device : c_void_p<br ALIGN="LEFT"/>pipeline_layouts : Dict[str, VkPipelineLayout]<br ALIGN="LEFT"/>pipelines : Dict[str, VkPipeline]<br ALIGN="LEFT"/>shader_dir : Path<br ALIGN="LEFT"/>shader_modules : Dict[str, VkShaderModule]<br ALIGN="LEFT"/>|cleanup(): None<br ALIGN="LEFT"/>create_compute_pipeline(shader_name: str, push_constant_size: int): Tuple[VkPipeline, VkPipelineLayout]<br ALIGN="LEFT"/>create_shader_module(shader_name: str): VkShaderModule<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.core.tiling.state_manager.StateConfig" [color="black", fontcolor="black", label=<{StateConfig|dim : int<br ALIGN="LEFT"/>epsilon : float<br ALIGN="LEFT"/>max_entanglement : float<br ALIGN="LEFT"/>type<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"src.core.tiling.state_manager.StateManager" [color="black", fontcolor="black", label=<{StateManager|config<br ALIGN="LEFT"/>device : NoneType, device<br ALIGN="LEFT"/>history : list<br ALIGN="LEFT"/>states : dict<br ALIGN="LEFT"/>|calculate_fidelity(state1: torch.Tensor, state2: torch.Tensor): float<br ALIGN="LEFT"/>get_state_history(key: str): List[torch.Tensor]<br ALIGN="LEFT"/>initialize_state(key: str, dim: Optional[int]): torch.Tensor<br ALIGN="LEFT"/>update_state(key: str, update: torch.Tensor, learning_rate: float): torch.Tensor<br ALIGN="LEFT"/>validate_state(state: torch.Tensor): bool<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.core.tiling.state_manager.StateType" [color="black", fontcolor="black", label=<{StateType|name<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"src.core.patterns.symplectic.SymplecticForm" [color="black", fontcolor="black", label=<{SymplecticForm|matrix : Tensor<br ALIGN="LEFT"/>|evaluate(v1: Tensor, v2: Tensor): Tensor<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.core.patterns.symplectic.SymplecticStructure" [color="black", fontcolor="black", label=<{SymplecticStructure|dim : int<br ALIGN="LEFT"/>|compute_form(point: Tensor): SymplecticForm<br ALIGN="LEFT"/>compute_volume(point: Tensor): Tensor<br ALIGN="LEFT"/>hamiltonian_vector_field(hamiltonian: Tensor, point: Tensor): Tensor<br ALIGN="LEFT"/>poisson_bracket(f: Tensor, g: Tensor, point: Tensor): Tensor<br ALIGN="LEFT"/>standard_form(device: Optional[torch.device]): SymplecticForm<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.core.tiling.components.config.TilingConfig" [color="black", fontcolor="black", label=<{TilingConfig|dilation : int<br ALIGN="LEFT"/>groups : int<br ALIGN="LEFT"/>max_memory_gb : float<br ALIGN="LEFT"/>num_stages : int<br ALIGN="LEFT"/>num_warps : int<br ALIGN="LEFT"/>optimize_layout : bool<br ALIGN="LEFT"/>overlap : int<br ALIGN="LEFT"/>padding : str<br ALIGN="LEFT"/>stride : Optional[Tuple[int, ...]]<br ALIGN="LEFT"/>tile_size : Tuple[int, ...]<br ALIGN="LEFT"/>vectorize : bool<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"src.core.patterns.riemannian_base copy.ValidationMixin" [color="black", fontcolor="black", label=<{ValidationMixin|<br ALIGN="LEFT"/>|validate_connection_properties(connection: ChristoffelSymbols[Tensor]): bool<br ALIGN="LEFT"/>validate_metric_properties(metric: MetricTensor[Tensor]): bool<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.core.patterns.riemannian_base.ValidationMixin" [color="black", fontcolor="black", label=<{ValidationMixin|<br ALIGN="LEFT"/>|validate_connection_properties(connection: ChristoffelSymbols[Tensor]): bool<br ALIGN="LEFT"/>validate_metric_properties(metric: MetricTensor[Tensor]): bool<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.core.performance.cpu.vectorization.VectorizationMetrics" [color="black", fontcolor="black", label=<{VectorizationMetrics|execution_time : float<br ALIGN="LEFT"/>memory_usage : float<br ALIGN="LEFT"/>operation_type : str<br ALIGN="LEFT"/>vectorization_efficiency : float<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"src.core.performance.cpu.vectorization.VectorizationOptimizer" [color="black", fontcolor="black", label=<{VectorizationOptimizer|chunk_size : int<br ALIGN="LEFT"/>enable_profiling : bool<br ALIGN="LEFT"/>metrics : List[VectorizationMetrics]<br ALIGN="LEFT"/>use_mixed_precision : bool<br ALIGN="LEFT"/>|clear_metrics(): None<br ALIGN="LEFT"/>get_metrics(): List[VectorizationMetrics]<br ALIGN="LEFT"/>profile_vectorization(func: Callable): Callable<br ALIGN="LEFT"/>vectorize_attention(query: torch.Tensor, key: torch.Tensor, value: torch.Tensor): torch.Tensor<br ALIGN="LEFT"/>vectorize_geometric_flow(metric: torch.Tensor, connection: torch.Tensor): torch.Tensor<br ALIGN="LEFT"/>vectorize_pattern_dynamics(pattern: torch.Tensor, flow: torch.Tensor): torch.Tensor<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.core.performance.vulkan.shaders.VkCommandBufferAllocateInfo" [color="black", fontcolor="black", label=<{VkCommandBufferAllocateInfo|<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"src.core.performance.vulkan.shaders.VkCommandBufferBeginInfo" [color="black", fontcolor="black", label=<{VkCommandBufferBeginInfo|<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"src.core.performance.vulkan.shaders.VkComputePipelineCreateInfo" [color="black", fontcolor="black", label=<{VkComputePipelineCreateInfo|<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"src.core.performance.vulkan.shaders.VkDescriptorSetLayoutBinding" [color="black", fontcolor="black", label=<{VkDescriptorSetLayoutBinding|<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"src.core.performance.vulkan.shaders.VkDescriptorSetLayoutCreateInfo" [color="black", fontcolor="black", label=<{VkDescriptorSetLayoutCreateInfo|<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"src.core.vulkan.resources.VkMemoryRequirements" [color="black", fontcolor="black", label=<{VkMemoryRequirements|<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"src.core.performance.vulkan.shaders.VkPipelineLayoutCreateInfo" [color="black", fontcolor="black", label=<{VkPipelineLayoutCreateInfo|<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"src.core.performance.vulkan.shaders.VkPipelineShaderStageCreateInfo" [color="black", fontcolor="black", label=<{VkPipelineShaderStageCreateInfo|<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"src.core.performance.vulkan.shaders.VkPushConstantRange" [color="black", fontcolor="black", label=<{VkPushConstantRange|<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"src.core.performance.vulkan.shaders.VkShaderModuleCreateInfo" [color="black", fontcolor="black", label=<{VkShaderModuleCreateInfo|<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"src.core.performance.vulkan.shaders.VkSubmitInfo" [color="black", fontcolor="black", label=<{VkSubmitInfo|<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"src.core.performance.vulkan_memory.VulkanBuffer" [color="black", fontcolor="black", label=<{VulkanBuffer|buffer : c_void_p<br ALIGN="LEFT"/>dtype : Optional[Any]<br ALIGN="LEFT"/>memory : c_void_p<br ALIGN="LEFT"/>offset : int<br ALIGN="LEFT"/>shape : Optional[Tuple[int, ...]]<br ALIGN="LEFT"/>size : int<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"src.core.vulkan.memory.VulkanMemory" [color="black", fontcolor="black", label=<{VulkanMemory|allocations : Dict[int, MemoryBlock]<br ALIGN="LEFT"/>device : Union[int, c_void_p]<br ALIGN="LEFT"/>memory_properties<br ALIGN="LEFT"/>peak_allocated : int<br ALIGN="LEFT"/>physical_device : Union[int, c_void_p]<br ALIGN="LEFT"/>total_allocated : int<br ALIGN="LEFT"/>|allocate(size: int, memory_type_bits: int, properties: int): MemoryBlock<br ALIGN="LEFT"/>cleanup()<br ALIGN="LEFT"/>free(block: MemoryBlock)<br ALIGN="LEFT"/>get_stats(): Dict[str, float]<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.core.performance.vulkan_memory.VulkanMemoryManager" [color="black", fontcolor="black", label=<{VulkanMemoryManager|device : c_void_p<br ALIGN="LEFT"/>physical_device : c_void_p<br ALIGN="LEFT"/>|allocate_tensor(size: Union[Tuple[int, ...], torch.Size], dtype: Any): VulkanBuffer<br ALIGN="LEFT"/>cleanup(): None<br ALIGN="LEFT"/>copy_from_device(src: VulkanBuffer, dst: np.ndarray): None<br ALIGN="LEFT"/>copy_to_device(src: np.ndarray, dst: VulkanBuffer): None<br ALIGN="LEFT"/>free_tensor(buffer: VulkanBuffer): None<br ALIGN="LEFT"/>get_fragmentation_ratio(): float<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.core.vulkan.resources.VulkanResources" [color="black", fontcolor="black", label=<{VulkanResources|buffers : Dict[int, BufferResource]<br ALIGN="LEFT"/>device : int<br ALIGN="LEFT"/>images : Dict[int, ImageResource]<br ALIGN="LEFT"/>memory<br ALIGN="LEFT"/>|cleanup()<br ALIGN="LEFT"/>create_buffer(size: int, usage: int, sharing_mode: int, memory_properties: int): BufferResource<br ALIGN="LEFT"/>create_image(format: int, width: int, height: int, depth: int, usage: int, sharing_mode: int, memory_properties: int): ImageResource<br ALIGN="LEFT"/>destroy_buffer(resource: BufferResource)<br ALIGN="LEFT"/>destroy_image(resource: ImageResource)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.core.patterns.motivic_riemannian.MotivicRiemannianStructure" -> "src.core.patterns.fiber_bundle.BaseFiberBundle" [arrowhead="empty", arrowtail="none"];
"src.core.patterns.motivic_riemannian.MotivicRiemannianStructure" -> "src.core.patterns.riemannian_base.ValidationMixin" [arrowhead="empty", arrowtail="none"];
"src.core.patterns.motivic_riemannian.MotivicRiemannianStructure" -> "src.core.tiling.patterns.cohomology.RiemannianFiberBundle" [arrowhead="empty", arrowtail="none"];
"src.core.patterns.riemannian.BaseRiemannianStructure" -> "src.core.patterns.riemannian_base.ValidationMixin" [arrowhead="empty", arrowtail="none"];
"src.core.patterns.riemannian.PatternRiemannianStructure" -> "src.core.patterns.riemannian.BaseRiemannianStructure" [arrowhead="empty", arrowtail="none"];
"src.core.performance.cpu_memory.CPUMemoryManager" -> "src.core.performance.memory_base.MemoryManagerBase" [arrowhead="empty", arrowtail="none"];
"src.core.performance.vulkan_memory.VulkanMemoryManager" -> "src.core.performance.memory_base.MemoryManagerBase" [arrowhead="empty", arrowtail="none"];
"src.core.tiling.geometric_flow.PatternFlow" -> "src.core.tiling.geometric_flow.GeometricFlow" [arrowhead="empty", arrowtail="none"];
"src.core.attention.geometric.EuclideanExponential" -> "src.core.tiling.quantum_geometric_attention.GeometricStructures" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="exp_map", style="solid"];
"src.core.attention.geometric.EuclideanExponential" -> "src.core.tiling.quantum_geometric_attention.QuantumGeometricAttention" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="exp_map", style="solid"];
"src.core.attention.geometric.EuclideanLogarithm" -> "src.core.tiling.quantum_geometric_attention.GeometricStructures" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="log_map", style="solid"];
"src.core.attention.geometric.EuclideanLogarithm" -> "src.core.tiling.quantum_geometric_attention.QuantumGeometricAttention" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="log_map", style="solid"];
"src.core.attention.geometric.HyperbolicExponential" -> "src.core.tiling.quantum_geometric_attention.GeometricStructures" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="exp_map", style="solid"];
"src.core.attention.geometric.HyperbolicExponential" -> "src.core.tiling.quantum_geometric_attention.QuantumGeometricAttention" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="exp_map", style="solid"];
"src.core.attention.geometric.HyperbolicLogarithm" -> "src.core.tiling.quantum_geometric_attention.GeometricStructures" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="log_map", style="solid"];
"src.core.attention.geometric.HyperbolicLogarithm" -> "src.core.tiling.quantum_geometric_attention.QuantumGeometricAttention" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="log_map", style="solid"];
"src.core.attention.geometric.ParallelTransport" -> "src.core.attention.geometric.GeometricStructures" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="transport", style="solid"];
"src.core.attention.geometric.ParallelTransport" -> "src.core.tiling.quantum_geometric_attention.GeometricStructures" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="transport", style="solid"];
"src.core.attention.geometric.ParallelTransport" -> "src.core.tiling.quantum_geometric_attention.QuantumGeometricAttention" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="transport", style="solid"];
"src.core.metrics.evolution.ErgodicAnalysis" -> "src.core.metrics.evolution.EvolutionAnalyzer" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="ergodic", style="solid"];
"src.core.metrics.evolution.FlowEvolution" -> "src.core.metrics.evolution.EvolutionAnalyzer" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="flow", style="solid"];
"src.core.metrics.evolution.LFunctionComputation" -> "src.core.metrics.evolution.EvolutionAnalyzer" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="l_function", style="solid"];
"src.core.metrics.evolution.OrbitAnalysis" -> "src.core.metrics.evolution.EvolutionAnalyzer" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="orbit", style="solid"];
"src.core.metrics.height_theory.HeightStructure" -> "src.core.metrics.height_theory.AdaptiveHeightTheory" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="height_structure", style="solid"];
"src.core.models.base.LayerGeometryDict" -> "src.core.models.base.ModelGeometry" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="layers", style="solid"];
"src.core.performance.cpu.algorithms.BranchOptimizer" -> "src.core.performance.cpu.algorithms.AlgorithmOptimizer" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="branch_opt", style="solid"];
"src.core.performance.cpu.algorithms.BranchOptimizer" -> "src.core.performance.cpu.algorithms.AlgorithmOptimizer" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="branch_opt", style="solid"];
"src.core.performance.cpu.algorithms.BranchOptimizer" -> "src.core.performance.cpu.algorithms.AlgorithmOptimizer" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="branch_opt", style="solid"];
"src.core.performance.cpu.algorithms.FastPathOptimizer" -> "src.core.performance.cpu.algorithms.AlgorithmOptimizer" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="fast_path", style="solid"];
"src.core.performance.cpu.algorithms.FastPathOptimizer" -> "src.core.performance.cpu.algorithms.AlgorithmOptimizer" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="fast_path", style="solid"];
"src.core.performance.cpu.algorithms.FastPathOptimizer" -> "src.core.performance.cpu.algorithms.AlgorithmOptimizer" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="fast_path", style="solid"];
"src.core.performance.cpu.algorithms.FastPathOptimizer" -> "src.core.performance.cpu.algorithms.AlgorithmOptimizer" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="fast_path", style="solid"];
"src.core.performance.cpu.algorithms.InstructionCounter" -> "src.core.performance.cpu.algorithms.AlgorithmOptimizer" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="instruction_counter", style="solid"];
"src.core.performance.cpu.algorithms.LoopOptimizer" -> "src.core.performance.cpu.algorithms.AlgorithmOptimizer" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="loop_opt", style="solid"];
"src.core.performance.cpu.algorithms.LoopOptimizer" -> "src.core.performance.cpu.algorithms.AlgorithmOptimizer" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="loop_opt", style="solid"];
"src.core.performance.cpu.algorithms.LoopOptimizer" -> "src.core.performance.cpu.algorithms.AlgorithmOptimizer" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="loop_opt", style="solid"];
"src.core.performance.cpu.algorithms.NumericalOptimizer" -> "src.core.performance.cpu.algorithms.AlgorithmOptimizer" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="numerical_opt", style="solid"];
"src.core.performance.cpu.algorithms.NumericalOptimizer" -> "src.core.performance.cpu.algorithms.AlgorithmOptimizer" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="numerical_opt", style="solid"];
"src.core.performance.cpu.memory.CacheOptimizer" -> "src.core.performance.cpu.memory.MemoryManager" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="cache_optimizer", style="solid"];
"src.core.performance.cpu.memory.MemoryPool" -> "src.core.performance.cpu.memory.MemoryManager" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="pool", style="solid"];
"src.core.performance.cpu.memory.MemoryPool" -> "src.core.performance.cpu.memory.MemoryManager" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="pool", style="solid"];
"src.core.tiling.arithmetic_dynamics.ArithmeticDynamics" -> "src.core.tiling.geometric_flow.GeometricFlow" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="arithmetic", style="solid"];
"src.core.tiling.arithmetic_dynamics.ArithmeticPattern" -> "src.core.tiling.quantum_geometric_attention.QuantumGeometricAttention" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="arithmetic", style="solid"];
"src.core.tiling.geometric_flow.PatternFlow" -> "src.core.tiling.quantum_geometric_attention.QuantumGeometricAttention" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="flow", style="solid"];
"src.core.tiling.geometric_flow.RiemannianMetric" -> "src.core.tiling.geometric_flow.GeometricFlow" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="metric", style="solid"];
"src.core.tiling.optimization.parameter_manager.ParameterMonitor" -> "src.core.tiling.optimization.parameter_manager.AdaptiveParameterManager" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="monitor", style="solid"];
"src.core.tiling.patterns.cohomology.AdvancedMetricsAnalyzer" -> "src.core.tiling.patterns.cohomology.MotivicCohomology" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="metrics", style="solid"];
"src.core.tiling.patterns.cohomology.ArithmeticDynamics" -> "src.core.patterns.motivic_riemannian.MotivicRiemannianStructure" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="dynamics", style="solid"];
"src.core.tiling.patterns.cohomology.ArithmeticDynamics" -> "src.core.tiling.patterns.cohomology.MotivicCohomology" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="dynamics", style="solid"];
"src.core.tiling.patterns.cohomology.HeightStructure" -> "src.core.patterns.motivic_riemannian.MotivicRiemannianStructure" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="height_structure", style="solid"];
"src.core.tiling.patterns.cohomology.HeightStructure" -> "src.core.tiling.patterns.cohomology.MotivicCohomology" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="height_structure", style="solid"];
"src.core.tiling.patterns.cohomology.MotivicCohomology" -> "src.core.patterns.motivic_riemannian.MotivicRiemannianStructure" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="motive", style="solid"];
"src.core.tiling.patterns.cohomology.MotivicCohomology" -> "src.core.tiling.patterns.cohomology.QuantumMotivicCohomology" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="motivic", style="solid"];
"src.core.tiling.quantum_attention_tile.QuantumMotivicTile" -> "src.core.tiling.quantum_geometric_attention.QuantumGeometricAttention" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="attention", style="solid"];
"src.core.tiling.state_manager.StateType" -> "src.core.tiling.state_manager.StateConfig" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="type", style="solid"];
"src.core.vulkan.memory.MemoryBlock" -> "src.core.vulkan.resources.BufferResource" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="memory", style="solid"];
"src.core.vulkan.memory.MemoryBlock" -> "src.core.vulkan.resources.ImageResource" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="memory", style="solid"];
"src.core.patterns.riemannian.PatternRiemannianStructure" -> "src.core.tiling.patterns.cohomology.DeRhamCohomology" [arrowhead="odiamond", arrowtail="none", fontcolor="green", label="manifold", style="solid"];
"src.core.patterns.riemannian.PatternRiemannianStructure" -> "src.core.tiling.patterns.cohomology.Integration" [arrowhead="odiamond", arrowtail="none", fontcolor="green", label="manifold", style="solid"];
"src.core.patterns.riemannian.PatternRiemannianStructure" -> "src.core.tiling.patterns.cohomology.QuantumMotivicCohomology" [arrowhead="odiamond", arrowtail="none", fontcolor="green", label="metric", style="solid"];
"src.core.patterns.riemannian.RiemannianFramework" -> "src.core.patterns.evolution.PatternEvolution" [arrowhead="odiamond", arrowtail="none", fontcolor="green", label="framework", style="solid"];
"src.core.tiling.patterns.cohomology.ArithmeticDynamics" -> "src.core.patterns.motivic_riemannian.MotivicChristoffelSymbols" [arrowhead="odiamond", arrowtail="none", fontcolor="green", label="dynamics", style="solid"];
"src.core.tiling.patterns.cohomology.FiberBundle" -> "src.core.tiling.patterns.cohomology.CohomologyGroup" [arrowhead="odiamond", arrowtail="none", fontcolor="green", label="base_space", style="solid"];
"src.core.tiling.patterns.cohomology.HeightStructure" -> "src.core.patterns.motivic_riemannian.MotivicMetricTensor" [arrowhead="odiamond", arrowtail="none", fontcolor="green", label="height_structure", style="solid"];
"src.core.tiling.patterns.cohomology.MotivicCohomology" -> "src.core.patterns.motivic_riemannian.MotivicCurvatureTensor" [arrowhead="odiamond", arrowtail="none", fontcolor="green", label="motive", style="solid"];
"src.core.tiling.patterns.cohomology.RiemannianFiberBundle" -> "src.core.tiling.patterns.cohomology.MotivicCohomology" [arrowhead="odiamond", arrowtail="none", fontcolor="green", label="base_space", style="solid"];
"src.core.tiling.state_manager.StateConfig" -> "src.core.tiling.state_manager.StateManager" [arrowhead="odiamond", arrowtail="none", fontcolor="green", label="config", style="solid"];
"src.core.vulkan.memory.VulkanMemory" -> "src.core.vulkan.resources.VulkanResources" [arrowhead="odiamond", arrowtail="none", fontcolor="green", label="memory", style="solid"];
}
